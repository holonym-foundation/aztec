{"noir_version":"0.30.0+a2f687687559d15fde52abce54838f6e144a0aa4","name":"TokenBridge","functions":[{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/+2b227aQBCG18RJTJ24YGMMgQQIyUXvDA2nO16mfe3eV+orVM2YnTJsp2hRx1tWYqWIsb2e/5t/D1jICdSuRe9/gY6v9eeN+rNhn63+LP+tzQRzlXVyBp5wNjzhvPKEMxTkDBhO+Ax1DOsO1tytOlyPv9tWqChTlELBBLoi19URwIMboUU6oBfHUuDrcnNDklNwpcFDfQ0/ASfW1yhYrIus+pBzWGiDnEOdK3IOd0bUibQpwvUuoj2yXN73CQA1NHUu5I5JTK8NiXVhTTVey9f4VsuYlLtVjGNyrXPfkmP0Cj0U/OaYUe1A/zWJptJjhPGA9MV+6EeDjDG0e7Wf180j94XGfQnpc8PUPxau/9bgMecsjEFLx204xj2BsH0g9W1l2ErIG8vnndExCHVu5I9JTYm43/M15L9Th838VhqTOCE89+I85ayeOndj95Gwy+RdvIFXLcOrO8OrhPShDK0a/AuILubG4xajLefFcg3abQsv2gxP27EXbUZb0IsNaKcWXqQMT+rYi5TRlvNi9Rm0MwsvMoYnc+xFxmjLeTGvni06Fl50GJ6OYy86jLbgGqnmRW7hRc7w5I69yBltQS++gnbXwosuw9N17EWX0Rb04gtoFxZeFAxP4diLgtEW3Dur54uehRc9hqfn2Iseoy3oxRy0+xZe9BmevmMv+oy24BqptB8svHhgeB4ce4F6pzJ3PGQuPGTOzoA5MmIZ7WW1fw4svBgwPAPHXtDfck5hzs+AOTJiGe3lArSHFl4MGZ6hYy9Q71Tm1EPmzEPmrofMuYfMhYfM5zCfIyOW0V5Ve+ijhRePDM+jYy9Q71Tm1EPmgYfM2RkwR0Yso72qfpt7svDiieF5cuwF6p3K3POQuX0GzJERy2ivlqA9svBixPCMHHuBeqcy9z1kLjxkHnjInHnI3PWQOfeQ+bIG3TCnZ8AM773gOzA/auWZb2KDBz1TBqMyGGMSJ4QR+26V3PsqiVE7ak3E/diNjzlf8HhSq/Z8DXmn8jVVz/IvOhe+wzdlanrVcSDs5wvJGxAdPB+S+Dvpi/3QD1y3yA7vXD3r+PXIfSPjvoT0eWbqHwvXPzV4pgYzjMk3wlHH3LKZ1y21X8ufCE8N++AbfScXm82+Q/cYQZ5ZTXWW9B2+n0p2TU8Mr5qGVwnpQ/fo/7VvXpgvzH9jps8TTXKO8uC5hlEL/f+GCcnxC57ToyHuNQAA","debug_symbols":"ndpBattQGIXRvWgciu/vJz3JWymlOIlTDMYOsVMoJnuv3ZIF5Mz0JN3ZNzq86/C8e3z/9XN/fDmdh83363A4PW0v+9PxdroOq281/3t7ft0e7y/Ol+3bZdisez0Mu+Pz/al/PAwv+8Nu2LT+8ePhvlm+vlmvYBPYFGzWsGmwGWEzwabDBjpYQwcNOmjQQYMOGnTQoIMGHTTooEEHDTpo0MEIHYzQwQgdjNDBCB2M0MEIHYzQwQgdjNDBBB1M0MEEHUzQwQQdTNDBBB1M0MEEHUzQQYcOOnTQoYMOHXTooEMHHTro0EGHDjp0MEMHM3QwQwczdDBDBzN0MEMHM3QwQwczdLBABwt0sEAHC3SwQAcLdLBABwt0sEAHC3SQ1UpGkVHJaC2jJqNRRpOMuoxmGUkRkSIiRUSKiBQRKSJSRKSISBGRIiJFlBRRUkRJESVFlBRRUkRJESVFCDZGtDHCjRFvjIBjRBwj5Bgxxwg6RtQxwo4Rd4zAY0QeI/QYsccIPkb0McKPEX+MAGREICMEGTHICEJGFDLCkBGHjEBkRCIjFBmxyAhGRjQywpERj4yAZEQkIyQZMckISkZUMsKSEZeMwGREJiM0GbHJCE5GdDLCkxGfjABlRCgjRBkxyghSRpQywpQRp4xAZUQqI1QZscoIVka0MsKVEa+MgGVELCNkGTHLErMsMcsSsywxyxKzLDHLErMsMcsSsywxyxKzLDHLErMsMcsSsywxyxKzLDHLErMsMcsSsywxyxKzLDHLErMsMcsSsywxy6ILkmKWJWZZYpYlZlliliVmWWKW9VWzvB1+b9/228fD7n4V9v7t/fj0eTP2drz8ef3/5fbvXw=="},{"name":"_assert_token_is_same","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"1d3hah5HFoThe9Fvs8yc6nO627eyLIuTOIvAyCFWFhaTe9/Pm09ygkWybzknSL9s2dOjwVVlzMNI/njz3dtvfvrXP2/vvn//4eb13z/evHv/7Zv72/d3l48+3hx/2//7xQ8/vLn79PGH+zc/3t+8Pl7dvL377vLjz69uvr999/bm9Zg/v/risl26XrhXPl5a64lLM/Lhppef7seLz/Opqysyr1dXzPM3V//j1eWpz+MrHvs8xsOV51Hx1z74+TV/3nt/fm79/nPHMR/CiTP+6LnnOMf16jlyPvHc0fLcv9xbjfcejffOxntX471n471X4713373jaLz32Xjvxl1G4y6jcZfRuMto3GU07jIadxmNu1TjLtW4SzXuUo27VOMu1bhLNe5SjbtU4y7VuMvRuMvRuMvRuMvRuMvRuMvRuMvRuMvRuMvRuMvRuMts3GU27jIbd5mNu8zGXWbjLrNxl9m4y2zcZTbushp3WY27rMZdVuMuq3GX1bjLatxlNe6yGndZjbucjbucjbucjbucjbucjbucjbucjbucjbucjbucjbtcjbtcjbtcjbtcjbtcjbtcjbtcjbtcjbtcjbtcjbvcjbvcjbvcjbvcjbvcjbvcjbvcjbvcjbvcjbvcjbs8j6Pz5mfnzTtfLTg63y04RufNO98uODpfLzg63y84Ol8wODoXenYu9OxcaOvLP61v/7S+/vNV7//kuR7ez8pz//ZNsSfeKxtHXa+uEU++V/Y1i/7TX3L7//8GuB5Y9MCGB8ALPtcDJz0Q9IDogUEPJD1Q9ABNOmjSQZMWTVo0adGkRZMWTVo0adGkRZMWTVo06UGTHjTpQZMeNOlBkx406UGTHjTpQZMeNOmkSSdNOmnSSZNOmnTSpJMmnTTppEknTbpo0kWTLpp00aSLJl006aJJF026aNJFk5406UmTnjTpSZOeNOlJk5406UmTnjTpSZNeNOlFk1406UWTXjTpRZNeNOlFk1406UWT3jTpTZPeNOlNk9406U2T3jTpTZPeNOkNk47joAdOeiDoAdEDgx5IeqDogUkPLHqAJn3SpE+a9EmTPmnSJ036pEmfNGlqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRiRqZqJGJGpmokYkamaiRiRqZqJGJGpmokYkamaiRiRqZqJGJGpmokYkamaiRiRqZqJGJGpmokYkamaiRiRqZqJGJGpmokYkamaiRiRqZqJGJGpmokYkamaiRiRqZqJGJGpmokYkamaiRiRqZqJGJGpmokYkamaiRiRqZqJGJGpmokYkamaiRiRqZqJGJGpmokYkamaiRiRqZqJGJGpmokYkamaiRiRqZqJGJGpmokYkamaiRiRqZqJGJGpmokYkamaiRiRqZqJGJGpmokYkamaiRiRqZqJGJGpmokYkamaiRiRqZqJGJGpmokYkamaiRiRqZqJHpaSOreT5+AdhU/vrYE99t/dTDF7qdZ43HiyufuPhS3uu1Iz5/F/JPXx73xaUXAL9eqk9fpfb50uuT7xf65ONpNXwRT36+2CePF/vkerFPPjqf/Po58i/4HPUnfI45Hj/Hrt9P4HLFerg4jl/9Xw3j8Ynms3ui9eyeaD+3JzqPZ/dE57N7onh2T/THf/+O/OIfVuMc3rH0jpV3bHrHlndsW8fi8I6d3rHwjnktCa8l4bUkvJaE15LwWhJeS+S1RF5L5LVEXkvktUReS+S1RF5L5LVEXkuG15LhtWR4LRleS4bXkuG1ZHgtGV5LhteS4bUkvZak15L0WpJeS9JrSXotSa8l6bUkvZak15LyWlJeS8prSXktKa8l5bWkvJaU15LyWlJeS6bXkum1ZHotmV5LpteS6bVkei2ZXkum15LptWR5LVleS5bXkuW1ZHktWV5LlteS5bVkeS1ZXku215LttWR7LdleS7bXku21ZHst2V5LtteSbbUkj8M7dnrHwjsm79jwjqV3rLxj0zu2vGNeS06vJafXktNriWev6dlrevaanr2mZ6/p2Wt69pqevaZnr+nZa3r2mp69pmev6dlrevaanr2mZ6/p2Wt69pqevaZnr+nZa3r2mp69pmev6dlrevaanr2mZ6/p2Wt69pqevaZnr+nZa3r2mp69pmev6dlrevaanr2mZ6/p2Wt69pqevaZnr+nZa3r2mp69pmev6dlrevaanr2mZ6/p2Wt69pqevaZnr+nZa3r2mp69pmev6dlrevaanr2mZ6/p2Wt69pqevaZnr+nZa3r2mp69pmev6dlrevaanr2mZ6/p2Wt69pqevaZnr+nZa3r2mp69pmev6dlrevZanr2WZ6/l2Wt59lqevZZnr+XZa3n2Wp69lmev5dlrefZanr2WZ6/l2Wt59lqevZZnr+XZa3n2Wp69lmev5dlrefZanr2WZ6/l2Wt59lqevZZnr+XZa3n2Wp69lmev5dlrefZanr2WZ6/F7fXywb/f/Hj75pt3bz9cjnz6vZ/uvr2/fX93/fD+Pz/88juXa/8L"},{"name":"exit_to_l1_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"5Z3djhzHlYTfhdfCIs9vZupVFosFbcsLAgJlWPQChuB3d9Oaqm5CRRYHrIyOA155ZJU6IjmM79T0xOn67c1ffvrTP/7vf9+9/+svv7758b9/e/PzL39+++HdL+9v//Tbm/Zfov/5f3/929v3H/+PXz+8/fuHNz+2H9789P4vt//91w9v/vru55/e/Oj9X//zw8fr7ZXX+yuvj1den6+8vr/y+vHK6+frrtf2yuvllde/8vurr/z+6td/f3/4w2Uz7eXCOWK/NMfBpaGxvejty7lfLHJ0dWrEy9WpXT65+nfb8Q22pfl2pbRUrPH8lj/vOe++7cu+tfXtm6OiZ767i79c3T36ge++xPfvrz0WvvZc99rWFr62LHxtXfjatvC1feFrx8LXzoWvvTCXtjCXtjCXvjCXvjCXvjCXvjCXvjCXvjCXvjCXvjCXvjCXvjCXsTCXsTCXsTCXsTCXsTCXsTCXsTCXsTCXsTCXsTCXuTCXuTCXuTCXuTCXuTCXuTCXuTCXuTCXuTCXuTCXfWEu+8Jc9oW57Atz2Rfmsi/MZV+Yy74wl31hLvvCXI6FuRwLczkW5nIszOVYmMuxMJdjYS7HwlyOhbkcC3M5F+ZyLszlXJjLuTCXc2Eu58JczoW5nAtzORfmci7MpbS28sVl5Yvryhe3lS/uK188Vr54rnzxvvLFx8oXX5lQWZlQWZlQWZlQWZlQWZlQWZlQWZlQWZlQWZlQWZlQXZlQXZlQXZlQXZlQXZlQXZlQXZnQlV0gWVkGkpVtIDmuA+mY+vKf6YwTCZUu28XS7800HbaJCEJEESL27SLacrtY/VORg+/fkP37J/fvn+pRRdDm9sri9snFL+69tPso7T5Lu++l3Y/S7mdl995Ku5fS7rW0+9Kz1kvPWi89a730rPXSs9ZLz1ovPWuj9KyN0rM2Ss/aKD1ro/SsjdKzNkrP2ig9a6P0rI3SszZLz9osPWuz9KzN0rM2S8/aLD1rs/SszdKzNkvP2iw9a3vpWdtLz9peetb20rO2r521LyKBELlicmXfRcaEfh96afejtPtZ2f1opd1Lafda2r2Vdu+l3Udp96Vn7Sg9a0fpWTtKz9pZetbO0rN2lp61s/SsnaVn7Sw9a2fpWTtLz9pZetbOyrNWW+VZq63yrNVWedZqqzxrtVWetdoqz1ptlWettsqzVlvlWaut9KyV0rNWSs9aKT1rpfSsldKzVkrPWik9a2XtrH0RGQiRCyaX6fZZAWoB/T5oK+1eSrvX0u6ttHsv7T5Ku8/S7ntp96O0+9Kz1krPWis9a630rLXSs/aKzzR6ovvSs9ZKz1orPWut9Ky10rPWS89aLz1rvfSs9dKz9orPNHqi+9Kz1kvPWi89a730rPXSszZKz9ooPWuj9KyN0rP2is80eqL70rM2Ss/aKD1ro/SsjdKzNtfO2hcRQYhcMLlCbLs4NI9EDCHiCJFAiCRCpCNEBkJkAkSu+GSVcxFBiCAS3xGJ74jEd0TiOyLxHZH4jkh8RyR+IBI/EIkfiMQPROIHIvEDkfiBSPxAJH4gEj8QiZ+IxE9E4ici8ROR+IlI/EQkfiISPxGJn4jET0DirTWEiCBEFCFiCBFHiARCJBEiHSEyECKIxAsi8YJIvCASL4jECyLxgki8IBIviMQLIvGCSLwiEq+IxCsi8YpIvCISr4jEKyLxiki8IhKviMQbIvGGSLwhEm+IxBsi8YZIvCESb4jEGyLxhki8IxLviMQ7IvGOSLwjEu+IxDsi8Y5IvCMS74jEByLxgUh8IBIfiMQHIvGBSHwgEh+IxAci8YFIfCISn4jEIzp3hujcGaJzZ4jOnSE6d4bo3Bmic2eIzp0hOneG6NwZonNniM6dITp3hujcGaJzZ4jOnSE6d4bo3Bmic2eIzp0hOneG6NwZonNniM6dITp3hujcGaJzZ4jOnSE6d4bo3Bmic2eIzp0hOneG6NwZonNniM6dITp3hujcOaJz54jOnSM6d47o3HlzhEggRBIh0hEiAyGCSDyic+eIzp0jOneO6Nw5onPniM6dIzp3jujcOaJz54jOnSM6d47o3Dmic+eIzp0jOneO6Nw5onPniM6dIzp3jujcOaJz54jOnSM6d47o3Dmic+eIzp0jOneO6Nw5onPniM6dIzp3jujcOaJz54jOnSM6d47o3Dmic+eIzp0jOneO6Nw5onPniM6dIzp3jujcOaJz54jOnSM6d47o3Dmic+eIzp0jOneO6Nw5onPniM6dIzp3jujcOaJz54jOnSM6d47o3Dmic+eIzp0jOneO6Nw5onPniM6dIzp3jujcOaJz54jOnSM6d47o3Dmic+eIzp0jOneO6Nw5onPniM6dIzp3jujcOaJz54jOnSM6d47o3Dmic+eIzp0jOneO6Nw5onPniM5dIDp3gejcBaJzF4jOXTRHiARCJBEiHSEyECKIxCM6d4Ho3AWicxeIzl0gOneB6NwFonMXiM5dIDp3gejcBaJzF4jOXSA6d4Ho3AWicxeIzl0gOneB6NwFonMXiM5dIDp3gejcBaJzF4jOXSA6d4Ho3AWicxeIzl0gOneB6NwFonMXiM5dIDp3gejcBaJzF4jOXSA6d4Ho3AWicxeIzl0gOneB6NwFonMXiM5dIDp3gejcBaJzF4jOXSA6d4Ho3AWicxeIzl0gOneB6NwFonMXiM5dIDp3gejcBaJzF4jOXSA6d4Ho3AWicxeIzl0gOneB6NwFonMXiM5dIDp3gejcBaJzF4jOXSA6d4Ho3AWicxeIzl0gOneB6NwFonMXiM5dIDp3gejcBaJzF4jOXSA6d4Ho3AWicxeIzl0gOneB6NwlonOXiM5dIjp3iejcZXOESCBEEiHSESIDIYJIPKJzl4jOXSI6d4no3CWic5eIzl0iOneJ6NwlonOXiM5dIjp3iejcJaJzl4jOXSI6d4no3CWic5eIzl0iOneJ6NwlonOXiM5dIjp3iejcJaJzl4jOXSI6d4no3CWic5eIzl0iOneJ6NwlonOXiM5dIjp3iejcJaJzl4jOXSI6d4no3CWic5eIzl0iOneJ6NwlonOXiM5dIjp3iejcJaJzl4jOXSI6d4no3CWic5eIzl0iOneJ6NwlonOXiM5dIjp3iejcJaJzl4jOXSI6d4no3CWic5eIzl1eUiKL/eIIPxC5pER2KnLBN/42w7eLs/cjEUeIBEIkESIdIXIB6rvtF/eYn4j88Wpp0l+ulmZjv1pCNkuTztIVta6rLQmfJeWzZHyWnM9S8FlKuKXMzdLt608s/fHqmBtXs91tqMdmv9e2P2rbn5Xt99Zq2xdq+6my2Tc5sq+17Vtt+17bftS2zz11b79N2eznoX3uqXtqn3vqntrnnrpn9oUcnKNt9oce2ScH55l97uiO3O555sO1D/a5oztjeydzph/Z547umX3lvmE+tc99w3xqn/uG+dQ+N/dP7XNz/9Q+9w3zg/1uR/a5b5hP7XNP3bn/2mr2cWSffOp6ftk++dQ9sW/kU/fMPvnUPbNPPnXn9tPWnPPIPvnUHfFl+8dTd46Nt9ZknthvuhnSFvffzcaRexvbta73S+eRdR3bn7zJeLz0xXmUdZ5lnfeyzkdZ57Oq889solRwLiudv2goQMMu0Mi+a4z55e9A378DfcZ9Mvnc/DiZnyDzk2R+OpmfQeZncvmJBvaTtvvJT/wc3Ina/s5zzpNre4z9dR/ebNHtmPJ9HFO/j2Pa93FM/z6OGd/HMfP7OGb/Po45vo9jzu/imPl93AV9Zj9zZtuPqSfHNOn7z8G3c979fPyh+I9+psT99nN+cvWLpcM7Fmv9/ic/7cuWRMz2tzcfftOWsfQn/uMV0RLOvazzKOs8yzrvK52/aAyAxrxAo/uu8QDuw+/A7YoNxqKtP5B7c3S8oftUR0LnSOkcGZ0jp3N0zGlpfSfNA5UOHYXsN18hU05uNNLbxrt0lYMbjf4ZAO93YiZ+8od0AsrelyuM5QpztcJoyxVkuYIuV7DlCr5cIZYrLM/0WJ7psTzTY3mm5/JMz+WZnsszPZdnei7P9Fye6bk80/PbMy3q+1aEfPywlP1yzcPrm+wNrPawfna/Y5qD0dTkMzVaYzQljKaU0ZQxmnJGU8FoKhlNERJ9NEKij8ZIdGEkujASXRiJLoxEF0aiCyPRhZHowkh0fQKn7h9fePvy4S1T2TwJoacnZC/6fnk8rK3cPQWhpyT01Ak9DUJPk8+TNUJPQuhJCT0ZoafVHH+RCYxMYmQ6RmZgZCZExhtGRjAyipExjAyGAo6hgF9BgdiX6G5fd/3mHyy8M5oajKYmoalojKaE0ZQymjJGU85oKhhNMRI9GIkejEQPRqInI9GTkej5BCScvf+YSejpCX/Nz36+743QkxB6UkJPRujJCT0Foack9NQJPQ1CT6s5/rvMaBgZwcgoRsYwMo6RCYxMYmQ6RmZgZDAUmBgKzEsosH9spGha++YfLKYymjJGU85oKhhNJaOpzmhqMJqafKbmJesIl5siJPpshESfjZDosxESfTZCos9GSPQpT0DCyfuPU4TQ0xP+mp/8fD8lCD0loadO6GkQepp8nrQRehJCT0royQg9reb4i0xgZBIj0zEyAyMzITLWMDKCkVGMjGFkMBQwDAUuaYvfP3xddDx8/PpnOGu+3y/bw4tr081UZzQ1GE1NQlOXtNwvNyWMppTRlDGackZTwWiKkejOSHRnJLozEj0YiR6MRA9Gogcj0YOR6MFI9GAkejASPRiJHoxET0aiJyPRk5HoyUj0ZCR6MhI9n4GE/dNCxR4fmrKb6o3R1BP+onvbfw/gD8+JeTDljKaC0VQymuqMpp5w6+Lj/guvx3eHb6YOrr5/5kB/uHZvg/RZ/ACjVT+AVD+AVj+AsR9gbk7kcdzeD+DVDxDVD5DVD9CLH2CyY1Rl+/FCHz/7534AdoyeHoA9xNb3J0mOwwM8I8T70y1vB5CTA/S5PaFqtKO70dmrH2D17fSLzETISGsNpCMgHQXpGEjHQToB0kmQTgfpDJAOiAcC4oGAeCAgHgiIBwLigYB4ICAeCIgHAuKBgHigIB4oiAcK4oGCeKAgHiiIBwrigYJ4oCAeKIgHX7FAkPplnRi2ycR8eIqxtKMHE5vP7cHKln5/W+X4McZD9g/rGNLzk6u3E0j5E2j5E1j5E3j5E0T5E2T5E/TyJxjlTzCrn8DLz2QvP5O9/Ez28jP5K1Z52E9QfiZ7+Zns5Weyl5/JXn4mR/mZHOVncpSfyVF+Jn/FMhb7CeAzuefWYrHe/dBTEnrqhJ4GoafJ5ykboSch9KSEnozQkxN6IuR4EnI8CTmehBxPQo53Qo53Qo53Qo53Qo53Qo53Qo53Qo53Qo53Qo53Qo4PQo4PQo4PQo4PQo4PQo4PQo4PQo4PQo4PQo4PQo5PQo5PQo5PQo5PQo5PQo5PQo5PQo5PQo5PQo5PPo5L4+O4ND6OS+PjuDQ+jkvj47g0Po5L4+O4ND6OS+PjuDRCjgshx4WQ40LIcSHkuBByXAg5LoQcF0KOCyHHhZDjSshxJeS4EnJcCTmuhBxXQo4rIceVkONKyHEl5LgRctwIOW6EHDdCjhshx42Q40bIcSPkuBFy3Ag57oQcd0KOOyHHnZDjTshxJ+S4E3LcCTnuhBx3Qo4HIceDkONByPEg5HgQcpxwn1MI9zmFcJ9TCPc5hXCfUwj3OYVwn1MI9zmFcJ9TCPc5hXCfUwj3OYVwn1MI9zmFcJ9TCPc5hXCfUwj3OYVwn1MI9zmlsz+X6uShQrcTsD+Y6vwE7M+IPD8B+0MidWzPFdKpRyegf0rk+Qnon292egL6B5ydnoD9QZHnJ/BCJ8jDE7A/Ze78BPQz+fQE9DP59AT0M/n0BJVm8uEJZqWZfHwC9plsul1sLocnYJ/J5ydgn8nnJ2CfyecnoH/y6+kJ2Gfy+QnYZ/LDCaIdnoB9Jp+fgH0mm47NSR6dQBv7TL69h3ZyAvqZfHoC+pl8egL6mfzlJ4HfTkA/k09PUPxp7LcT0M/k0xPQz+TTE9DP5NMT0M/ksxPIE+aBDdkut+mfnGBzZZSunNJVULpKSlfPYKZtvwC7fTkPXQ1KV5PRlTZKV0LpSildGaUrp3QVlK6S0hUl25WS7UrJdqNku1Gy3SjZbpRsN0q2GyXbjZLtRsl2o2S7UbLdKdnulGx3SrY7Jdudku1OyXanZLtTst0p2e6UbA9Ktgcl24OS7UHJ9qBke1CyPSjZHpRsD0q2ByXbk5LtScn2pGR7UrI9KdmelGxPSrYnJduTku1JyfZOyfZOyfZOyfZOyfZOyfZOyfZOyfZOyfZOyfZOyfZByfZByfZByfZByfZByfZByfZByfZByfZByfZByfZJyfZJyfZJyfZJyfZJyfZJyfZJyfZJyfZJyfbJyHZrjGy3xsh2a4xst8bIdmuMbLfGyHZrjGy3xsh2a4xst0bJdqFku1CyXSjZLpRsF0q2CyXbhZLtlHupRrmXapR7qUa5l2qUe6lGuZdqlHupRrmXapR7qUa5l2qUe6lGuZdqlHupRrmXapR7qUa5l2qUe6lGuZdqlHupRrmXapR7qUa5l2qUe6lGuZdqlHupRrmXapR7qUa5l2qUe6lGuZdqlHupRrmXapR7qUa5l2qUe6lGuZdqlHupRrmXapR7qUa5l2qUe6lGuZdqlHupRrmXapR7qUa5l2qUe6lGuZdqlHupRrmXapR7qUa5l2qUe6lGuZdqlHupRrmXapR7qUa5l2qUe6lGuZdqlHupRrmXapR7qUa5l2qUe6lGuZdqlHupRrmXak/ZS23782Fcj10lpatO6WpQupqMrp6yl3ruSihdKaUro3TllK4o2T4p2T4p2T4p2T4Z2e6Nke3eGNnujZHt3hjZ7o2R7d4Y2e6Nke3eGNnujZHt3ijZLpRsF0q2CyXbhZLtQsl2oWS7ULJdKNkulGwXSrYrJduVku1KyXalZPslu5YxYneVj88yP3YVsb/fHtHvLy67qc5oajCamoSmLtmzvNyUMJpSRlPGaMoZTQWjKUaiGyPRjZHoxkh0fwbR+37vEnMemRJGU8poyhhNOaOpYDSVjKY6o6nBaGoSmgpGogcj0YOR6MFI9GAkejASPRiJHoxED0aiByPRk5HoyUj0ZCR6MhI9GYmejERPRqInI9GTkejJSPTOSPTOSPTOSPTOSPTOSPRLFu9C778aja6nps7e87xk7+5qU5es3V1uShhNKaMpYzTljKaC0VQymuqMphiJPhiJPhmJPhmJPp9B9LNbl2mMppzRVDCaSkZTndHUYDQ1+UxFa4ymhNEUIdGjERI9GiHRoxESPRoh0aMREj0aIdGjMRJdGIkujEQXRqILI9GFkejCSHRhJLowEl0YiS6MRFdGoisj0ZWR6MpIdGUkujISXRmJfsnWmue8mxI7NXXynmdcsrV2uSllNGWMppzRVDCaSkZTndHUYDQ1CU05I9GdkejOSHRnJLo/g+hnty4ejKaS0VRnNDUYTU1CU9EYTQmjKWU0ZYymGIkejEQPRqIHI9GDkejBSPRkJHoyEj0ZiZ6MRE9Goicj0ZOR6MlI9GQkejISvTMSvTMSvTMSvTMSvTMSvTMSvTMSvTMSvTMS/XhrTcfc3pbUGe3LprTvjzPTHg8f+jrsyFLL/deot6/3qyXk4Ooc7eXiHA+/cfXY/Ru1/963xdU+8tC/F/cfxf1ncf+9uP/B7T/77r8f+p+1/R9vAxbyL8X9c8/fc//k8/fUP/n8vfufh/yc5PP31D/5/N0vHk0O/ZPP32wn/tnn75l/9vn7Zf/ZuOfvkO3+bage+ueev+f+uefvuX/u+Xvun3v+jv2Dp8Y8zi/3/D33zz1/z/1zz99z/9zz99w/9/wdve/+D/kj5PP31D/5/D31Tz5/T/2Tz99T/+Tz99Q/+fzd/c/j+38hn789d/956J98/u6/Lvucf/L5e+qffP6e+Vfy+Xvqn3z+nvonn7+n/snn76n/C/h/3yG6femf+N9UOkRlQFQmQsUaROUCesQ+ojWGHKooRMUgKg5RCYjKFdnff0DX23uBhyodojIgKhOh4g2iIhAVhagYRMUhKgFRuSL7GXfC6KFKh6gMiMpEqESDqAhERSEqBlFxiEpAVCDZD0j2A5L9gGQ/IdlPSPYTkv2EZD8h2U9I9hOS/YRkPyHZT0j2OyT7HZL9Dsl+h2S/Q7LfL8h+qu/3/I+PKHtQSYhKh6gMiMpEqIwLsn97Y2pX8XmoIhAVhagYRMUhKgFRSYhKh6gMiMoV2Re7Z//wPdgr9l++QkUgKgpRMYiKQ1QCopIQlQ5RGRAVRPZ7axAVgagoRMUgKg5RCYhKQlQ6RGVAVCDZF0j2BZJ9gWRfINkXSPYFkn2BZF8g2b+iJ3l7k21X6XmoMhEqV3QOv0JFICoKUbki+/tHuWhvh3/H1CEqAVFJiEqHqAyIykSoXNHr+woVgahckf2Y9+z3QxWDqDhEJSAqCVHpEJUBUZkIlSt6fV+hIhAVSPYdkn2HZN8h2XdI9h2SfYdk3yHZD0j2A5L9gGQ/INkPSPYDkv2AZD8g2Q9I9gOS/YRkPyHZT0j2E5L9hGQ/IdlPSPYTkv2EZD8h2e+Ls3/7p/9/+/d3b//080+/3v6bj//yH+///OHdL+9f/vHDP//2+7+5Xftv"},{"name":"get_portal_address_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/9VZ227aQBC1XRJIuN8vyYM/ASKatG/koa+t1B9ADtgVEgkRhor2qf2AVuoPozLOTjpMR2QRayuMZO3ssjvn7NmLvYttPdmbzWMr/4SUccM6A5V2D7OewVjdOHnaR8LTMcjTJjzp/Hg2k+KmCBAVx2F5rOOwMrAfxG+r9HY+9765k4exv3Jny4U7C9y72fJhHNKGv4h/odKRN526i5nrhaE/XwzvvdXwbrIYhpPv/jPoH5VmSHvXlDDvuv1TEpyvRhDAUb9hCryyFhFNlWdJe5uUoejYPr15zizSJvMPC6xMylCD881TUr739f7T42g29m/H47kfbmmMuwotW1v/m2680z3itXi8j8vpdBJM/PmH1SRcbMVNC3Ghy47QF8rDEXisVdsTEmeg/O5hFi0axE6p2GnGL6P6D+aaww6y1vac53ohHto54XNmnk8vpn52IW7W+Nj1fdAqx7TKMK0KpA7lkItBP5vgYmzM5wRsc1pcB4Cd19AiL/DJJ6xFXsA2p8VN31Z9fUmLgsCnkLAWBQHbnBZX0ddHUUOLosCnmLAWRQHb4Bp5D9glDS1KAp9SwlqUBGyDWkR7Z1lDi7LAp5ywFoi3L+fiEXLOHyHn16BzhvlmsK8j7IqGFhWBTyVhLSoCtkEtRoBd1dCiKvCpJqwF4u3LufgKOGeYbwb7xgPsmoYWNYFPLWEtagK2wbn8FrDrGlrUBT71hLWoC9gGtYi+lxsaWjQEPo2EtUA8OKvjuT2MlU+vm2V8wGyWd4mPHLLEp2f3pvIHlrkzNh2fJsFqGdfjaXz4fMF8K17sAOJ2zMeNzkl4Z3miYneEPl0q3+BNdo9i2+pBHCxPEf+R1MV6qAeuW+QO35N4iXu5o12DtSuQOm2h/67h/ncYnw7jDGPiEx5xzC2deQ3nIOmMhneGa3N8riDuqfm4cd3z9WC/a1rbtmufpHtiHO8RiI93fuFiNve++J99b2wTak1Gk6b8Shzz9Io6TXydK+w4ZN81banEMSyZ6Gq3HVOfcAvA7Rj5I16K1PmpUnq9gyZtLzjuGDNPtMK6jqAjjmOH5AcH9jlQRrXcJ27wgkHci8P59ngB1wp9xNL5XarbJm2arN6a5WH98c8e+qr8rVJpXtDt6pyUOSwe/NXyF6EEBGDhHwAA","debug_symbols":"5dvBattAEMbxd9HZlN3Z2Z2dvEopxUmcYjB2iJ1CMXn3yo0lN1Q4h/RvrOiUKJ7MfmPxAx1G++Z+cfv84/ty/bDZNjdf981qczffLTfr9mrfhC/+54/bx/n6cL3dzZ92zU2YNYv1ffvzZdY8LFeL5kbtZfZPmZd0LPSa+9JSB0qz5K5p+6v3xTEOVRfJ+VhdxOKb6m+zNnUMH4gdg3aVMRS5bPD4ke/b/ZQ7nc8twbqbI1Hey20a9Vhtmm0gtyC5X3snsLeCvTPYu4C9Dexdwd7O9ZYA9o5gb9ClgC4FdCmgSwFdCuhSQJcCukygywS6TKDLBLpMoMsEukygywS6TKDLBLpU0KWCLhV0qaBLBV0q6FJBlwq6VNClgi4z6DKDLjPoMoMuM+gygy4z6DKDLjPoMoMuC+iygC4L6LKALgvosoAuC+iygC4L6LKALg10aaBLA10a6NJAlwa6NNClgS4NdGmgywq6rKDLCrqsoMsKuqygywq6rKDLCrqsoEsHXTro0kGXDrp00KWDLh106aBLB1066DKGQDaPZHNytSCQuwVByebkdkEg1wsCuV8QyAWDQAqNpNBICkWXf9DtH3T9Z3j/J6rF7t9ysPNHSJByLJbw195VTgPFqXa1KqdSj0N9a5chHfa9TqXH5GW0yW20yetok/tYkw9vdY0ieRxtciGTH89IFzhD/8MZxfozqp+/A9bfAfPTMnVU7/LkK8tTriyPXVmeemV5/LrypHBleeKF8/QvT5iXN3kGnkRT9yTqxd+ptVz7vtrXinRjyjTGTNMYU6cxZp7GmGUaY9o0xqzTGNMnMaaGaYz56Z+C2ouf86fl/Ha1OLwCe/jseX3XvRHbXu5+Pb5+0tb+Bg=="},{"name":"exit_to_l1_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/+xdB5hdRfW/7+3LJmGzm0DoLS+9J+++7UlIo/fea7LZQCD0joKAqBQBQVGKKEUUVBALKKgodhFR7Nj9Y0WsoNLE/8zunOxvT+a+OuflDsz7vvPNnfum/M6ZmTNn6s1Eg7/Jo6LolRGDzxlFTYqyivLgbzLP5M8x/wgWfiTztzL/WObfmPnHM/8WipaCfwL7P8/8E5l/EvNPM378ZYy71Ljtha6Ojv7uYn/cHq8oFHtX9nQWOjpXdvXEPXFnT+eqYk97e39PR09378re7kJv3NHeH6/u7G1fXRj8/SszlFahzp/GNhqwTVf0qqIZxp1p3FnGnW1cjSG4rz13jqJ/ZwbrLNaLfwf5vO7rxX8y0bBf1rhLjVuo7xdPi9zpyBcy7nBptrVu12nmo6G2Qfxr/6vg6j7qxcxg34Xh8JdxLLvN3aVVsMCtN+2YHlAWLxkhvJwZkoerDNdlTIWnM/tlNNRRv5xZv6NuEiyUGit00VTo+KWMu8bxckamsrhWCC55fsWS1spC36rOeGXXqu64f0VnT19fb3scF1d0rehaWexZ3b+yM+7p7FFp9q0o9qjsiiv64v7Ciq5+3bA3iiyVNnLfsF/JuDX26PdfyUYnJQgE7SrdVx1WMim+X804LyMrVheKRWN1pQgoXZdl9D/HDUp3GjrNidFgj69/jejxpZS4a5wvOsQ5AoEaIWeMmzVuU3aQh01NsJzyj1DUrGikolGKRivaSFGLojGKWhW1KRqraJyijRVtomi8ok0VbaZoc0VbZBtgqWgG8iwP3qDqbQQOCyXWBeAorUIje9YXhXrWLbOe9axaEAjaVbpbZdPds2q+t8o6L6OGVuJsVqYSb+1bJdaC2FqgEm+T8kqs+d7G80rcJFSJt/WtEmtBbCtQibdLeSXWfG8nUIklsG5lGpzrsdP2jhuBnnmkCa0XzSyuVhbabTKu/k0gO9oxP7o8txeQUz7rUHlGw3+u60rksExpPDNRpTlJ0WRFUxRNVTRN0XRFMxTNVDRL0WxFcxTNVTRP0XxFevpVM11U1K6oIzs4tKChx8Ts8NXXScw/mfmnMP9U5p/G/NOZfwbzz2T+Wcw/m/nnMP9c5p/H/POZv8D8MfMXmb+d+TssHUxOsA7V23YmOkirf/Xgb5JDXLOaZeYyeFnUyfOqye7k1zvFXVrxVIdlMduLsuiPpzmTX1883VlaPfEMh2Uxx4uyKMQzXcmvvxDPcpVWXyGe7bAs5vpQFj2FeI4r+am+Z66jtPpVWvMclsU8D8qiT/E835H8evQKuqO0FMtx7LAs5qe/LPo1z0U38uvTabW7SatHp9XhsCwKDSqLQn2/2KG9Fzu0V2Lsb+sti9iTsnDYr8UO9XI832FZFIXKwvWGIYftN3ZY/2Ip+WWZ/NIwvqW0Oh3OM+k0XM8t6Xm7vMD8WlfWbVm75luv508U4HtRc7r51vWxS4DvHRqkG+vF2e2wPTos63iHlNcb3V46BerN0pTzPVGovSzzpL30OGwvDss6dik/WuciO0LrCL2u1ZMdWt/qNX+6rl96T9kkgfq1k3C7qhef5rlXgO+dPRkv9Tq0MRc4bKMO603sS1mMcFgWC7MybThN7YLrywVGTy4EfblISF/q/beTBfTGbinXl5rnRQJ87+5JG13ksF3t4FBfOqw3sS9l0eywLBZnZdpwmtoF15c7GD25GPTlEiF9qc8qTBHQG3ulXF9qnpcI8L23J210icN2tdShvnRYb2JfymKkw7JYlpVpw2lqF1xfLjV6chnoy+VC+lKf65oqoDf2S7m+1DwvF+B7f0/a6HKH7WpHh/rSYb2JfSmLUS7H0FmZNpymdsH15Y5GT+4E+nJnIX2pz8BOE9AbB6VcX2qedxbg+2BP2ujODtvVLg71pcN6E/tSFqMdlsWuWZk2nKZ2wfXlLkZP7gr6cjchfanvC5guoDcOS7m+1DzvJsD34Z600d0ctqvdHepLh/Um9qUsNnJYFntkZdpwmtoF15e7Gz25B+jLPYX0pb5bZYaA3jgq5fpS87ynAN9He9JG93Q5z+VQXzqsN7EvZdHisCz2zsq04TS1C64v9zJ6cm/Ql/sI6Ut9D9VMAb1xXMr1peZ5HwG+V3jSRvdx2K72dagvHdab2JeyGONyzjEr04bT1C64vtzX6Mn9QF/uL6Qv9Z19swT0xqqU60vN8/4CfPd70kb3d9iuDnCoLx3Wm9iXsmh1WBYHZmXacJraBdeXBxg9eSDoy4OE9KW+33S2gN44IeX6UvN8kADfazxpowc5bFcHO9SXDutN7EtZtDksi0OyMm04Te2C68uDjZ48BPTloUL6Ut8FPUdAb6xNub7UPB8qwPfJnrTRQx22q8Mc6kuH9Sb2pSzGOiyLw7MybThN7YLry8OMnjwc9OURQvpS35s/V0BvnJZyfal5PkKA79M9aaNHOGxXRzrUlw7rTexLWYxzWBZHZWXacJraBdeXRxo9eRToy6OF9KX+xsg8Ab1xVsr1peb5aAG+z/akjR7tsF0d41BfOqw3sS9lsbHDsjg2K9OG09QuuL48xujJY0FfHiekL/X3mOYL6I3zUq4vNc/HCfB9vidt9DiH7WqFQ33psN7EvpTFJg7LYmVWpg2nqV1wfbnC6MmVoC/7hPSl/nZdQUBvvDHl+lLz3CfA94WetNE+h+1qlUN96bDexL6UxXiHZdGflWnDaWoXXF+uMnqyH/TlaiF9qb/zGQvojYtTri81z6sF+L7Ekza62mG7Ot6hvnRYb2JfymJTh2VxQlamDaepXXB9ebzRkyeAvlwjpC/1N5GLAnrjspTrS83zGgG+3+JJG13jsF2d6FBfOqw3sS9lsZnDsjgpK9OG09QuuL480ejJk0BfrhXSl/r78e0CeuPylOtLzfNaAb6v8KSNrnXYrk52qC8d1pvYl7LY3GFZnJKVacNpahdcX55s9OQpoC9PFdKXW2SHf1/VlXzennJ9qXk+VYDvqz1po6c6bFenOdSXDutN7EtZbOGwLE7PyrThNLULri9PM3rydNCXZ2SjYb+s4zIbF7mTzRnu2k+Bse28v5jhLq1C3qRzpgJ9lqKzFZ2j6FxF5yk6X9EFit6g6I2KLlR0kaI3KbpY0SWKLlX0ZkWXKXqLorcqepuiyxVdoehKRVcperuiqxVdo+haRe9QdJ2i67ODQqJvjWsso6Ih/1nMfzbzn8P85zL/ecx/PvNfwPxvYP43Mv+FzH8R87+J+S9m/kuY/1LmfzPzX8b8b2H+tzL/25j/cua/gvmvZP6rmP/tzH8181/D/Ncy/zuY/zrmv9748edav2ObqVdXnOlAv9P3pM9y2Fe8o0F9bT0867I424n8Bsv1nPrTKhr5xec6LIvr0lwWHetwxufVx3MBeI7Pryet4jD5xRc4LIvr01kWBYYzfkONPHetXo/n+I21pdVjkV98ocOyeGfayqLHijO+qHqeuxN4jt9UbVrdifKLL3ZYFu9KT1kUS+CML6mG5+6SPMeXVp5WXxn5xW92WBY3pKEsusvijC+rjOdCBTzHb6kkrUJF8ovf6rAs3r1hy6KzQpzx28rx3FExz/HlJdPqWF2F/OIrHJbFezZUWXRXhTO+Mpnnnip5jq9KSKt3ddXyi9/usCxubHxZFGrAGV9t47lQE8/xNeunFdcov/hah2VxUyPLYlXNOON3DOe5vQ6e4+sgreLquuQXX++wLG72ZI7b4fxA7HB8G1/vcI77Fk/KwuE4KHZox8c3OCyL93pSFg7tvdihvRLf6LAsbvWkLBz2a7FDvRzf4rAs3idUFk2Oy8Jh+40d1r/Ypfyy0fCf67W6me7SWrdW904F+l2KblD0bkXvUXSjopsU3azoFkXvVXSrovcper+i2xTdrugORXcq+oCiuxR9UNGHFN2t6B5FH1b0EUUfVXSvovsUfUzR/Yo+rugT2WjYWp3Ggms572L+G5j/3cz/Hua/kflvYv6bmf8W5n8v89/K/O9j/vcz/23Mfzvz38H8dzL/B5j/Lub/IPN/iPnvZv57mP/DzP8R5v8o89/L/Pcx/8eY/37m/zjzfyIrv1aHbabu+WYHdj6t1b3L4ZjhPk/W6m5wIr/Bcn13/WmtW6t7j8Oy+Jgna3U31sfzsLW6m+pJi63V3eywLO73ZK3ulhp5tq3Vvbe2tKxrdbc6LIuPe7JW977qeU5cq3t/tWmVWKu7zWFZfMKTtbrbq+G5zFrdHZWnVXat7k6HZfFJT9bqPlAZzxWt1d1VSVoVrtV90GFZfMqTtboPleO5irW6u7Pu1urucVgWD3iyVvfhrLu1uo9k3a3VfdRhWTzoyVrdvVl3a3X3Zd2t1X3MYVl82pO1uvuz7tbqPp51t1b3CYdl8RlP5sEdzg/EDse38f0O58Ef8qQsHI6DYod2fPxJh2XxsCdl4dDeix3aK/GDDsvis56UhcN+LXaol+OHHJbF5zxZq3PYfmOH9S/+nEdrdbPcpbVure6TCvSnFD2g6EFFn1b0GUUPKXpY0WcVfU7R5xU9ougLir6o6FFFX1L0ZUVfUfRVRV9T9HVF31D0TUWPKfqWoscVfVvRE4q+o+i7ip5U9L1sNGytTmPBtZxPMf8DzP8g83+a+T/D/A8x/8PM/1nm/xzzf575H2H+LzD/F5n/Ueb/EvN/mfm/wvxfZf6vMf/Xmf8bzP9N5n+M+b/F/I8z/7eZ/wnm/w7zf5f5n2T+72Xl1+qwzdQ9r+bAzqe1uk85HDM87sla3QNO5DdYrg/Wn9a6tbpPOyyLb3uyVveZ+ngetlb3UD1psbW6hx2WxROerNV9tkaebWt1n6stLeta3ecdlsV3PFmre6R6nhPX6r5QbVol1uq+6LAsvuvJWt2j1fBcZq3uS5WnVXat7ssOy+JJT9bqvlIZzxWt1X21krQqXKv7msOy+J4na3VfL8dzFWt138i6W6v7psOy+L4na3WPZd2t1X0r626t7nGHZfEDT9bqvp11t1b3RNbdWt13HJbFDz1Zq/tu1t1a3ZNZd2t133NYFj/yZB7c4fxA7HB8Gz/hcB78x56UhcNxUOzQjo+fdFgWP/GkLBzae7FDeyX+gcOyeMqTsnDYr8UO9XL8Y4dl8VNP1uoctt/YYf2LpeTn+n7f72dd4ezqlcT5A2c424uSOH/oDGfPKkmcP3KGs79PY9M6lgB/36yV/cC4PzTuj4xLd1TS3ZV0pyXddUl3YNLdmHRnJt2lSXds0t2bdCcn3dVJd3jS3Z505yfdBUp3hNLdoRcbl+4apTtI6W5SurOU7jKlO07p7lO6E5XuSqU7VOluVbpzle5ipXN/dB6QzgnS+UE6V0jnDekcIp1PpHOLdJ6RzjnS+Uc6F0nnJekcJZ2vpHOXdB7zNuPS+U0610nnPekcKJ0PpXOjdJ6UzpnS+VM6l0rnVekcK51vpbVUWmOltVdak6W1WlrDpbVdWvOltWBaI6a1Y1pTprVmWoOmtWlas6a1bFrjprVvWhOntXJaQ6e1dVpzp7V4WqOntXta06e1ftoDQHsDaM/Aj5X7E0VPKfqpop8p+rmiXyj6paJfKfq1ot8o+j9FTyv6raLfKfq9oj8o+qOiPyl6RtGfFT2r6C+K/qrob4r+rugfiv6p6DlFzyv6l6J/Z6NhP9d65T9ZZ/1ekd+Lrf36Pmydh3a3UPSCeh5h/mOsWfkr1PeLX840pl8v1PeLX3BXDoVmwPmiEfJLxn3ZuK8Y97/ZQV5mmPCvKv//9H/K8MsoyipqUpRTNEJRs6KRikYpGq1oI0UtisYoalXUpmisonGKNla0iaLxijZVtJmizRVtoWhLRVsp2lrRNoq2VbSdou0VTVCUVzRR0SRFkxVNUTS1aUju635LHRUAbRzRAsmzPLgRXG+jc1jY8UtZd7imNbmrhLqRbxRZCixy33hc4ka80yUrnJQgELSrdGc0uatkUnzPaHJeRgOVOBs1pqdy2QNI4nwpK9PYZmJjc23mzGhy31MQ4BHG3whN51L4WKlnmcYzW/MkIfyZAlppZpPbFiPFd1aQ73oxzhGWYaG+X6wr5pwm92Uz17HJoNuPTvNik6ZrOcwWksM8ATnME5SDVoAScngm5d+Lk2oHf96wfJfdDydV75/1ZL3EYb2MHZZ17FJ+2oDS89E2KzuqUp7l6hOmKdFXuZIJGpPzS1nGhfp+8RyBDgABV4k3LpeHxjtfQCH8PSWL2dUYbPXyXGhKp3JxWRZUJwtglNRaNuXk7bJsYkgrbm9X7WJVd7x61er2zu7e4sq4q72ra3XH6u6uno5Vqzs7Vqzq7o87VrQXe/u7C6vjnv7+7s72vu6u1b2r+rpWo7KOV7W3d6zqXdkXdxa7VqxUy5btKwqrO7rbi4UVq9q7V61q7+nqWtHevqqrZ3VPb0+xuGJ1e0+hs7u7t9BVbO8tSpRNbMqmkSNpl9Mt2HEVjQXQ7ovSlsJXFFDSHQKdVYfgaEXLoV1ADp0CcugUlMMLQqO2f6Z81CbVDp5L+ahNqt4/78mozWG9jB2Wdfx8GLXxX1wUGrV1+TZq6xIetXUJKIQXXoejtu6mdCqXFwRGBt2ejdp6HI7annc4apMomx4YtSV1BGmeYpPEKdWp9PrWqfQKdyq9Ap3KSym/80aiU/mzkMVaL66XG2Tx14tzgcNO2WH9i18WUPwLKuiU65XnwiZ3nd+w6c8UdcovCZTNwtfQVOoi00h3sG1KKtT3i5M257jcaVZvWg43OIlsNyUZulamUjKsN63FKS8P3WAWCxhESwQMwyWC0807CMlhqYAclgpPu0vI4dWUT7tLtYP/pXzaXareRyP9mHZ3WC9jh2Udu5Tfa2XafZHQDMkyyRmSxQIdwDLBGRKNd5mAQsgJKQTX0+6LHRp/y5vSqVxclgXVyeUNmHZ3WTY7Opx2R2Vd7whfomx23AAjfKljRzsZC2BnX5S2FL6dBJT0LgKd1S6CoxUth50F5LCrgBx2bZI94iJhxTePlG0HLmZXJNrByA3Ld9lRm1S9H+XJqM1hvYwdlnU8Koza+C/eSWjUtptvo7bdhEdtuwkohDGvw1Hb7k3pVC5jBEYGu3s2atvD4ahtlMNRm0TZ7LEBNkstapJp7750Knv61qnsKdyp7CnQqbQ1qFNxuXabonWgYZ1KvbjGNsjirxfnXg47ZYf1Lx4roPj3asBmqb0dbpYaNv2Zok65TaBs9raUjevRLW6OqrecX3GY1j4O+69G3vW3j5CxsG+TZ3f9aUHs2+Q+3f0cdpRSfO/X5LyMGnrXHzbkQp0/SZwud3Zi49q/SfCuv/0cWhfUUxDg18K22gNM4zmwSeCuPy38/QW00v7Ci3iu+M4K8l0vxoNSvhCqK+ZBAkPUgwWG6gcLLgAeKCSHQwTkcIjw9lUJOWyS8oVQqXYwPuULoVL1flNPFkId1svYYVnHm4aFUP4b6KtcyQSNyUMl56wPEugADhWcs9Z4DxVQCFt6shB6kEPj77CmdCqXLQXm9Q5rwEKoy7I53OFC6KYO51wlyubwDbB91eV0C3ZcRxgL4EhflLYUviMElPRRAp3VUYKjFS2HIwXkcLSAHI4WlMMrQqO2rVM+apNqB9ukfNQmVe+39WTU5rBexg7LOt42jNr4Lz5CaNR2jG+jtmOER23HCCiE/Otw1HZsUzqVS15gZHCsZ6O24xyO2rZ1OGqTKJvjNsD21QOaZNq7L53KCt86lRXCncoKgU5lkifbV10qrvFCFmu9uCZ7sn11pcNO2WH9iycLKP6VDdi+2udw++qmI9PZKU8SKJu+19BU6irTSPttm5IK9f3ipM05Lnea1ZuWww1OIttNSYaulamUDOtNa3XKy0M3mNUCBtHxAobh8YLTzf1CcjhBQA4nCE+7S8hhWsqn3aXawfSUT7tL1fsZnky7O6yXscOyjmeEaXf+G+irXMkEjdw1kjMkqwU6gDWCMyQa7xoBhTDHk2n31Q6NvxOb0qlc5giMIk9swLS7y7I5yeG0+wyHI3yJsjlpA4zwpY4drTUWwMm+KG0pfGsFlPQpAp3VKYKjFS2HkwXkcKqAHE5tkj3iImHFz0v5qE2qHcxP+ahNqt4XPBm1OayXscOyjgth1MZ/8VqhUdtpvo3aThMetZ0moBA6XoejttOb0qlcOgRGBqd7Nmo7w+GoreBw1CZRNmdsgM1Sq5pk2rsvncqZvnUqZwp3KmcKdCpdnmyWcqm4pgtZrHV/BdyTzVJnOeyUHda/uFtA8Z/VgM1SZzvcLDVjZDo75S6BsjkbOuVG3VX336xMZ3dOk2d31WlBnNPkPt1zHSp6Kb7PbXJeRg29cPEVoUp8nm+VWAviPIFKfH7KK7Hm+3yBSmzD6mI34eom99ewubQoL0j5GpVWWOcLjB7e0JTuuqO/Or1YoO64vHn8jSmXoa7bb2hyv27gsM3Eb3BYHhemvDx0fblQoC1fJLw7ul58el31IgG+F4xMt+5+SYjvhUKzDa51rcPyiRc6XhNslMHu8mOdiPdNvhnsWhBvEjDYL065wa75vtjzUefLQpX4Et8qsRbEJQKV+NKUV2LN96UNGnUW6vsNKIRLBXrdN6d8pKhHiW8W4Psyx+tto6OheXitHF9V7svG/a9xXzGu/r3F1DvXfOmR9WUC8nqrQ2ucLDL6ua4zLzpU7DNMOm9T/F+u6ApFVyq6StHbFV2t6BpF1yp6h6LrFF2v6J2K3qXoBkXvVvQeRTcquknRzYpuUfReRbcqep+i9yu6TdHtiu5QdKeiDyi6S9EHFX1I0d2K7lH0YUUfUfRRRfcqus/MKNA6xNtM+ZP/cua/gvmvZP6rmP/tzH8181/D/Ncy/zuY/zrmv57538n872L+G5j/3cz/Hua/kflvYv6bmf8W5n8v89/K/O9j/vcz/23Mfzvz38H8dzL/B5j/Lub/IPN/iPnvZv57mP/DzP8R5v8o89/L/Pc1rW/wVLtRqJo2Xa8ue1tT/Wn1rx78Xd7kDtfilO99MDyvusKd/HqvdJdWfJXDsljiRVn0x293Jr+++GpnafXE1zgsi6VelEUhvtaV/PoL8TtcpdVXiK9zWBbLfCiLnkJ8vSv5qb7nnY7S6ldpvcthWSz3oCz6FM83OJJfj0rr3Y7SUizH73FYFjumvyz6Nc83upFfn07rJjdp9ei0bnZYFjulvyx00vEtTuTXP5DWe52k1TeQ1q0Oy2Ln1JdFzwDP73MivwGY8ftdpNU/mNZtDstil7SXRd8gz7e7kF/PYFp3uEhrkOX4TodlsWvKy2KV4fkDDnheadK6y0Fa3SatDzosi93SXRZFOon5ofp5jimtu+tOq2c1pXWPw7LYPdVl0bOSeP5w/fJbd8L2I3Wn1b0urY86LIs9Ul0Wnet4vrdunuN1ad3X5G7OcrHDszh7puSwbZlf7HDeLHY47xMvc1gWe3lSFg7nB2KH49t4J4dlsbcnZeFwHBQ7tOPjXR2WxT6elIVDey92aK/Eezgsi309KQuH/VrsUC/Hezssi/08uTnHYfuNHda/WEp+WSa/NKwrU1ofc2iH6jRc77HR+5fe2uR+n9H9TW7L2jXfr2aH9te45HtVynf96/p4vwDf/Z7cMfBxh+3RYVnH/SmvN7q9fEyg3pyQcr7fJtRe1njSXj7hsL04LOvYpfxo3y/ZEVpH6P29n2ga2uf7SSNY1/Xrf9mhfZ0uy21tym/11Dx/UoDvkz0ZL33SoY35KYdt1GG9iX0pC90GXZXFA00ybThN7YLry08ZPfkA6MsHhfSl7uCuENAbp6VcX2qeHxTg+3RP2uiDDtvVpx3qS4f1JvalLCKHZfGZJpk2nKZ2wfXlp42e/Azoy4eE9GWmaehcEKZb9119KdeXmueHBPg+25M2+pDDdvWwQ33psN7EvpRFxmFZfLZJpg2nqV1wffmw0ZOfBX35OSF9mW0aOjeJ6dYrn/NSri81z58T4Pt8T9ro5xy2q8871JcO603sS1lkHZbFI00ybThN7YLry88bPfkI6MsvCOnLpqahc+WYbt23kaVcX2qevyDA94WetNEvOGxXX3SoLx3Wm9iXsmhyWBaPNsm04TS1C64vv2j05KOgL78kpC9zTUP3bmC69crn4pTrS83zlwT4vsSTNvolh+3qyw71pcN6E/tSFjmHZfGVJpk2nKZ2wfXll42e/Aroy68K6csRTUP3EmG6dd8blnJ9qXn+qgDfb/GkjX7VYbv6mkN96bDexL6UxQiHZfH1Jpk2nKZ2wfXl14ye/Droy28I6cvmpqF72zDduvfrpFxfap6/IcD3FZ600W84bFffdKgvHdab2JeyaHZYFo81ybThNLULri+/afTkY6AvvyWkL0c2Dd1rienWPT+Ycn2pef6WAN9Xe9JGv+WwXT3uUF86rDexL2Ux0mFZfLtJpg2nqV1wffm40ZPfBn35hJC+HNU0dO8vplu3Pkq5vtQ8PyHA93WetNEnHLar7zjUlw7rTexLWYxyWBbfbZJpw2lqF1xffsfoye+CvnxSSF+Obhq6Fx3TrVc+70q5vtQ8PynA9w2etNEnHbar7znUlw7rTexLWYx2WBbfb5Jpw2lqF1xffs/oye+DvvyBkL7cqGnouxGYbr3yuTHl+lLz/AMBvm/ypI3+wGG7+qFDfemw3sS+lMVGDsviR00ybThN7YLryx8aPfkj0Jc/FtKXLU1D39XBdOuVz3tTri81zz8W4PtWT9rojx22q5841JcO603sS1m0OCyLp5pk2nCa2gXXlz8xevIp0Jc/FdKXY5qGvjuG6dYrn9tSri81zz8V4Pt2T9roTx22q5851JcO603sS1mMcVgWP2+SacNpahdcX/7M6Mmfg778hZC+bG0a+i4jpluvfD6Qcn2pef6FAN93edJGf+GwXf3Sob50WG9iX8qi1WFZ/KpJpg2nqV1wfflLoyd/Bfry10L6sq1p6Lu1mG698rk75fpS8/xrAb7v8aSN/tphu/qNQ33psN7EvpRFm8Oy+L8mmTacpnbB9eVvjJ78P9CXTwvpy7FNQ9/1xnTrlc9HU64vNc9PC/B9rydt9GmH7eq3DvWlw3oT+1IWYx2Wxe+aZNpwmtoF15e/NXryd6Avfy+kL8epdG8S0Bv3p1xfap5/L8D3xz1po7932K7+4FBfOqw3sS9lMc5hWfyxSaYNp6ldcH35B6Mn/wj68k9C+nJjle7NAnrjUynXl5rnPwnw/YAnbfRPDtvVMw71pcN6E/tSFhs7LIs/N8m04TS1C64vnzF68s+gL58V0pebqHRvEdAbn0m5vtQ8PyvA90OetNFnHbarvzjUlw7rTexLWWzisCz+2iTThtPULri+/IvRk38Fffk3IX05XqX7XgG98bmU60vN898E+P68J230bw7b1d8d6kuH9Sb2pSzGOyyLfzTJtOE0tQuuL/9u9OQ/QF/+U0hfbqrSvVVAb3wx5fpS8/xPAb4f9aSN/tNhu3rOob50WG9iX8piU4dl8XyTTBtOU7vg+vI5oyefB335LyF9uZlK930CeuMrKdeXmud/CfD9VU/a6L8ctqt/O9SXDutN7EtZbOawLP7TJNOG09QuuL78t9GT/wF9+YKQvtxcpft+Ab3xjZTrS83zCwJ8f9OTNvqCw3b1okN96bDexL6UxeYOy+KlJpk2nKZ2wfXli0ZPvgT68mUhfbmFSvc2Ab3xeMr1peb5ZQG+v+1JG33ZYbt6xaG+dFhvYl/KYguHZfHfJpk2nKZ2wfXlK0ZP/hf05atC+nJLle7tAnrjuynXl5rnVwX4ftKTNvqqw3b1P4f60mG9iX0piy0dloUGJ9GG09QuuL78H+nJ3JC+zJhCcq0vt1J53SGgN36Qcn05wHPOfbo/9KSNZhy2q2zOHS6H9Sb2pSy2cqgvm3IybThN7YLry6zRk02gL3NC+nJrVVZ3CujLn6RcX2qecwL68ilP2mjOYbsa4VBfOqw3sS9lsbVDfdmck2nDaWoXXF+OMHqyGfTlSCF9uY0qqw8I6Mufp1xfap5HCujLX/jyzRiH7WqUQ33psN7EvpTFNg715eicTBtOU7vg+nKU0ZOjQV9uJKQvt1VldZeAvvx1yvWl5nkjAX35G1/u9HbYrloc6kuH9Sb2pSy2dagvx+Rk2nCa2gXXly1GT44BfdkqpC+3U2X1QQF9+duU60vNc6uAvvydL3cuOmxXbQ71pcN6E/tSFts51JdjczJtOE3tguvLNqMnx4K+HCekL7dXZfUhAX35x5TrS83zOAF9+Sdf7sRx2K42dqgvHdab2Jey2N6hvtwkJ9OG09QuuL7c2OjJTUBfjhfSlxNUWd0toC+fTbm+1DyPF9CXf/HlzLLDdrWpQ33psN7EvpTFBIf6crOcTBtOU7vg+nJToyc3A325uZC+zKuyukdAX/495fpS87y5gL78hy9nShy2qy0c6kuH9Sb2pSzyDvXlljmZNpymdsH15RZGT24J+nIrIX05UZXVhwX05fMp15ea560E9OW/fNnz57Bdbe1QXzqsN7EvZTHRob7cJifThtPULri+3NroyW1AX24rpC8nqbL6iIC+fCHl+lLzvK2AvnzRlzVZh+1qO4f60mG9iX0pi0kO9eX2OZk2nKZ2wfXldkZPbg/6coKQvpysyuqjAvrylZTrS83zBAF9+V9f5swctqu8Q33psN7EvpTFZIf6cmJOpg2nqV1wfZk3enIi6MtJQvpyiiqrewX0ZTQq3fpS8zxJQF9mRnli0zhsV5Md6kuH9Sb2pSymONSXU3IybThN7YLry8lGT04BfTlVSF9OVWV1n4C+zKVcX2qepwroyxGetNGpDtvVNIf60mG9ib0pC4f6cnpOpg2nqV1wfTnN6MnpoC9n5KJhv6zjMtskciebGTlZXVmo7xe/rIR3kUAfMTPntk7oK6l0mrdFsmX/QsadDGY51J0kA51mXrkjDGWj5J/LvDMsbdf1cHrktr7Qb3ZufezuOiGVRrOhSFhAmUimw3Mlk/buld3x6p5VkjKYnZORgWucszzBmYvSXafolwH+R5vnOQr8XEXzFM1XVFCkGSoqalfUId3w0UqRLKS5uVQXUkwPKItOY6F1SRYCdYk6s1+yPJoEC6FGs6BozIK406EZ3yVUOVybVS557raktbLQt6ozXtm1qjvuX9HZ09fX2x7HxRVdK7pWFntW96/sjHs6e1SafSuKPSq74oq+uL+woqtfN+SNIksljdw35O6ce42ofz2SjUxKED059+n2upxPFOK7N+e8jETm0LoMVleKgNJ1WUYLBMaYOs2J0eDYqlE9fMHDHn6hqceLGtHDLzQ9PPkXmUEw/lz3+AWHPf5Ch5V+kSc9vkued/C0x99BqMdf7FuPrwWxWKDHX5LyHl/zvcSTHn+Rweq6x3dZRksFevylG6DHj9Pd49OviLJYZurx8kb0+Dqz/7I8XPfwsYOK2b968LfMYSVf7kkP75LnHSGtuKe9WOxu1+F6VhXijlV9xZ5icdXKjkJfYUVfsb+3I+5d3VHsaO9b1bdSpbkiXl1YvaKvd3XPIK5G9vA7CvXwO/nWw2tB7CTQw++c8h5e872zJz38coPVdbq7CPTKuxhLpJG9ctHDXnlXU/d2a0SvvKvplclvy9R1L1102Evv6lCZ7OZJL+2S59097aV3F+ql9/Ctl9aC2EOgl94z5b205ntPT3rp3QxW1+nuJdBL77UBeul2D2fL9zZ1b59G9NJ7s9nyfRowW97ucLZ8b4fKZB9PemmXPO/r6Wz5vkK99H6+9dJaEPsJ9NL7p7yX1nzv70kvvY/B6nq23GUZHSDQ4x9gZsvx51oZZhyW0xxPtmJ2OSh3PczqL3R3lCqbNO1p96Vznu2wTXZ4Uh8btQhR9zkmhzzv5gnPDo8CxPNfhzzP80TvzHKodw7Mue2ftS1woGVg6drOOsgBbjqaws8W6rT1mcJ/ZQZdPdA5ODd0zGB5doinV8FdxOLlzPtZ5v1s9n9wgxvc4AY3uMENbnCDG9zgBje4wQ1ucP1yZys6BOaJaDOF9uv/DzbzP4cYV98ndSiEXxoN/fT/M6OhdIN8Xz/uHEWHWerFYWH+8HVfLw7PDe6qGxk15I6vdl0Hm1jaGbd5xA7TKkhhnOkBxtkOMWagvI+Q3ihFP9cLZYc7XCg7wuHioG7Ao6LG3A/n8gI9C9y6017Vsbqvr7erX1IGh3uyueJAT3A63Fwhej/cDpDmkWYD4VHGPdq4xxj3WOMeZ9wVxl1p3D7jrjJuv3FXG/d4455g3DVGaS41+Z+o/CcpWqvoZEWnKDpV0WmKTld0hqIzFZ2l6GxF5yg6V9F5is5XdIGiNyh6o6ILFV2k6E2KLlZ0iaJLFb1Z0WWK3qLorYrepuhyRVcoulLRVYreruhqRdcoulbROxRdp+h6Re9U9C5FNyh6t6L3KLpR0U2KblZ0i6L3KrpV0fsUvV/RbYpuV3SHojsVfUDRXYo+qOhDiu5WdA+TxYeV/yOKPqroXkX3KfqYovsVfVzRJxR9UtGnFD2g6EFFn1b0GUUPKXpY0WcVfU7R5xU9ougLir6o6FFFX1L0ZUVfUfRVRV9T9HVF31D0TUWPKfqWoscVfVvRE4q+o+i7ip5U9D1F31f0A0U/VPQjRT9W9BNFTyn6qaKfKfq5ol8o+qWiXyn6taLfKPo/RU8r+q2i3yn6vaI/KPqjoj8xWTyj/H9W9Kyivyj6q6K/Kfq7on8o+qei5xQ9r+hfiv6t6D+KXlD0oqKXFL2s6BVF/1X0qqL/KdJWYkZRVlGTopyiEYqaFY1UNErRaEUbKWpRNEZRq6I2RWMVjVO0saJNFI1XtKmizRRtrmgLRVsq2krR1oq2UbStou0Uba9ogqK8oomKJimarGiKoqmKpimarmiGopkjBmWRN7KYpfyzFc1RNFfRPEXzFekOUx8MKypqV9ShqFNRl6JuRT2KehUtULRQ0SJFOyharGiJoqWKlilarmhHRTsp2lnRLop2VbSbot0NFlJIeyj/nor2UrS3on0U7atoP0X7KzpA0YGKDlJ0sKJDFB2q6DBFhys6QtGRio5SdLSiYxQdq+g4RSsUrVTUp2iVIr2dfrWi4xWdoGiNohMVnaRoraKTFZ2i6FRFpyk6XdEZis5UdJaisxWdo+hcRecpOt/wsqXh5QLlf4OiNyq6UNFFit6k6GJFlyi6VNGbFV2m6C2K3qrobYouV3SFoisVXaXo7YquVnSNomsVvUPRdSavcSav65X/nYrepegGRe9W9B5FNyq6SdHNim5R9F5Ftyp6n6L3K7pN0e0jBtO4w6RJ9tGdyv8BRXcp+qCiDym624S9x7gfHjG8XX1E+T+q6F5F9yn6mKL7FX1c0ScUfVLRpxQ9oOhBRZ9W9BlFDyl6WNFnFX1O0ecVPaLoC4q+qOhRRV9S9GVFX1H0VUVfU/R1Rd9Q9E1Fjyn6lqLHFX1b0ROKvqPou4qeVPQ9Rd9X9ANFP1T0I0U/VvQTRU8p+qminyn6uaJfKPqlol8p+rWi3yj6P0VPK/qtot8p+r2iPyj6o6I/KXqGlcmflf9ZRX9R9FdFf1P0d0X/UPRPRc8pel7RvxT9W9F/FL2g6EVFL5m0xpi0Xlb+VxT9V9Griv43YrCgMoqyipoU5RSNUNRsCnCkcUcZd7RxNzJui3HHGLfVuG3GHWvcccbd2LibGHe8cTc17mbG3dy4Wxh3S+NuZdytjbuNcbc17nbG3d64E4ybN+5E404y7mTjTjHuVONOa27Asa6jTYdCfm3A5MG/kv3fx/5fzfzHs/AnMP8aFv4k5j+Z+U9l/tOZ/0zmP5v5z2X+85n/Dcx/IfO/ifkvYf43M/9bmP9tzH8F81/F/Fcz/7XMfx3zv5P5b2D+9zD/Tcx/C/PfyvzvZ/7bmf9O5r+L+T/E/Pcw/0eY/17m/xjzf5z5P8n8DzD/p5n/Ieb/LPN/nvm/wPyPMv+Xmf+rzP915v8m83+L+b/N/N9h/ieZ//vM/0Pm/zHzP8X8P2P+XzD/r5j/N8z/NPP/jvn/wPx/Yn5tsKF/LvPPZ/6Y+duZv5P5u5m/l/kXMv8OzL+E+Zcx/47MvzPz78r8uzP/nsy/D/Pvz/wHMf+hzH8E8x/N/Mcxfx/zr2b+Ncy/lvlPZf4zmP9s5j+P+S8cMbx/uIj9/ybmfzMLfxn7/y3MfwULfyX7/yrmv5aFfwf7/zrmv4v572b+e5j/w8z/Uea/j/nvZ/5PMP+nmP9B5v8M8z/M/J9j/keY/4vM/yXm/wrzf435v8H8jzH/48z/BPN/l/m/x/w/YP4fMf9PmP+nzP9z5v8l8/+a+f+P+X/L/L9n/j8y/zPM/yzz/535n2f+F5j/Feb/H/Nroxr9I5h/FPO3Mf845t+E+Tdlfm0kLwV/nv0/kfknMf9k48ef61M/Lk+t9OVkJjPTzLPWaY3guVDfL/7wCHfym97sfuw1vYK6XqjvN2wBp14ZHJnzY4HhqFz9PMcrC+3tXb3tkmXjcoFxlSdls8ITfZlzyPNKT3h2uNgbH+sJzxmHPB/ToDZY99cjHfRltPCuseldZo8bkLoO6d1GOg/t6vnFVw0Pr8L/x+WG707KmfcHmveHG7ffuKuNe7xxTzDuGuOeaNyTjLvWuCcb9xTjnmrc04x7unHPMO6Zxj3LuGcb9xzjnmvc84x7vnEvMO4bjPtG415o3IuM+ybjXmzcS4x7qXHfbNzLjPsW477VuG8z7uXGvcK4Vxr3KuO+3bhXG/ca415r3HcY9zrjXm/cdxr3Xca9wbjvNu57jHujcW8y7s3GvcW47zXurcZ9n3Hfb9zbjHu7ce8w7p3G/YBx7zLuB437IePebdx7jPth437EuB817r3Gvc+4HzPu/cb9uHE/YdxPGvdTxn3AuA8a99PG/YxxHzLuw8b9rHE/Z9zPG/cR437BuF807qPG/ZJxv2zcrxj3q8b9mnG/btxvGPebxn3MuN8y7uPG/bZxnzDud4z7XeM+adzvGff7xv2BcX9o3B8Z98fG/YlxnzLuT437M+P+3Li/MO4vjfsr4/7auL8x7v8Z92nj/ta4vzPu7437B+P+0bh/Mu4zxv2zcZ817l+M+1fj/s24fzfuP4z7T+M+Z9znjfsv4/7buP8x7gvGfdG4Lxn3ZeO+Ytz/GvdV4/7PuHqBXbsZ42aN22TcnHFHGLfZuCONO8q4o427kXFbjDvGuK3GbTPuWOOOM+7Gxt3EuOONu6lxNzPu5sbdwrhbGncr425t3G2Mu61xtzPu9sadYNy8cScad5JxJxt3inGnGneacacbd4ZxZxp3lnFnG3eOcecad55x5xu3YNzYuEXjthu3w7idxu0ybrdxe4zba9wFxl1o3EXG3cG4i427xLhLjbvMuMuNu6NxdzLuzsbdxbi7Gnc34+5u3D2Mu6dx9zLu3sbdx7j7Gnc/4+5v3AOMe6BxDzLuwcY9xLiHGvcw4x5u3COMe6RxjzLu0cY9xrjHGvc4464w7krj9hl3lXH7jbvauMcb9wTjrjHuicY9ybhrjXuycU8x7qnGPc24pxv3DOOeadyzjHu2cc8x7rnGPc+45xv3AuO+wbhvNO6Fxr3IuG8y7sXGvcS4lxr3zca9zLhvMe5bjfs2415u3CuMe6VxrzLu2417tXGvMe61xn2Hca8z7vXGfadx32XcG4z7buO+x7g3Gvcm495s3FuM+17j3mrc9xn3/ca9zbi3G/cO495p3A8Y9y7jftC4HzLu3VRfqf83/o8Y96PGvde49xn3Y8a937gfN+4njPtJ437KuA8Y90Hjftq4nzHuQ8Z92LifNe7njPt54z5i3C8Y94vGfdS4XzLul437FeN+1bhfM+7XjfsN437TuI8Z91vGfdy43zbuE8b9jnG/a9wnjfs9437fuD8w7g+N+yPj/ti4PzHuU8b9qXF/ZtyfG/cXxv2lcX9l3F8b9zfG/T/jPm3c3xr3d8b9vXH/YNw/GvdPxn3GuH827rPG/Ytx/2rcvxn378b9h3H/adznjPu8cf9l3H8b9z/GfcG4Lxr3JeO+bNxXjPtf475q3P8ZNzLjo4xxs8ZtMm7OuCOM22zckcYdZdzRxt3IuC3GHWPcVuO2GXescccZd2PjbmLc8cbd1LibGXdz425h3C2Nu5VxtzbuNsbd1rjbGXd7404wbt64E407ybiTjTvFuFONO41wKprJdr67nqPSY05HaYnOXbjkeU70+puvmesJz1mHPM/zhOcmhzzP94TnnEOeC57wPMIhz3GDeC7U94uLDuX3n4wf6z7tkR84OzzB2ekJzi5PcHZ7grPHE5y9nuBc4AnOhZ7gXOQJzh08wbnYE5xLPMG51BOcyzzBudwTnDt6gnMnT3Du7AnOXTzBuasnOHfzBOfunuDcwxOce3qCcy9PcO7tCc59PMG5ryc49/ME5/6e4DzAE5wHeoLzIE9wHuwJzkM8wXmoJzgP8wTn4Z7gPMITnEd6gvMoT3Ae7QnOYzzBeawnOI/zBOcKT3Cu9ARnnyc4V3mCs98TnKs9wXm8JzhP8ATnGk9wnugJzpM8wbnWE5wne4LzFE9wnuoJztM8wXm6JzjP8ATnmZ7gPMsTnGd7gvMcT3Ce6wnO8zzBeb4nOC/wBOcbPMH5Rk9wXugJzos8wfkmT3Be7AnOSzzBeaknON/sCc7LPMH5Fk9wvtUTnG/zBOflnuC8whOcV3qC8ypPcL7dE5xXe4LzGk9wXusJznd4gvM6T3Be7wnOd3qC812e4LzBE5zv9gTnezzBeaMnOG/yBOfNnuC8xROc7/UE562e4HyfJzjf7wnO2zzBebsnOO/wBOednuD8gCc47/IE5wc9wfkhT3De7QnOezzB+WFPcH7EE5wf9QTnvZ7gvM8TnB/zBOf9nuD8uCc4P+EJzk96gvNTnuB8wBOcD3qC89Oe4PyMJzgf8gTnw57g/KwnOD/nCc7Pe4LzEU9wfsETnF/0BOejnuD8kic4v+wJzq94gvOrnuD8mic4v+4Jzm94gvObnuB8zBOc3/IE5+Oe4Py2Jzif8ATndzzB+V1PcD7pCc7veYLz+57g/IEnOH/oCc4feYLzx57g/IknOJ/yBOdPPcH5M09w/twTnL/wBOcvPcH5K09w/toTnL/xBOf/eYLzaU9w/tYTnL/zBOfvPcH5B09w/tETnH/yBOcznuD8syc4n/UE5188wflXT3D+zROcf/cE5z88wflPT3A+5wnO5z3B+S9PcP7bE5z/8QTnC57gfNETnC95gvNlT3C+4gnO/3qC81VPcP7PE5w6QR9wZjzBmfUEZ5MnOHOe4BzhCc5mT3CO9ATnKE9wjvYE50ae4GzxBOcYT3C2eoKzzROcYz3BOc4TnBt7gnMTT3CO9wTnpp7g3MwTnJt7gnMLT3Bu6QnOrTzBubUnOLfxBOe2nuDczhOc23uCc4InOPOe4JzoCc5JnuCc7AnOKZ7gnOoJzmme4JzuCc4ZnuCc6QnOWZ7gnO0Jzjme4JzrCc55nuCc7wnOgic4Y09wFj3B2e4Jzg5PcHZ6grPLE5zdnuDs8QRnryc4F3iCc6EnOBd5gnMHT3Au9gTnEk9wLvUE5zJPcC73BOeOnuDcyROcO3uCcxdPcO4qhDPrGOdugLO90NXR0d9d7I/b4xWFYu/Kns5CR+fKrp64J+7s6VxV7Glv7+/p6OnuXdnbXeiNO9r749Wdve2rTWIzm/0om909qUN7NKgO1VvuOYc87+lJu9nLYbs5MOcHz3s75PnDI/xog/t4oiv29QTnfp7g3N8TnAd4gvNAT3Ae5AnOgz3BeYgnOA/1BOdhnuA83BOcR3iC80hPcB7lCc6jPcF5jCc4j/Vk3HacwzHMoTk/ymaFJ3VopSc4+zzBucoTnP2e4FztCc7jPcF5gic413iC80RPcJ7kCc61nuA82ROcp3iC81RPcJ7mic19uss1RiGbO8d4Vjjb68AZ/zjLeF5Ve1o/ya4nv7jWtJ7KuiuLUaMaVhaDOAu18fxTO8+FWtL6WYL8eldXn9bPHZbF6EaXxSDOnmp5/kUpnrurS+uXJeXXsbqatH7lsCw22jBlMYizo3Kef12e585K0/pNJfIrVJbW/zksi5YNWRaDOAuV8Px0pTx3l0/rt5XLr69cWr9zWBZjNnxZDOLsLs3z76vjuVgqrT9UK7/u5LT+6LAsWtNSFoM4u5N4/lMtPPfY03qmNvn12NL6s8OyaEtXWQzg7Fq9Ps/P1s5zgaf1l3rkVxye1l8dlsXYFJaFwVlAnv9WL88dQ2n9vX75FSmtfzgsi3HpLYsBnP2DQON/Zl2ktVqnFj/nKC2VWvy8w7LYOOVlQTj/lXU3b+FwfBvj+KxeHjdpUFkU6vvFDsdBsUM7Ph7jsCzGe1IWDu292KG9Eo91WBabelIWDvu12KFejjdxWBabeVIWZ7ibQ48d6oLYYV2Opcoi67gsznS4TvCCJ2s4Z3mC82xPcJ7jyZmpaQ55PteTdcDzHLbv6Z6cNTzfk3ZzgSc43+AJzjd6gvNCT3Be5AnON3mC82JPcF7iCc5LPcH5Zk9wXuYJzrd4gvOtnuB8myc4L/cE5xWe4LzSE5xXeYLz7Z7gvNoTnNd4gvNaT3C+wxOc13mC83pPcL7TE5zv8gTnDZ7gfLcnON/jCc4bPcF5kyc4b/YE5y2e4HyvJzhv9QTn+zzB+X5PcN7mCc7bPcF5hyc47/QE5wc8wXmXJzg/6AnOD3mC825PcN7jCc4Pe4LzI57g/KgnOO/1BOd9nuD8mCc47/cE58c9wfkJT3B+0hOcn/IE5wOe4HzQE5yf9gTnZzzB+ZAnOB/2BOdnPcH5OU9wft4TnI94gvMLnuD8oic4H/UE55c8wfllT3B+xROcX/UE59c8wfl1T3B+wxOc3/QE52Oe4PyWJzgf9wTntz3B+YQnOL/jCc7veoLzSU9wfs8TnN/3BOcPhHBmGc56z0E3O+T5h57wPNIhzz/yhOdRDnn+sSc8j3bI80884Xkjhzw/5QnPLQ55/qknPI9xyPPPPOG51SHPP/eE5zaHPP/CE57HOuT5l57wPM4hz7/yhOeNHfL8a0943sQhz7/xhOfxDnn+P0943tQhz097wvNmDnn+rSc8b+6Q5995wvMWDnn+vSc8b+mQ5z94wvNWDnn+oyc8b+2Q5z95wvM2Dnl+xhOet3XI85894Xk7hzw/6wnP2zvk+S+e8DzBIc9/9YTnvEOe/+YJzxMd8vx3T3ie5JDnf3jC82SHPP/TE56nOOT5OU94nuqQ5+cd8qzXxum7CXOA/4yRQZP5f4QivZ6s11f1eqNef9PrUXp9Rq9X6Pl7PZ+t53f1fKee/9PzYXp+SM+X6PkDPZ7W40s93tLjD22Pa/tU22vaftH9ue7f8oq0/tP6QLcPXV+0/PS96NMVzVA0U9EsRbMB8zczQ3zMVTRP0XwtI0WxoqIuR0UdijoVdSnqVtSjqFfRAkULFS1StIOixYqWmHJbpmi5oh0V7aRoZ0W7KNpV0W6Kdle0h6I9Fe2laG9F+yjaV9F+ivZXdICiAxUdpOhgRYcoOlTRYYoOV3SEoiMVHaXoaEXHKDpW0XGKVihaqahP0SpF/YpWKzpe0QmK1ig6UdFJitYqOlnRKYpOVXSaotMVnaHoTEVnKTpb0TmKzlV0nqLzFV2g6A2K3qjoQkUXKXqToosVXaLoUkVvVnSZorcoequitym6XNEViq5UdJWityu6WtE1iq5V9A5F1ym6XtE7Fb1L0Q2K3q3oPYpuVHSTopsV3aLovYpuVfQ+Re9XdJui2xXdoehORR9QdJeiDyr6kKK7Fd2j6MOKPqLoo4ruVXSfoo8pul/RxxV9QtEnFX1K0QOKHlT0aUWfUfSQoocVfVbR5xR9XtEjir6g6IuKHlX0JUVfVvQVRV9V9DVFX1f0DUXfVPSYom8pelzRtxU9oeg7ir6r6ElF31P0fUU/UPRDRT9S9GNFP1H0lKKfKvqZop8r+oWiXyr6laJfK/qNov9T9LSi3yr6naLfK/qDoj8q+pOiZxT9WdGziv6i6K+K/qbo74r+oeifip5T9Lyifyn6t6L/KHpB0YuKXlL0sqJXFP1X0auK/qdIK4OMoqyiJkU5RSMUNSsaqWiUotGKNlLUomiMolZFbYrGKhqnaGNFmygar2hTRZsp2lzRFoq2VLSVoq0VbaNoW0XbKdpe0QRFeUUTFU1SNFnRFEVTFU1TNF3RDEUzFc1SNFvRHEVzFc1TNF+RVnKxoqKidkUdijoVdSnqVtSjqFfRAkULFS1StIOixYqWaF2raJmi5Yp2VLSTop0V7aJoV0W7Kdpd0R6K9lS0l6K9Fe2jaF9F+ynaX9EBig5UdJCigxUdouhQRYcpOlzREYqOVHSUoqMVHaPoWEXHKVqhaKWiPkWrFPUrWq3oeEUnKFqj6ERFJylaq+hkRaco0t+r19+C199Z19+z0d9R0d8V0d/s0N/D0N+H0N9e0N8i0Pf86zv09f30+u53fa+6vrP8YkX6rm19j7W+I1rfv6zvNtb3Bus7efV9t/ouWX1Pq74DVd8vqu/u1Pdi6jsn9X2O+q5EfQ+hvuNP35+n76bT977pO9X0fWX6LjB9z5a+w0rfD6XvXtL3Guk7g25TpO+60ffI6Dta9P0n+m4RfW+HvhND3zeh73LQ9yToOwj0+X59dl6fS9dnvvV5an1WWZ8D1mds9flVfTZUn7vUZxr1eUF9Fk+fc9NnyPT5LH32SZ8r0md29HkYfdZEn+PQZyT0+QO9t1/vm9d70vV+b9336H3Keg+w3l+r967qfaF6z6Xez6j3Cup9eHqPm94/pvdT6f1Fer+N3n+i92Po/Ql6vV6vX+v1XL2+qdf79PqXXg/S6yN6vUDPn+v5ZD2/qucb9fybno/S8zN6vkKP3/V4Vo/v9HhH2//aHtb2obaXtP2wNRk40WAfTb9tjbvirLP6Tz7trPxZp+ZXrFqVP3fNWSfkTz2n/4zVa0/VXcZA/0y/mcbd5+y1a9esXtN/Rn7Vqf1n5k859az8ySvO6jshf86KtWf359ecopM5pf9M3QcNKGD6TTLufmeces6aU47Pn7IuoTWn9K09+8w1p56SX71izdp+3fMNNBH6bWPcvhVr1w5gPfPM/jPOOvbkFecdu3LNWceeueYC3VEOtKYqo6yuPsoJ1Uc5qfooJ1cf5Zzqo5xXfZSLqo9ycfVRLqs+ylurj3Jt9VGuqz7Ku6qP8u7qo7y/+ii3Vx/lQ9VHuaf6KJ+sPsoD1Ud5pPooX6w+yperj/LV6qM8UX2U71Yf5UfVR/lJ9VF+Xn2UX1Yf5Q/VR/lT9VGerT7KX6uP8p/qo7xYfZT/VR8lk606SitEmWbc/c5euXZNX37VirNW5M9cqwwObXmcMp0MD7A32uqKPbau2JObhmJPpdjG1jltMBUykdY3d6Y2VS2p6RClUoOur4Y4W+eqi6OryQQTbq+hqAOTQfq37IwzVpyvhLCq/7z8qWeflT91dX7lqWefsupMjHhArREPrzXicbVG/ENUu3z+XGum/6g14thM7WjzdcSdkqkR8KxqI+5nIkyNaow4p9aI7bVGXFBrxJ1qjbh1DUVJcbevtUSm1BpxeQ1oDzFx9hmKum48C3HPPHvlWWes6DsrOYEDIQEaRO9ux0tRDomqZJQiHlV9XsfWmtfpUfVCPczE3aFynBRlabU4KeLedeDcv3qcB9WKc1UNOFeauPtB3KoqKSVwcOWMUpTDqmWUIh5TfV4ras3rzKh6oa6pvpKuqbWSrqmjkq6pvpKuqbWSrqmjkp5RbyU9o/pKekatlfSM6ivpGbVW0jPqqKTn1yvU86sX6vm1CvX86oV6fq1CPb8OoV5Sfcu/pNaWf0kdLf+S6lv+JbW2/EvqaPlX1VtJr6q+kl5VayW9qvpKelWtlfSqOirp9dVX0utrraTX11FJr6++kl5fayW9vo5Keku9lfSW6ivpLbVW0luqr6S31FpJb6mjkt5Rr1DvqF6od9Qq1DuqF+odtQr1jjqEep+JW/OQlBKoYkhKUaoeklLEKoakFKXqISlFrGVIen/16vT+WtXp/XWo0/urV6f316pO769DnT5cb8t/uPqW/3CtLf/h6lv+w7W2/IfraPmPVl9JH621kj5aRyV9tPpK+mitlfTROirpY/VW0seqr6SP1VpJH6u+kj5WayV9rI5K+mS9Qn2yeqE+WatQn6xeqE/WKtQn6xDqU9W3/KdqbflP1dHyn6q+5T9Va8t/qo6W/3S9lfTp6ivp07VW0qerr6RP11pJn66jkj5TfSV9ptZK+kwdlfSZ6ivpM7VW0mfqqKTP1VtJn6u+kj5XayV9rvpK+lytlfS5OirpS/UK9aXqhfpSrUJ9qXqhvlSrUF+qQ6hrzYaQWtaDKe70TJWAKeKRdWR6Qq2ZnlFrxK+Oqh1tfnTtcReMrhHwzrVG3K/WiMfUGnFtrREvqDXitbVGvKGOory11kzvrCPTj9Sa6cfryPRztWb6pToy/U8dcXMb1Qi4rdaIW46rHe30cTVmOq+OTC+oNdNL68j06lozfWcdmY4ZX3vcXeuIe0EdcT9fR9yBw7s1xh2xaY0FNKbWiONrjbhtrREn1RpxZq0RC7VGPLaOoryp1kxvqzXiPbVG/FitER+qNeIXa434WK0Rn6w14h9rjfjPWiO+UmvE5s1qjDi+1oiTIGIFO+0x6oxa8zwGIlbbKE+qNdMzao34RB1o/1prpi/WGnHHzWtHe00dcW/ZvEbAd9Ua8ed1oP1TrZk+V2vEWVvUjrZrixoz3aHWiLvWGnHvOticv3Xtcdu3rhFwb60RD60D7cl1xD29VsDn1hrxhjrQfqSOuB+rFfADtUb8fh1o/1RH3L/UCvi5WiNuvE3taKfXEXf2NjUCjmuNuG8daPvriLumVsCn1hrx6jrQ3lpH3NtrBfyhWiN+tQ60P6w105/VGvHFOtCO3rb2uK3b1gh4fK0R4zrQLqsj7s61At6z1ohr6kB7fh1xL6wV8JtrjXh7HWg/Xmumn6414g/rQPvnOuL+rVbA/6q5kW5XO9rD64i7ersaAZ9ca8Rza414OUScuD6bJ5+99qw1p609P5nXt9ea8z11CPjeWjN9rI5Mn6g107/XkWlm+9rjjti+RsAttUacWQfaM+uIe3GtgN9Wa8Trao14Y60R74GINbXUe2vN+bE6SuaJWjP9cx2Z/q3WTMdMqD3TcRNqzLRYR6Y71hF311oB711rxJPqQPtAHXG/VCvgb9Ya8fu1RvxprRH/ChFrUg//rDXnsfmo5pIZn68x00IdmXbUmun+dWR6cK2ZnltHppfXEffttQK+vtaI99eB9t91xG2aWCPgcRCxyoXBzWrNc9taIxYgYk0KoqPWnPefWHvZHFxrpmfUkek5tWZ6Yx2Z3lNH3HtrBfzJWiM+WQfaP9QR98+1Av5HrRHHTqod7Yo64l4yqUbAn60j0+zk2uOOnVwj4CV1ZLpnrZkeWmvEo+tAu9mUGjPddkrtmc6uNdO4jkz/D+LW1Nv8vlbUTVNrRz1yao2ZTqkj0xm1ZrpzHZnuXmumq+vI9MRaM31bHZleVWum99aR6SN1xP1SrYC/UWvE39eB9pU64q67MrdawM21RpwyrXa0C+qIu7hWwDvVGnFlHWjPqyPuG2sFfGmtEW+rA+3v64j7XK2AX6o1Ym56jRE3g4g19cZb1Zpz1/TaBbyg1kwPrSPTI2vN9MI6Mr2mjrjX1wr4xlojPlgH2hfqiDtiRo2Ax9QaMQ8Ra2o3U2rNedmM2uW0c62ZHl9HpufVEfeNtQK+tNaIt9WB9pk64vbOrD3uzjNrZHavWiMeWGvEo2uN2FeHfLaeNRS3psa6/awaUS+cVTvqJbVmelQdmR5Xa6YX1pHpJbVmemcdmX6qjrifqRXwI7VG/HkdaP9ZR9x/1wr4lVojbj27drRH1RF3zewaAZ9Wa8TLIGJNaunyWnO+qw453VNrpt+qI9Of1xH317UC/n2tEXNzake7Sx1xD5xTI+Ajao14CkSsqQqfUWvO19Yhp3fWmukDdWT6tTriPlYr4O/WGvGvdaDNza097qi5NQJuqzXinDrQLq8j7i61At6r1ogn1oH24jriXlYr4CtrjXh3HWgfqSPul2oF/I1aI/6+DrSv1BE3mlcj4OZaI06ZVyXaFhNIf2Bb/+DKrSgfDd02WKjn1xOvaIbE4aN/Q37KeNRQ3i0Y1rzX70i6GfNuJEhpIA7LZyCOedcE73LmXQ7ejTDvRkC2o5zLo9Cl0xztOt1C3DHK8OE23YL+1ns0JhqSTR7yGQ2yaqWycZd3jHlnDFE+9D4Hz1tCWApH8mg2z4Rd/78RPCfFG8XitUGYjSz85x3z38LwIH79GwHPG0dDbWBLwDbSOba4pyUaaisRyC9ieOk3EvA0O8dTiHVZ0HmR4/vPWvft9L37T17Zf8aZJ6w57dDBD4hmACwxsCVjIBMNZ+ZVCINKDJ+bLO/yEH8UhHHJeAYESmk3M0yjAJfDvIuolCOQXWSRAcpGRLkWCu3DOo4K8GDf476RFGIhPgvYibwauVX2GzFZZZms2iAMdgAbCcgvE61vmJCf8guYG4NZ4+E6rgXCNaUEI73DDkeiDQ4YkpCH/un+ZAd4J6BT2jMgfzLIcoznHITZIjMUdpl51wr/o2FsK0v3xmrpshwNGLEMyZXqQ0cyPCMtspDW5e7SjXtQx4xIkHEOwtAt8XCZ57qfTV/hQEn/WkFWaBgL1J92NIxL8UZhDizDGzeysxbeiKcWWd4GbIYxQjJrZTIj/DiYojBHlJFZa4LMsP3ywYoQb0WdbpuQzMYymRH+NpAZhVlRRmZjE2Q2BuREsqKwWQjXyuKOhDD696p5pnDY/0iOAVB3Eq8R4zViWGXKLO6odgzQBnjGOscz2J4F6uZAv0H1zPUYYGMmqyyTVRuEGQfy21hAfhnIl9ImP+UXMAfMAXPAHDAHzAFzwBwwB8wBc8AcMNePWfv5PEMLhBuZEoz0bixgtM3Pfw3eSWzE0Hj5hgnCgXOTFOaXEPYx89wK/48EfmxrGxKL6ZkoeX6+GTDiuhS5EuuoGciL0h5dQj64pkH1AudvsY6QOw74ondUv8bAu03M82h4x+eLcV28Dd5RPcD8aR59HLwjGW8M74hPzL+aeiIw91eynuCcpa2eCODpsOHJMTyoT5pZGIqbgzB/NK5tTldmznBw7Yby4+sbYwEjhXm2BMYMe5+P7Gs3bSwNId46sA/k+hF5ozD/ZLjwJ9PnDG6mk5gL1rxvAjzqtEdbeKcw/wE5vWiesX1jPzMqs/7/9Mswfx6eNwZZbuqe54H55M0AZx7ywbw3B6yO8o4x74whyofe5+B5ZGYo7OZMXiRrwq7bDH0IELHzeKNYvDYIM97Cf94x/5syPJsyzLpMXoFnqke4vuAa0/gEGeVARuPhmfAIrB1abQvCgZtPk/oMtOnW6VAjQ5vOQnsa7YW02tNol3Ce0Z72eU9Jo/Bw+ekwZJeWskUozMQS9UpmA/igLcLHM1hvCSOFmVoCI6ZFOG22CPE7Bv4T2GDdjm2B2yKtwBuFmV1G/hJ7EIR4H6ifaHPotEdaeKcwhcyQnIpga1AZ4Z60ZZb/6Zdh/jw8o64X0H0FtL+ovDe25D0esDrKe5jtR7YI5YM2IT0vBVuE95cka8Kuy4vqJGLn8caweNjPjrPwn3fMP5/72phh1mXSCfVsGdgiAodbYtvYCPdCkYwojG0vLM4N0P/Y10nNh/D9eOQfCRj5nrVye1b3yAz/zynunuJq6cNgWwOfLg+DDczJmHfNAMW53dBT6JbZP13sEbKfB3Qq31dI+eA+UNKvrnUqHt7C/hz7MHreCsJyG5jaDe7Fw0NfSfH4Hkq0nVss/Ocd88/tKb4/cUQ03L6ndjEXsLnXUcVVaTwgRme4ju8/a7+zV65d07fTirNWHHRGf3+Js2FzGfZMtP7ZMAqDOg2fX4dnwwpS9QrHVaRvCD+ef6AwdGlk0niE93VU7jh/jbIiV+q8mPux6KDM+FkAwm87CzC3jMySzgLg+IFkJXwWoChjGw7KjI97cc2HZEZhOsrILGnci3MTtnGvgN0rNKYclBkfT/MzADieXlhGZm0JMsM0eX+H+9/R3slG69sGtF+ep6HDC427hdYWBmXP14z4WQJcM9rZuNWuGbWC25g1o8EzBuMsGCOGMWL8ajybOMdT7ME15ErwbAJ4JOZ0Zfgc7MNpbO76jAFflxjLZNUGYXCdRGCNatjcDKVNfsovYA6YA+aAOWAOmAPmgDlgDpgD5oA5YA6YA+aAOWAOmAPmgDlgDpgD5oB5acAcMAfMNWHGPbd4VpbCjUsJRnqH53T5eVO9bv4fwCuw72LgjAa/p9B2joHCbJwZCvsyhBvL5NsSDe21QJlLnZfh93DyDw3g/Yi4t1LqnBq/47LVIh96brLIDM/JEA+4J5ufPcA6jvvKqU1iW9gUZELvshZ8iItcfg4J92piXaa9gpvAO9rjNR7e8TOOdDbd1/okgKfThsd2Hozky8+D4Z4zCrNNZrgs8Sezr3NwnxE/v03YsoCRwkwogRHTIpy2PV7E78ayvPWg3ud6FHmjMFPLyH8TAYwyvA8/l0vnwVotvFOYWdCHzDHP2L6xP1po+Z9+GebPw/MmIMvN3PM8sA8Jz0HnIR/MewvA6ijvGPPOGKJ86H0OnhdkhsJSOJIHyZqw63IjXYzYebwWFq8Nwmxq4T/vmP/NGJ7NGGZdJvOhnlE9ktpHZ7OVUe+SjCgMnlmQOqPJ76Xndh3afrzPwP3wFGbHEjoL7W60F3g/LqPbhp9JpbRtY5V1dixg5Dyj3X0W4I5c4+4ptJc611bN+TW8w4efX8OzOxlIboRrfgpFqbMbA+mOcp5uIUZblX6l+hXiTdejzUDGOlIzCy+0B7/kh9VsesV131PNh9W2hrCVfFgN7evIyNf2LZtK0muL0vfBNTwrLmWLcV01CmQpl3dR6Hskg+lKnOHGc9f0K9X28b4l3fabINJGLLzQuc2Cbb6mjeHDeQ3XbX8spJuJ1p9rQ3thPoTlZ0LwPLz+4XkcCms7jzOqwvTQHmm1yCXvWC5tDA8/36LLajLgkDqzmaSD8ByihP5Du4R+pdpSqwWPw7pawHsWMC+Js9S13lXSFg0/My6Icdg3x/Cc3Q6i+RatZ/w5DjxnvzOEXQayof4K5yRt35Tj4Wg+0aZHUJctdcLvcF1AOnIs8EH8Upg9gN+TAZv7sohXY1lkouF6Kgfvk8aEGJbC7Gvcct8t4ucK8e4mvON4qRNeh9/PkmNYNob3FOagMnwknY8caUnr0ArTiqLhdiuej+Tj5lIYshBmE8CDcZBnCnM0y4Pj3CQhv9GWtI6rMK0oGt5fI88UdxOIh20G26ztziHX9QdxZCCfVgv/xxtXy2otxENda8OP/RSODSTuPMH+ps2CV14H2dfGuH4ppYNsa5JnMJnir8USF/u944HfyDW/bH4nY8HG53f4XE6GzeXg/A7Vm40t4UYB3/nI7VisWShdiXsxqr1Lhnizze+MYOE1ZoHv1RbQjifduxHDp/PGeRhHeQ8bQ5Dew/Vk/cPvY+L8TtI9FajrqZ3h3X+2O74rSQ/12WiLXPKO5ZJ0bxrOxTVififpe7PY9iXWxYfpK/OrZL4E8bi8C6AtWv/boUJtMq72bmzbd6URYxrms1oseByWT2y7R1CofRZwPIjtca6ozOMBXY13Guej9ffN5CBMD4SNzTPuU8jCO2zPlB49o43QzOKW+64Ehaex8WgW39b/NAEvlK70+kKOYUHbj8IsNm65u5M4H82WtJZVmFYUDe+PcJ6JsGL/xvvPV1lYbLNtJeJhuvo3msVBfYjzSjjnQa7A92sKON6htJsYVizPZhYG5xcozD7GLff9bT4XbpvPKFWfKMwBZfJLmntvtqR1cIVpRdHw+oRz4nxPTDZa/47IUvWpVDzMS//GsDjYdyGmNpYPjmud9R9xoYCYED/is9171qj7Mnm9LVW3UadRmH7jJo1bS/VnbwR+I9f8bsB9CcQnuXw+Nwf/nwPhsC66H5/GQvsP4oKkrV7Nt9WJN9u4l9LBObdG3weMfVca7gPeDsJWch8wX5/U8uX6elSF6aXxnmDZ/bWlv+Mmu69hsI1uJJSuxFxFtXtliTfbvgbbnnuBexoLtvWNsQxfI9aKqO3z72ji+k4RwvI96Nxew7VHCou2DK77VpJeW2T/7oTUntakPZW4j38a4JDa15Ckg3Bfg9TafjX7GoTXcApJ60US35zTvLdGlfOOdbQVngUxFnB+H8dmS0XzHT7WJX3FceA6/64QdifznLSvwXYO8HyIY9Mdjd7vZdsLsBfgPRWwCZT7apR/Jhqum0bAe8JL4zFbGVGY/Y1b6R4APvbHve2uywHX7xELrvdTmEPK8LFxAh+jLGkdXmFaUTTcVsU6yvcglMKAc5B4pgjjIM8U5tgyOMcn5LeRJa2VFaYVRcP7aOSZf58I6yvtZeBywTPJrusP4shEw88ic/7XGFfL6hSIh+3Lhh/7JrxHW2KfFfYxYy14G6CDrPs+uX4ppYNQ9hSGzpskzQnxuLyvWzcHE7m1A6hPaoJ8zwdcfH0gaS8e1nX65V1hLTNvlcWMRw3lbZvPErFlewbvW3e/L2Mw3REC6eL6km3vJfZ9Enzp/mTYOfUK5hA3gjinreg7adkZx599cv8pZ637SA8Cx3evRvYP8WSj9Ss4hssbP08LGyweTkHDTv90w8BBFKa71DwX6vn1FIZ9QI0feBrATkIcNZyndR8+Y+/XffwMhK/fr/sAGryvdMJ4mPEL79YttMG7dQsu8G7dAT6YgN4WsnVeQXsKXUINr1doQ9TAwIXqGP+gD27KxQU7R3kPO5xEhgjf/JOD520gLJ/8o/qEHw7Che2kePywZxuEEf1AX5nNO7iJAA0r+nig8AaX3lo3uEjJSqdPH93rP+X0s/vP7h/88NouZ5/Sd9aaU0/ZccXatRkAynfZ4H9cMfMC1z9U6Djjk4Nn3EmIcUda3r0KQrH5ER8qOdyxwSu0rfNI2tkhbGl1YoeCMoqi17Sl1f4atbTauaWVs1haudeCpTVn3uCzSMPoXVV8vVpaP40gDqs8A3GIP3g3iikQ/W408QXvNmLyHFjigrzp3RhQKvSulfWg+l2beYfbE8cCf+SOM+9wK9bG5h02lk3MO1yWHW/eDbt6y7zD5TQ6ApaPXCm/uFOnu6frdAsdA0uWeztPd9Aq3cekRVYp5bMnyGpf8+zaKt0H0s1APvQ+B8+zICyFI3lQp0vYdR2hafF9S8Tbg8VrgzB7WfjPO+Z/b4Znb4ZZl8kEwOG+znaGOlv5r+o62wNhed2jad/XYp3F7d/u62xvqLOV/6qus7tAWF736Lqv12KdXQg43NfZVUJ1thjqbDR0jNxW9+hqutdind0dcLivs6uF6mx7qLPR0HK3re7RDNxrsc4eCjic19neolCdjXtCnVWTTRCW1z1aNXgt1tl+wOG+zravEqqzQc+q30UQltc9Ok7wWqyzZ5pnPf+1t5mEE51L6O3ol6nHg6u9r/d6fDWE5fUxb55fi/X4UvOs6/FBph5PgncHm3eTAa/7ut3ZFeYcKv5VXbdvhbC8jk4xz6/Fun094HBfZ3u7gl1ROVPV1tmPQFhe92hX2Wuxzt4GONzX2RVCdbbQF+psFD0EYXndm2GeX4t19j7zrO2FTxh7YRa8+6R5Nxvefcq8mwPvHjDv5sK7B827efDu0+bdfHj3GfOuAO8eMu9iePeweVeEd58179rh3efMuw5493nzrhPePWLedcG7L5h33fDui+ZdD7x71LzrhXdfMu8WwLsvm3cL4d1XzLtF8O6r5t0O8O5r5t1iePd1824JvPuGebcU3n3TvFsG7x4z75bDu2+ZdzvCu8fNu53g3bfNu53h3RPm3S7w7jvm3a7w7rvm3W7w7knzjuZpcWfh45lBd1QkcEVS3Nc3sKcjGv7LMH8engmD0E7HgZ2FtObZt2Lt2v3OWHPOirP6aV9hBiASbBIR/ocsvAph0rKnUGqfmk476SY83MMY8m583gKnr4u4LYx+pZovnsh2fxNL9Seym2XxDDuRLX0aplQ9wJvZBA4OFHHLYCVyxy/ROO9WarjhBruVrAAeIT6H3RLi8vZMLatWJquRTFZ4yhJv4mkVkF8G8qW0yY+3CfADHC3R8JsW04CR3mUBj0QbKKUPsAxx+zOX2YiUyQzxGwt1nV7VWMeAuSqhz3XyeKt/3oIDv6T617lD2MZlhvhCzJwf20GrfORW5pRXxHjAL2yhjqZ39Iz9uIQZjvY1x0j5Yd1pTuADb9Qr9VVb7KdRBphOFCXrE6lbpZPaBt4ehtvZCY+UfUF1IhMN7xNQFtL9nGue+K1yXMZ4s9uMEnXI1meiTo3M//yLA6OiSOD2wNLlNaqBeUcl8hbQb0XUpRHwHzE89BO+Hb5Y7RSHtC0lxOdAG20zabm2RccyWY1msmqLht8wRfKTutkj6cYxvNnDN8x4oy/qLdstmxsSo+2raFJ9Q5IOwzK0HS3EW3nTJLNhN+7CM2HdW9Z+LqJMqb/NMvmh/Xw/2M/7l7GfR7N3jbRNyY9fMyG+bPYk2s8C9lLRNvbjtgjWneYEPvAG/KMqtJ9RBngRAOVt0ydSY8ukttEKLtfLkjYR1Qmyx3AOgFypvllAxgP1jN90yGWMNx2uKWM/8xuz+A3uON7BW+GwL6C42Wj92xDpaDlPIx/J2lsCun9A9klf/bPdYHhmGdknfTUX2wrJC7/Cy2+vpnrOdQnJnsLhXRyScx1Jbc72BSKpvKMSeQv0UVWPOWxfa3CGJ+4buECmmq8P4Q2BEl9lFmqTA3qWjnm7HgMlfSUT7TwKg/e7bCIgP9v4hvx4y2nAHDAHzAFzwBwwB8wBc8AcMAfMAXPAHDAHzAFzwBwwB8wBc8AcMAfMAXPAHDAHzAFzwBwwB8wBc8AcMAfMAXPAHDAHzAFzwBwwB8wBc8AcMAfMAXPAHDAHzAFzwBwwB8wBc8AcMAfMAXPAHDAHzAFzwBwwB8wBc8AcMAfMAXPAHDAHzAFzwBwwB8wBc8AcMAfMAXPAHDAHzAFzwBwwB8wBc8AcMAfMAXPAHDAHzAFzwBwwB8wBc8AcMAfMAXPAHDAHzAFzwBwwB8wBc8AcMAfMAXPAHDAHzAFzwBwwB8wBc8AcMAfMAXPAHDAHzAFzwBwwB8wBc8AcMAfMAXPAHDAHzAFzwBwwB8wBc8AcMAfMAXPAHDAHzAFzwBwwB8wBc8AcMAfMAXPAHDAHzAFzwBwwB8wBc8AcMAfMAXPAHDAHzAFzwBwwB8wBc8AcMAfMAXPAHDAHzAFzwBwwB8wBc8AcMAfMAXPAHDAHzAFzwBwwB8wBc8AcMAfMAXPAHDAHzAFzwBwwB8wBc8AcMAfMAXPAHDAHzAFzwBwwB8wBc8AcMAfMAXPAHDAHzAFzwBwwB8wBc8AcMAfMAXPAHDAHzAFzwBwwB8wBc8AcMAfMAXPAHDAHzAFzwBwwB8wBc8AcMAfMAXPAHDAHzAFzwBwwB8wBc8AcMAfMAXPAHDAHzAFzwBwwB8wBc8AcMAfMAXPAHDAHzAFzwBwwB8wBc8AcMAfMAXPAHDAHzAFzwBwwl8Os8Yw2z4S1BcKNTglGejcO8IwVwpNleMiPZTjCPDdbZDYiZTLLAsaR5nkMYP30qCG8Y1zjjft6Nd5WyC9vwZGDMGfMHQr7WYOtlWEmfjZi70ZB2vnIrcwpL0qb/JRfq8EUwX+t8NwEGJtdYzRyHpmAkfLD+t2cwEcOwnzNyH9ctP6vDXhCGdAz6Y4WSA/1yYZqv1gmWcAzWggP1YmMSbuFyQL1yRiQGf2PdTsrhJHyorRHM/lgP9ECeFqE8CS1tZC3gI4uFIotkAf9Msyfh+cxgEei3bRAHpXgGS2Lp9AGeDAvqfaYVA9QXwnozyLq6krkPhbwbOweTxfaVZXgQZt6nHs8sRCfBbQVX3WYrpbVeCarsUxWbRBmE5DfeAH5ZSBfSpv8lF/AHDAHzBsWs8bD7eYWCJdNCUZ6h/MCAvq5ZJ+MZUg21EiLzFpSJjO0LWnsjWOOTUYP4RWwqbpQpjQvwHHkIEwHzAtsbgK0RuvbyDjPgTJ3PuY2MudjbvJTfq3Aj22cjLa0gE03IOfmBIyUnw4zDnDb+MhBmImGIdu8APKGc0823SE1P5bUDjYBjIQdbUbp8TXNAYy2yEIq73FMFuNC3uvyFugrqh5DSa8DYNurBM8mwnhKlY2w7TMwztrUfboDOnYzkxb1ZYSf8stBmIUl9CemRThJn1KarSCrzUBmm7nnbVh5kf4atwHyjkrkLVCmA2P9zd2nO1BXtjBpUV0h/JRfDsLsUqaubMHkQ3WF0mwFWW0BMttCQGal6koj845K5C1QpkWd7pbu0x2oK1uZtKiuEH7KLwdh9i9TV7Zi8qG6Qmm2gqy2Aplt5Z63knWF8ssCn1hnshCG/n/VvOf48w3iIUrgQahutOt0t3af7kCd28akRXWO8FN+OQhzbJk6tw2TD9U5SrMVZLUNyGwb97yVrHOUXxb43ArCZiEM/U91juPPNIiHKIEHobrRodPd1n26A3VuO5MW1TnCT/nlIMzJZercdkw+VOcozVaQ1XYgs+3c81ayzlF+WeAT61AWwtD/VOc4/kyDeIgSeBCqG5063e3dpztQ5yaYtKjOEX7KLwdh3lCmzk1g8qE6R2m2gqwoLM7HCa+llayHOIdJY1fbHCaOnScIYUyau7HJDMf0hBfrfxbC0P/UfrZjaeQjuXXDUnNAOHctnXdUIm/n+6bMniSqM9TGmll54H6jd5RpY1nGB9/fhPN62RLxKPymEAbnOzFMFnBSmHeXwCk515xUh5obmHdUIm+pOkTtneoQ11E5CPO+MnWI6xe+t6IVeNq4RDwKX6oOZVk6WIc+UKYOvRbnosvtM5OsQ7yvpzLBOkRhPlplX8/XAluBpwkl4lH4UnWI939Yhz5Rpg5J2RFJdQjtBL4GlDfPXO7UH/O2km8QD1ECD5J1kexLqosTmExyEObzZeri9owPqouUZivwtH2JeBS+VF2cwNLBuvjlEjhx/xzFFbLrS9ZPzJt4cbjfKsY8dNnytvuaq89mvaua9aWRgGeiEJ6RVeCZCHjy7vHEQnwOrGVNMmm53jM4mclqJJNVG4SZBPKbLCC/DORLaZOf8vMRM45jcaxN4TZOCUasu4RHoD6X1GFYhvyMDcqsJWUywzMTtLeJ1nB1//An2GMlMF9b1Hi3hfzygAPn8inMv+cMhf0L7LHaGvggd3P2TmodNgN5UdrkxzVOWk/AtSx6xj1WAvsKBuS8aQJG3AdKc3zNCXzkIMwLFdpTKAN6xj2HfK/pqGioDuQjt+WUdC6xFVziuRHznVQnyA7c0iILgT13BSEZD9QzvmeSyxj3TI4wD0ljB76nleoPpsn3i2YhL5wfyUbDzz3qH43teBo6vFQ9FNqvWsTxUKn9quv2VpaRPd83iu2YXH42MwvhNoK4+j3XJSR7Cof7HoT2QZRsc5SfUD9RxD4pAgz4y8PzpoDHfX3pKLREw/uEcnjwXJnEGWaps3FCY+lChsknD/LEs7MUBsfYeQH5lbJPKb9qMY/1EHOQc5BzEuYg5yDnJMxBzkHOSZiDnIOckzAHOQc5J2EOcg5yTsIc5BzknIQ5yDnIOQlzkHOQcxLmIOcg5yTMQc5BzkmYg5yDnJMwBzkHOSdhDnIOck7CHOQc5JyEOcg5yDkJc5BzkHMS5iDnIOckzEHOQc5JmIOcg5yTMAc514ZZ4+F7+vG7QJunBCO9w3O9o4XwbMnwkB/LkM6jbW2RWUvKZLYl4KIzePgdubktQ3jd3yFYHNhjvzXklwcceL8khRkD5wNjgw3PB+KZQH6nqdDZuwGZ87N35Mf7cokfPGfDzzC2QBysK1LfKuPfhSA/nr/ivDRCjpkEOUrmndS2x8uWQxHLPAL+I4aHftg3uNdzg+eGqvnm0WjA49F5ugKec3J9bojfs8O/Z9oWrX/nCp5jcshnyT5hgmze1jNUNlnkLXjyDZYF5Vct5pEeYg5yDnJOwhzkHOSchDnIOcg5CXOQc5BzEuYg5yDnJMxBzkHOSZiDnIOckzAHOQc5J2EOcg5yTsIc5BzknIQ5yDnIOQlzkHOQcxLmIOcg5yTMQc5BzkmYg5yDnJMwBzkHOSdhDnIOck7CHOQc5JyEOcg5yDkJc5BzkHMS5jTIWePh5xPwbM34lGCkd62AZ7QQnqRzJ1iGdI5kc4vM0nYeCc+Z0Tkg/G7uoWOG8Lr/hsvgeaTNIb884MBvZFGYSbOHwh5psOG5HjzLM5a9kzovkYmGn9/IR/bvYNm+tcTPHuF347CuSNXnVoabf9+o1cJLI+SYSZCjZN5JbVtYrxSxzCPgP2J46Dca8Lg/QzJ4Hml0FXiwr5L6jpHEWRnUwa7PI01kshrNZNUWNfY7m/x8FPkpv4A5YA6YA+aAOWAOmAPmgDlgDpgD5oA5YA6YA+aAOWAOmAPmgDlgDpgD5qUBc8AcMAfMAXPAHAXMhfp+AXPAHDAHzAFzwBwwB8wBc8AcMAfMXmLWePg5ghYI15oSjPSuEd+DSDofgmVI5z3GW2TWkjKZ4TdRBL7RUkj6PtIlrZL5xgN798dDfnkLjhyEuXvGUNi3GGx4rgfP8tjOqUmcl8hEyWfARgIGfv6wNVr/7FELxME6KNVORjLc5EfdwXlphBwzCXKUzDtJZwjrqyKWeQT8RwwP/SYAHve6qVhAPVgJnomAJ+8cz+B5JAEdPHAeaZJJy/V5pMlMVjbdTmEmgfwmC8jPZtOQf7Js3gOymFKBLKZY8ExpsCwov2oxT/IQc5BzkHMS5iDnIOckzEHOQc5JmIOcg5yTMAc5BzknYQ5yDnJOwhzkHOSchDnIOcg5CXOQc5BzEuYg59owazx8fagFwo1MCcaJ8D/hmSiEJ2ndD8uQ1vFaLTJrSZnMcP8ArcNS3dNrrrPbhvC6v5tvcD24FfLLAw7KLwdhHpk+FHZ+25Cc6X9cS7XtP8g756H02j7lh+uquNbK135bIE4j9iTkGW7yTwSMnJdGyDGTIEfJvMvd6ypUDkUs8wj4jxge+k0EPO7X8NoLqK8qwYN91STneAbXgyXWKlEHu14PnspkNZHJqg3CTAH5TRWQXyZaf32a/FNl8x6QxbQKZDHNgmdag2VB+VWLeUrA3BDMoW4EzEmYQ90ImJMwh7oRMCdhDnUjYE7CHOpGwJyEOdSNgDkJc6gbAXMS5lA3AuYkzKFuBMxJmEPdCJiTMIe6ETAnYQ51I2BOwhzqRsCchDnUjYA5CXOoG7VhbjPvo2j4fsDJECcNGOldI+4pSNo3h2VI++BGWmTWkjKZ4T5Z2sdI7UXvWdxs7BBe9/eaDO6nnAD55QEH5ZeDMHdPGwq7lcHWCnHywM9E9k5qv1cmSt7DSvnh3smJ8C4PeMmdxN5J1udJDDf5JwNGzksj5JhJkKNk3kl3DQnrlSKWeQT8RwwP/SYDHvd74OIe1FeV4MH+VWKPuAyfg/spSSe63k85nclqMpNVG4SZBvKbLiC/TLT+/k7yU34Bc2Mwj2L4HeU9UOdmVCCLGRY8MxosixmyeQ/IYmYFsphpwTOzwbKg/F4PmKcFzAFzAubpHmIOeqMxmEMbDJiTMAe9ETAnYQ5tMGBOwhz0xusHs8bD5zVbINyklGBs5PnaiQwP+bEMW+B/LrOWlMlsIuCitQKqeyMU3QbrGHn3eDtQprSOwe8CyEGYLSYNhf0ArGNQWFwDsK1vSd3FkbR2RPnh/Qq4RsDXLFogDtYVqfrM76oh/1TAyHlphBwzCXKUzDtpjVJYrxSxzCPgP2J46IfrBu7nY+MC6qtK8KBNILE2K8Pn4DoG6TrX6xi8r+fz2Y3u6/l8P/lL2ScBc8AcMAfMAXPAHDAHzAFzwFyo71cRZrwfFedNKNyUlGBs5P6YpPkFLEOaL5hkkVkj5p2qkRnuxRPYGzjsbkNKX88ZbTRuKF/3+yHjYd+Io/msiaxcchDmqYlDYdsMtqR5IdscotRe6KQ5RMoP97fiXBE9jwGMEnMUmWj9cwG2fW6kz5oT+MhBmK2M/MdF6/+QN5yfm8neaX5nOed3sEy4Hif/LMBIvMwEPNL3D9Nc3USLLKTyJj4p7RkNzHsiy9vGt3MdG/f16ryprEm3UD2m/HIQZkaJ+oxpEU7SOdjGiadZkrwZuXI8nDcdZrZ5bmZhZgH/FGZ+Cf51XzTGwptU201qK5i3gC4fmFuexXjPMH8entGWmeMeT1dLNFxvl8MzB/DMdo8nFuJzYG55rknL9dzyPCaraUxWbRBmLshvnoD8MpAvpU1+ys9HzEJ5D5Tf/ApkMd+CZ36DZUH5VYt5bsDcEMxpqBsaD/UvhLUFws1KCUZ6NxvwCOj9kvYhlqFtrD4HntMks4mAi8atVPe0HboSxtQC8x9FHPuQ3cvnP3IQ5jP5obCrYUxNYWdZ+MF6KnVOMmkOB8+6UhvCPSKIl1zbWdeJQrgnMdzknwgYbXttpOWYSZCjZN58zmHaBuA7ipLrDz3j/Itzu9mMRUk/UJukvCm/HIR5Q5mxKNdHsyy8cT3aMH4TdCbnV4chO6KZhZkDMqEwby4hkw3ZfrKAEXVKFsLg2CYbrT/HmY82bFvA8ZezvE29x75Ppz2HySQHYa4pU+/5uIjqva2OlxpPcfvGVhf5GAfr4rsqnCsRHh+VrJ+UXxZ4wfqVhTD0P9VPLsN8JGYDDsy5YPkQL/jLwzPOcbi39zoKaFtWgmc+4HHehsyci4BdOzDnUjBpuZ5ziZmsbPYyhSmA/GIB+dnGieSPZfMekEWxAlkULXiKDZYF5Vct5oKHmIOcg5yTMAc5BzknYQ5yDnJOwhzkHOSchDnIOcg5CXOQc5BzEuYg5yDnJMxBzkHOSZiDnIOckzAHOQc5J2EOcg5yTsIc5BzknIQ5yDnIOQlzkHOQcxLmIOcg5yTMQc5BzkmYg5yDnJMwBzkHOSdhDnIOck7CHOQc5JyEOQ1yxjPfePaRws1LCUZ614gzwknnWrAM6czfLIvMWlImM7w3ns5nUt3T52c+sfEQXvdnMQbvCZoL+eUBh+1M1pkThsI+aLC1RuufncF7NbCeNupuFPJTfhojnf3B+4AQL7kz2TuhO7hK3llkO986s4FyzCTIUTJvKh9Ke7Ylb6nvpGI5EP8Rw0M/vJut4BzP4P3ik6vAg/2rhN6V4XPwPBLpOtfnkXhfP5nJqtF9fYHhIX9RNu8BWbRXIIt2C572BsuC8qsWcxwwB8xRqM8Bc6jPhfp+Qc4Bc0Mxh/r8+sGs8fDxbQuEm5kSjPRuPuARGP+UnLfAMqR5iHkWmbWkTGY450ZzRtTG9ZzRtpsM4RUYy3egTGk+i3BQfngHcLw9hDXY8L4unAuax95JznNSXpQ2+Sm/VuBrHrzjc1dJc59S9Tlp7rMAGDkvjZBjJkGOknlT+VDacy15C5RDEcs8Av4jhod+wuszfaivKsGDNoHE/TBScy2og13PZ3UwWfH5ozYI0w7y6xCQn21+jfwdsnkPyKKzAll0WvB0NlgWlF+1mNsD5oZgDnUjYE7CHOpGwJyEOdSN2jDjvgccv1K4+SnB2Mh1waRxHpYhjdtmWmTWkjKZ2fZ/UHvRY+xzNhnCK7CPoANlSuN/vocB75/dZruhsBfA+J/i4NjZNi8kdX9l0pwL5YdjfRxb87F+C8RpxN4nfg8o+YuAkfPSCDlmEuQomXfS3p5G8h2V4FugDhSxvkUg+4jhoR+O9d2PF+Nu1JWV4MG+XWI+VWpcjPrf9dxDF5MVH+u3QZhOkF+XgPxscyHkp/wC5oA5YA6YA+aAOWAOmAPmgDlgDpgD5oA5YJbDrPHw+b4WCBenBGMj90kkzcNhGdK87HyLzFpSJjPcKyRxJgz32VH6em7+VVg3cL9fK+7OsPzy0fp7xXIQ5hfbDoXNjh98Tpp/t63VSO3VTFqrofxw/x3OydPzGMAoMR+bidbft8z1mg5D+qw5gY8chGk18h8Xrf9rA55QBnxfdAuk1wg9xdduyd8FGPk6m+R6QdI+yRjkaNNTtrUlqXXIpLUlXIekd3jmXGJ/Z7XfMBTeb1rAuyKE19GrXuPB+tsthKezCjzdgEeifQvxObDG02PScr3G08tk1clk1QZhekB+vQLyy0C+lDb5KT8fMaN+IqwtEC5OCUZ61wUY+d4Hbfd0jx/CK2A/D3zXHvPLR+vbzzkIcw/YZAstNlma+3ripxF9fZK9j3tLbP2ogHyKNvnETD5Yb5sje9+fgzC7lbEH57G4kv1SNf0k9ksC7b8DdU0leHoBT497PLEQnwP95AKTlut+ciGTlU1/UpgFIL+FAvKz9YHkp/wC5oA5CTPaI4S1BcLFKcHYIBuugHYOpa9tiRPBzhHoJzpwrpfbOZRfDsKcDnbOKWDncJsmybaU0OWlbEvKrxV4wL5Oys7h8+ddTBZJdo6AfDps8omZfLA9cDsH6wGFeUOFdo6wXVG1nYN2hYBe6UEdVgmehYBngXs8sRCfA3bOIpOWaztnByYrm16mMItAfjsIyM/Wt5Kf8guYA+aAOWB+PWBGu52wtkC4OCUYGzTWGWa3U/raNr4X7HYBu6dHy6EH8stH648fchCmF+z2j4Pdzm30pDGYhG1SagxG+bUiD4BHym7vYXh6mCyS7HYB+fTY5BMz+WB74HY71gMK80iFdruwnVy13Y52soBe6UEdVgmeHQDPIvd4YiE+B+z2xSYt13b7EiYrm16mMItBfksE5GfrW8lP+QXMAXPAHDC/HjCj3U5YWyBcnBKMDRrrDLPbKX1tG/8d7HaJ+UEthwWQXz5af/yQgzAZsNufB7ud2+hJYzAJ26TUGIzyawUe0HaTstsXMDwLmCyS7HYB+fTY5BMz+WB74HY71oN1cwWbDrrl7HZZWQ/uocX2ko/Wr3eIu7kEbptOaGd84J5htLml71B0mG7RJjPbnmIK01qlzPg3nlqj9fsjId5ioTY9ILPFTGZ833QOwmxaRmaLE2SG+7JJVhQ2C+GwD9Lvad8S/f+qeU/hcE+a0L7bDpuM+H1WKKPtqpQRrelivSK+0KaR4i1mvLVbeKMwk8vwFifwhuVPPMWyvBWFbKwBmS1lMiP8S0BmFGZWGZktTZAZ3gNNsloKMhPgrV2nu0xIZsuZzAj/MpAZhYnLyGx5gsyWgMyWmuflIDOJcwvaJuyyYIwYRvrhWQaKh3ckLXePser98yizHYXwLK8Cz46AR6B+xkJ8Dtg6O5m0XM8D7sxktZzJqg3C7ATy21lAfhnIl9ImP+XnI2a8X5OwtkC4zpRgpHfLACO/K1Tr3X03HcIrMCYr4pwNH3dTfjkI8+1thsIeaLC1Qlg8Q2E7Kyf1jYOkM5Z4D6Pt+zZS5+L4ecp2JgvcG9glK5+iTT6dTD46DNkvzZHdzsVzHceVGXfb+kmpc2+19OVC/VJXtf32MsAj9Z1QAT4LaPe47ie5/uxkskL9KWz3DLTlZQwP+Sm/gDlgDpg3LGbbvSstEK4rJRjpHZ4Hl9DPmnc+Xtc225VgTwrYGl0ZkD+fN6D88J6IG8CevAbsSdpfhOddbfaS1J3ZSedDcc6P9og14p6fpHMcKAsB+6ogJOMBm5Tf7WKzNynMzWXml/idPnw8gudchL+tFUvNj6KOKTWvTWFuLyOzZQkys90LT2GzEA71h35PYxw8/5CFcLjOIjSe7bLJqJPhQhl9uEoZkV7CekV8oS0vxRs/e1+08EZh7i/D2/wE3rD8eX+F5Y/9Fq4J8fLnaejwUvMZQvOxXWgTkewJP+WXgzAPl5E9t696mOzwjgScSxXgrR3nPB2mOyCznZnMCP9OIDMK82gZme2cILPlIDM+15aFvNDuy0brz1tSfeVp6PBCMurQ6e7iPt0B2e9q0iLZE37KLwdhvlVG9ruCPx8NyZ7SbAV5UVgh3jp1ursJyWx3JjPCvxvIjMJ8r4zMdk+Q2S4gM5IVhc1CuF0hrn7Pz+5SfaVweA5a6Fx0yT1FeKb19Zq3wDnlYrV3hOCZ/N0FZNESDT8PUg7P7sJ4SpUN5i2gMwb2tO1h0uL2JuoMCvOnMjpjD8YH7WdEe5N42gN428M9b8PkmmFybWTeUYm8pcp0T5MWt7OxTCnMc2XKdE/GB5Up2tnE057A257ueStZpo3MOyqRt1SZ7mXS4vY7limF+W+ZMt2L8UFlivY78bQX8LaXe95Klmkj845K5C1VpnubtPj4AsuUwozcbNBNKtO9GR9Upji+IJ72Bt72ds9byTKl/LLAJ+Faat7vzeRAtiLHv7RBPEQJPEjWjX1MWnz8g3WDwmxapm7sw/iguoHjH+JpH+BtH/e8lawblF8WngnXqwbTvuBfWiem1ean092vhnRXl/npdPevH2/MX0Qghyw8U16V/G8Lux/E2Y2Fe5X5R0ZDZYR1kv6fXKJOCrWbkm12N8hboF4PtFninY+/97HIZ2aZNrs/44PaLI6/eRlhfcu7461Lr/31WPLaUPqhEXlHJfLez33eA+Nk1NPEf8Tw0G8/wHOAEJ79qsBzAODZ1z2eWIjPgTXCA01arvcCHcRktR+TVRuEORDkd5CA/DKQL6VNfsrPR8waD7UbwtoC4fZJCUZ6ty/gEajPJXUYliG/SxRl1p0ymS0AjLQfA/dp7LfZEF6BdY6BtetdIL884MC1IApzKOwLOchga4Ww3RZ+UOZS53v5+Xby47ifxot4toWecW5W4G6cATkvSsCINgG/05LzgXdaHlvCzkK7BmVA70h3YDmhPpG6Uz+pnHoBI+FdAnikbCKqE2SPLbfIQuB8WEFIxsPuiB+RIGPc57W2jK3O91tR/cE2RLLC/VYS9Udyz9O+TGZ8LjgHYc4sI7N9E2SGdZxkhX2mlG5MquOUH/aZpMdb4H/hdbTYphvJ3wMY+b4O1On4DbFu9k5Stkn7/1Dn7mSRo9RaKOVFZb0h8o5K5C2xt6jadVi8q0VgPNeLbacSPKgDpL4dIcDnsD2orseX+zFZLWKyaoMweJZJYP4itul0Pq8YMAfMAXPAHDCnEzPauIS1BcJ1pwQjvcP5CIk551L2GpYh2dDLLTJrSZnMcOxC81V4hv6LMJcmsF+7F2XK18lwLzqF2Qrm0r5imUvDMc0S9i7Nc2n4XWSBubReibm075SZSxtjkQEfH+Nd5I0YMyfdRY7fEOJzP5Ljv6R5BvzGKNVfrOO28Xoavum5HPAI6IuSbS3kLbPeUe19SXh3jkS7aYmG98Pl8DRiHiepbIS/jVUQ0pUD/QXe3ZOP1teVOQjztzLzu/zOFuoHcH6XZIW2r9SZaLznOQ/+RuYdlcjbozmtXhzbUF0h/JRfDsK8VKauJI2TsI8mWeG+F4l9OLpv28mSl9T4Iqle7tvAvKMSeQvsJyvi+CgC/iOGh3645+xA93i6W6Lh++3K4cF9LxJ7OIT4LOB+Dtdz0QczWe3PZNUGYQ4C+R0sIL8M5Etpk5/yC5gD5oA5YK4WM86lEdYWCLdvSjDSO9yXK9CnlLQjsAz5fgqU2fKUyQznEWluEr/f3bn5EF6B+cVulCmfI7Xda/qzrYfC9hpsOK+F89IL2DvJeaSkfai2fWz4bUB6xnkFgfFRt21+kPLGb2jTOKA5gQ8c6+xk5J80R7qTRQb0jGsG+7F3QrZ4jPxR2uTfHzASz40YE+H3VPKRfd2Mz63jmALrdhrWXHAvjdR6RFJbC3mL7E0tVrt/CffpSrQbXP+qBI/w/EIBv5WGeUm1x6R6gPpKai6jmnNSwnMZxTCXUd8vjKMaZ29zOwPHBPulBGMjx1FJOgzLkK+joMwWpUxmeG6Lxi94huBiGEdJnSfiZxZ2YdjwzMKtMI66DMZRfOyFexhQ5htyD4NtbEXPaHtI9IGZaP1vrFPelJ8OQ22oOUpeX6Qw15YZRy2xyICebedAUZ9Itd+kM40HAkbiGfWJtE1E4yibTSR9ptphugP1jPquEQkyzkGY95aoQ5gW4aT6Q2m2gqwobDZav4/Km/f8XDTdW8PT0OGl6qGQ7h+Q/SEmLZI91/05CPPBMrI/BPz5aEj22FZIXhQ2C+FQlvo91yUkewqHc1yNmPPibQ73lm2o+TahPqqI/WEE/EcMD/1w365EXa32jseDAc8h7vFItckBPXuoScv1GOgwJqseJqs2CHMoyO8wAfnZxjfkp/x8xKzxcL3VAuF6U4KR3h0CeKTGF0k6DMuQbO5dLDJblDKZ4RiIxhlkX+h+9AkYA0nc44NjNuq3OY4chDkWxkDfgzHQAUy+yA/KXODO7JLz7XgfFo019oV39IxjIKmx5i4JGNEmoHbenMBHDsL8osIxEMqAr1diX4j6RKr98nEg18FYJmgHSNlEOP7Mg1/YJio00g7nMkY7/Jkq7XCqPziuJlmhHc77qLx5fwjDQnY4T0OHl6qHaBc5TLeINgbJnvBTfjkI83wZ2XN7ZRcmu1aQF4XNQjiUpX7PdQnJnsLhOo/k+m1Sm2vEnlZ+b6Itb4E+quo9rbsAHom6inOuleCRtoeF+BzQs4ebtFyPgY5gstqFyaoNwhwO8jtCQH4ZyJfSJj/l5yNm3CeB9jyF2zclGOndYYBHoD6X1GFYhmRzH2CR2aKUycy2vkf2he5Ht91iCK/UGOhgyC8frb+ul4MwE2EMlDfYWqP1x5i4voAyl9qnlbS+gPu0OF84dsMxkEQfaKu7lDflh2P85gQ+chBmtpG/zYZC3nDvHD+LJNlWk8Y7hwJGvqdQ0v6h8ifby7YvWWq80yibm8sYbe7uEvUF0yKcVH9wvEOyktb1aLs4TLeIdgDJjPAfDjKjMIvLyOyIBJlhHSdZHQEyE5hnKVnHFzQw76hE3gJ9WLetTElfYh9GYXarskypb7Pt+S1lX3LbBPupZhbmCMC57n7mEjhxjgvrlZRNk1Sv0Kahfp7k1QL/C+85jW3yJ/8SwEjvcC2V3wuJc+bLGyDbpDnzIwAjX09uxD4mXta4zmA7s5ImmeE6A5Y1YcPzEwJ7DYbd5ZMzaS9neGTkE/dVu/8a9YfUnKNAPSigLhnlLN1Oq62+iMmqDcII7yErqdts3zdxJ4uuTuyzSsniAAseqTv8k2RxgCVvh7IYyPvwCmRxuAWPgC1bUhaHW/J2KIsOnfeRFcjiSAueIxssC8qvWsz7pwDzKPbsJu/uAR13VAWyOMqC56gGy+IoS97uZFEcmM8+ugJZHG3Bc3SDZUH5VYv58BRgHsWe3eTdNWBrHVOBLI6x4DmmwbKg/KrFfLiHmI9KAeZR7NlN3l39Ou9jK5DFsRY8xzZYFsda8nYoi9U67+MqkMVxFjzHNVgWx1nydtivDthFKyqQxQoLnhUNlgXlVy3mozzEfKSHmPf3EPMBHmI+3EPMPrbBNNSNUezZTd5dfTrvlRXIYqUFz8oGy4Lyez1gPspDzId7iPkADzEf5yHmNMgZv0Hw6haSeOJVLQwPySxiGCOGsQWecX2jzzwvjdytQ2D59EFeq5zLY7B8eH0h/yrRvOM+ne5q9zwNzL8db9Ki9fvVFp5OMM8Zx/I8HtLNQD70PgfPL28xFJbCkTyo3RJ2vd7Yb54RO4+3ksVrgzD9Fv7zjvlfzfCsZph1mfwd2rlE3aqkXut9ENSWtzNu0jcc+9g7SX3Zx3CTfyVgJH2J+qFPCE/SNxwpv6Tv8qRJZm3wDtfqW4TwbMnwbGmRhVTem7K8N21g3mNZ3mMbmPdolvfoBuY9kuU9soF5T2B5T2hg3jNY3jMamPc0lve0BuY9m+U9u4F5z2V5z21g3jNZ3jNZ3q3wjN/dcv7tnLhvYJ2O8qA9Ufx7TkLjiL5qv9uzEvBI9NNCfav1bNZyxhPug8S9S1J79ZLsulJ7Z0th3t9DzAd4iLkRZ+BC3Ri+NuUL5qM8xOxjfT7aQ8w+ytnH+nyMh5iP9RDzcR5i9rE++9gPBlu0MZhDn9IYzD7WjRUBc0MwB5u/MZh9bIPHeYg5DXLW86A0J/rxLSXxDO6lQDwks4hhjBhG3IOxEmRG67JLI7d7KSgvXPvvdy6P0ntd+kXzHtxLcbx7ngbmf08wadFeiuMtPK0xzxnH8sR9DhnIh97n4Pm+LYfCUjiSB7Vbwq7XKWhfAmLn8Y5g8dogzGoL/3nH/B/P8BzPMOsyuRPauUTdqqRe670U1Ja3A7mE9fWwvl6o7xfW1yHtsL4un7cv6+sj4L9V7J2kDbqKYST/EYCRbFDZPaSDeCivjEmb593GZJVGmbXBO9w3MUYIT1L/2Yi8k/rPRuSd1H82Iu+k/rMReSf1n43IO6n/bETeSf1nI/JO6j8bkXdS/9mIvJP6z0bkndR/Bp0adKrrvINODTq1UXmnWaeivd8EeJyPkeK+gbkoyoP2/FLeOD4TmO8e2PNLYwX6ZZg/D89HAB6JsY/QeGVgzncl42kE4wnPKOKe35UCfJaaf1wJ5VAN5v09xJzWM9GlMKf17PlrrW4c6SHmtN6l8Fqrz0d7iNlHOftYn4/xEPOxHmI+zkPMPtZnH/vBYIs2BnPoUxqD2ce6sSJgbgjmYPM3BrOPbfA4DzGn5f40mhN9x1aSeNzfn0b7B5dGbvf8Ul64R1XgrrGSe7JXi+Y9uOf3BPc8Dcz/4v7SPOSDPJ1onjOO5Yn7cTOQD73PwfPVWw2FpXAkD2q3hF2vU9D+WcTO461k8dogzPEW/vOO+T+B4TmBYdZ8XQrtXKJuVVKvbfen6XZObS4H71aC3Ogd6lN6R2lvAu9I5pvBO5LJFvCO6sRW8I5ktg28O8mCeS3wRO9ONs/N8O4U85yFd6ea5+3h3WnmeWN4d7p53gjenWGet4Z3Z5pn3NN8lnneHN6dbZ5x//E55nk8vDvXPONe4fPMcyu8O988477eC8zztvDuDeYZ9+C+0Tzn4d2F5hn3y15knqfCuzeZ5xnw7mLzPAXeXWKep8O7S80z7k19s3meCO8uM8+T4N1bzPMcePdW8zwb3r3NPE+Gd5ebZ9wbeoV5ngXvrjTPuI/zKvO8EN693TzvAO+uNs8d8O4a87wY3l1rnmN49w7zvBTeXWeeu+Dd9ea5AO/eaZ7b4d27zPMyeHeDeZ4P795tnneEd+8xzzvDuxvN867w7ibzvDu8u9k87wHvbjHPe8K795rnveDdreZ5b3j3PvO8G7x7v3neB97dZp474d3t5nkevLvDPHfDuzvNcxHefcA87wfv7jLPB8G7D5rnXnj3IfN8CLy72zzjt5jvMc+HwbsPm+cF8I50Vz+8I/sR7TXS33hui/rU1fCO9OPx8I50wwnwjnT/GnhHuuZEeEf68SR4R2v7a+EdrfufDO9In50C76h/ORXekS48Dd6R7j8d3pH+PgPeUd90JrwjfXsWvCO9fDa8oz7sHHhHOv1ceEf92nnwjvqD8+Ed9XUXwDvqS94A76j/eyO8I51+IbyjPvEieEf92pvgHen0i+Fd3jxfAu9IB18K70gHvxnekW69DN6R7n8LvKN+463wjnT/2+Ad9RGXwzvqX66Ad6SXr4R3pL+vgnezzfPb4R31G1fDO+oProF3pC+uhXekM98B70gHXwfvSKdfD+9Ir7wT3pGufhe8o37jBnhH+uzd8I76g/fAO9JnN8I7+m73TfCO9NTN8I50zS3wjvq698I7ut/4VnhH/d/74B31de+Hd7Tn5DZ4t9Q83w7vqL+6A94tN893wjvqrz4A7+gOwbvgHfVhH4R3u5jnD8E76tfuhnfU59wD76ivIz2t9aHWYfTdVNTv+7N3oyDvfOR2DMK/V0p+yk9j5N/obIVn/I7vAvZO4+4Rwr2A4SY/fnOeeFgA7+iZ6lUG4vC08HvG9C3u5oT8chCmYBSz7fvboyKR794PfMuc7AEayxO2QwEjhekogRHTIpz7M35RlocBbwLlXbTxdiDDg7wtKCP/wwQwStZ1LD+d9gEW3inMkq2H5LTMPKPuOhjkuJ/lf/qVmuvD8j7CPc8D81JHAs485IN5HwVYHeUdY940L8W/ZZqD5323HgrLv4tq+x47rTEgdh5vFxYPv6d6uIX/fNSYeWjKT5fJTlDPqB5pTFLfsT48QUYHgowozAKQkdS37vm3rfm37rGPamZhKG4OwhxWQmdp3sgWIL6xv0U7QUC3lexvDwOM9G5/wMh51vVlWzPoaYX/cRy8P3sX7J/Ky8Ol/bMvhKF6Xcr+oTCnlOl/BdrkgP1D8ybc/jkYMFKYM8rYP4eAPx+Vtn8OAd4E9F/RxhuVzf4W3s4rI/9DBDBK6n4sP532ARbeKcyF0C+9CewbKrcDQY7XWP6nXyn7B8tbQN8WsL+j8j7MkvcRgNVR3sP6WrJ/KB96n4Pnq8H+4XYDyZqw6zZDdipi5/F6WDy82+lQC/95x/zzsc9hDPPAuhzUs2vA/pHqpw5NkNG+ICMKg/bPgUJ4uP1DOHDMzO0fCmOzf95dxv4hW4D4xv4W7QQB3Vayvz0EMNI7tNE4z7q+PGEmglvhf1wv6GXvJO0IyovS5nLGfq4X3tEz2j/cJhoFfOejxthtBwBG4sFmt6H9c0BCWrtAGKrXzQn55SDMR8v0vwJtcsD+ofUl6jMI24GAkcLcX8b+OQj8+WiovFG+JIODgLde97wVbbxR2fRaeHuwjPwPEsAoxHuMdY/snwUW3inMZ6Ff+jzYN1Ru+4IcH7f8T79S9g+Wt4C+LWB/R+V9iCXvwwCro7yH9bVk/1A+OA9Hz98C+4fbDSRrwo7z/YidxzuAxWuDMAdb+M875p+PfQ5hmHWZfBHq2eNg/0j1UwcnyGgXkBGFwXMWC4Tw8P6Hj7V1GCr/ZhYGxy0U5gdl7B+yBYhvtC3QThDQbTHyQmmT/yDASO/QRuM86/pyMdg/1A/j+pdtXktKtybZdWjrkD1jm0dZDrh72DuNez8h3HzOhvz7AUabLUfP+K3P/RLSQvuHyq85Ib8chHmmTP8rME/Qi3Yc9RmEDdsbhflrGfuH24QLGL8oS9wbLqBvum28cX2DvD1fRv4CNnl3I3Qt2T+LLLxTmBehX3oZ7BsqtyUgx422Wf9/+pWyf7C8BfRtAfs7Ku+DLHkfAlgd5T2sryX7h/LBeTh6Hr3NUFhuN5CsCTvO9yN2Hm8/Fq8Nwhxo4T/vmH8+9jmIYdZl8irUM6pHjRgDcBmh/cPXxDWeRUJ4eP9DOCg/HYbKn9s/uGZAYTYxMiy3/oXzJNx2kJxvWBIN55f8BwBGeodrWZxnXV86wf6hfrjbwlc38CVVjkl8UX74nfQl8G4J4CV3AXuXZrsN75LtTUgL7R8qv+YoeQxOYWaUqMsiYyTzjVzaL0h9Brf/chBmTgmMmBbh5HUbZVkE3gTK28qbbf6HwhTLyL8ogFGyrmP56bSXW3inMN3bDMmpF+wbags7gRx3s/xPv1L2D5a3wPimgDYft+Ux7wMAq6O8h9mbZP/Y1hvpeVewf/iYgWSNYwa+HmCLt4jFa4vWn7+T7Ov4eJDPPegyWQT1bDewf5YIYdo3QUZo/1AYXP9y/j1yg2c5w0M4cFzN178oDMXF9a/9ytg/ZAvY9pugnSCg20r2t0XAyPeWtFh4Hpg7NIcjcI8KnslZzt5J2j+8HMmP9s9OjAe0idBus5VHWu0f6i9K2T+4RkbnCUrZPxRmdZn+t9O9THpK2T+dgJHCnFil/cP73CT7Z7l73oo23qhsllt4O63x9k9RiPcY6x7ZPztZeKcwZ0O/dC7YN1Ruu4Ac32r5n37B/qnM/nlLCfuHZF2t/cP3P6TR/rkA6tlbwf6R6qf2TZDREpCRzf6R2o+0E8NDOHDMzO0fCkNx0f65poz9Q7YAzq1QXLQT0mD/oI3GeR7YLw/2D+ktPKs9n73TfC0T4ovyorTJT/lpjAXzTP/Z4i1h8shAGrz8KW4OwryvTJ8l0LcM2Ax0HnAE4x/7FgpzRxmbYUfw56MhO5DSbAV+d5TlrQvbaCmbgcLcXUb+AuOoLkmbYWfgUaddsPBOYe4FXf4xsAmo3DpBjo9Y/qdfKZthJ5Dlru55HrAZdgOcecgH894dsDrKO8a8yWagfOh9Dp4/DzYDhSN5kKwJO44RETuPN5/Fa4Mwu1j4zzvmf1eGZ1eGWZfJJ6CePQI2w45CmHZJkBHaDBRmGcioIIRnGcNDOCg/2zhzCcOHtv7XytgM1H/ivSW8v5WcI+qMhvNL/p0AI73De1Q4z7q+XGkumcC1F7yzpJ29k7SFKC9Km/yUH849tMvi6UFbhPRegeHJQZgflenDuV1DfXgBeCOe5gNvAvZZEeenOG/YHijMzxtvQxUlbdMdgUed9iIL7xTmN6Bbn7b00bjv45819uG4r2tn9zwXUGdTee9syXtXwOoo72H9BfXhlA+9z8HzP6AP530fyZqw4xwqYufx5rN4bZHdhhGwn4bZjJT2zgyzLpPfQz37J/ThUrp2pwQZFUBGFAZ1rdQ8BNf9hKPUvo8Cw4f7Pl4q04dTf4Z9OO//JMcRSfsjlgNGPvZtsfCs68u+0IfTXEEMcRaxd5qvHYT4WsT4Ij/lpzEuNM9Ytjwe8dkLYSgNXv4UNwdhNtp20E3qsxY75z/uxnIdwfhfDBjX2cklMNrqSDvjtxX4XSLK26A9tJTxVrDwRmE2LSP/pQIYhXgfNsYgm2GhhXcKs9W2Q3LaxjxjO1wAcpxl+Z9+pWyGpdGQLAXGeQXbPM+Olrx3BqyO8h7WP5HNQPngHC89z9x2KCzva0nWhB3XWBE7j7eIxWuL7DaTgL02zEaltHdkmHWZbA/1jOqR5F6J5QkyQpuBwuwAMloohGcHhodwUH46DF8rKDB8uFZQLKGzNG/Uf9r2SmDfulSI36S1gqWA0bZXgvOs68vfzYWTeN4gLsOXVDkm8UX54ZkTPAfF4xGf3RCG0uDlj3v8KczyMn2We9t30GbAcslH66/3oF2zSxmbgbeJdsYv2l87iPI2aDMsZrzZbDYKs1fDbbZBm0F6DzTZDL0W3inM/qDLDwSbgO+r0f+vtPxPv1I2w2KQpcDcSsE2r7TMkveOgNVR3sP6J7IZKB9cm6HnFWAz8L6WZE3YWwEnYufxFrB4bZHdZpKal1/G8CxjmHWZHAL1bCXYDFLjwaWRXUZoM1CYhSCjRt1LQThw31pSn4F70ijMiRXaDHiGgeJi3yo1blkYDeeXj1vaovX7gxYLz7q+3As2QxfjAc+pIl/Se9cp7R6GV2MkOwDLlscjPjshDKXByx/3y1OYC8r0We7PLg7aDFRm/E4ym11zURmbgdeRdsYv2l8LRXkrdOBcELcZkDcKc1nDbbZChxDvw8Y0ZDN0W3inMFeALr8KbAIqty6Q482W/+lXymbAO3cExpUF27zSEkveywCro7yH9U9kM1A+9B7ntG4Cm4H3tSRrPMtGOhax83g9LF5bZLeZBOy1kvPQlN/APWRQz24Gm0FqPLg4QUZoM1AYvKOrSwhPN8NDOCi/Un0GxcU+444KbQa874LiYt8qNW5JurtrEWDk/UGLhWddX04Em2E+4wH3TSBfUuWYtG+C8tMY6ZsHnaJ4BvtwlFM+Wr9e5SDMJ8r04byOUh+O+wuIJzxHInWvem8CbzYb6jNl+nCJu78kxxjYV+u0Oyy8U5jPg279AvTRfI/nwP1+lv/pV6oPRx0poDMKtjmsRZa8FwNWR3kPs5moD6d80Jai529DH877GZI1rq/x8ZItHj9Dh/3TQgv/ecf8J6254tzbl6CePQF9uJSuXZggI+zDKQzq2g4hPFz3Ew7KT4eh8ud9OJ4TWrffq8I+HM/x8f5PcnyctP++FzDy8wAtFp51femGPrzAeMDvCSFf7UJ88fNz5Kf80M7AfYO4h4LcDvZO6AzhAO4OhpvbGbj/rwPe0TPeK9GZkNY8CENl2pyQXw7CPFum/3WuI8y9Etz+4fYY2j9/r9L+KTJ+UZay55rtth2VTdHC27/LyL9bAKMM74N1HctPpz3fwjuFeRn6pf+CfUPlVgA5jtlu/f/pV8r+ET43XUCbj58RxrxxXdpR3sPsTbJ/KB+0Q9fNP283FJb30XzOF9eGETuP18niYd/eY+E/HzVmvIpzpPRhQqxHkv1UT4KM5oGMKEwHyGi+EB7e/xAOPHtH5d/MwlDcHITZ1MiwnP2DZwm47SCj2wb5LUTD+eVzE23R+nspWyw8D9zJtsngs24P9L1H3Dcas3eSupXyorTJj7YOl3NrNNxeI7edvZO0v5POdqCtw225DWlHCsmiiHKnX6m+C3WDwFitHe3gSvDg+SYJW1mIzwLqmlcjt30/1/UdTFao64Xn3obZX5Q2+UutgwbM7jFrPFzP4fdy21OCkd7JznmX1rtYhtQfxRaZtaRMZnhvikCfX0CbBO/q2RNs2Nh9vu2ZaP27geaxcsG7gZ4D+3pf85w07zKPvZO0OyivKLLbtGgbzYN39DwGMAr0d+2lbHPck8Lnc2y2OYU5ooxtPsYiA3pGm9Cmp6Ts9aQ21w0YiWe0QaTsQ6oTmWi4nY2ykLZTHKbbjv3niAQZ432fx5eoQ5X0xTifiXMAEvVHaF6n3TavQ/hxLyCFOaWMzBYkyAzrON/HlY3Wv283b97zu/JeNe95Gjq85DqqwLzOgOz5PjA+r4P7wM4rI3u+RtbBZIdnJ3Hf0Tz3vJXULzg/RP0j9qFp6jvbovVtAuQta+LNMv5OWbkW0GbJRfa+FG2WK2AulMq8KRpeHtgHd7C0Kc4seN/B0m7gvsQ+xDiC8bHIgvHqMhgF6lWf5L4l1As6bdtZEwpzPdir74J1BaovM0GOd1r+p1+G+fPwjHM3Amv/A/WdnzdebMl7KWB1lPewvYMZljaee6HnO7ZbHwPJg2RN2PFcsw07xZvH4uFZgh0s/Ocd88/3gSxmmHWZvAfq2Z0wZpOaH94hQUYxyIjCkH1mm5/l+xdwTr05stvEuD7w4TK6ZaZ7/q36j7DNBIwU5r4NpP8EeLfqv6KFdwrzSaiXD4B+43aI/v8rlv/pF/RfZfrvyyX0H9djleq/mMVLo/77DNSzr4D+k7oLbocEGbWDjChMqbllCo/6j9pTMwtj+w7Kt8roFgH716r/CNs8wEhhvrOB9J/UmCrJ/kPeKcwPoF7+CPQblWkMcvyd5X/6Bf1Xmf77bQn9x/VYpfqvncVLo/57CurZ7zaA/cd1FOq/BfCO9i7g/C+/n1loraHkfg20W/n9i6iTKR6NxVFvE0/NLAzOFVCYf5TQiS2WuLpcz4H9IXwfAa6v49zxhtxnSjK1zf/jOo1tzW1Dzv/bzuvQM+6P7U5IC/fH8u+ulZoLz24/6Db6u2v8DA0/z4xnaJpLYMS0CKdt7plkgGc2BGyAdhtvtvUsCjOmjPwl5v4l51X5d9diC+8UZuPth+Q03jzj+R/UQ5Ms/9OvlJ2C5S0wl1/A+VUq74WWvPEcj6O8h52PITuF8sF5QXqeuP1QWN6XkqzxXiLqQxE7j9fN4tn6YOQ/H8nYxZQ2v+9Bl8nmUM+oHkn2UwsSZITrHxQG13ul7A/e/9jWNfj4j69H4/hvVgmdhfuC8HyQbQ+i1PmgpH04uIebn6FosfCMe1F0e5hs3s+EOPPZO8nxf9K5JzwHy/c+45khtH/4ntm07evdkPa4kCyK1c4x4v4rgf66A9tlJXhw3C2xN0WIzwLqetf7Y7luLTJZNXoPYtIYCe9zCJgDZhtmPNuC+zIoXCPusagEo23OQWo8k9RXYBlSHzrfIrOWlMmsAHgE7JQCziPh+cZ+sLsFzoF1ZFh+ecCB305bdwZ8wlDYNQYb2iFoK81i7yRtJcoriuzzeWjPzYJ39Ix7egX66I5S85K45k71rdS8JIU5q8x4YoxFBvxcfpKe2pBzkcQz2k1SNi2edcxH9vsYpG0rh+l2YP85IkHGuC/8kjJzhOX6Ypw7bsQ5MIG55g6cf+P3Dtjmfi8vI7OeBJlhHefnR7KQF/Z3uHcXz6plLWno8EIyKgrNO3TgvE8l+6mvLyN7PodUZLKz7aeWnC8WmDu13odZah/0TWVktihBZuX2Qc9yz1tJnUz5oe2Idkea7I22aH07CnmjfdBzjb9dVq4FtPNykd3+GLZXD+a8+T5ovi6Mtg3fBz0X3hdZ2g28U3/YPnD+/d1FFoz3lcEocEdMQYZ3+z6YeRbe1+0DhHn/B2D9iOrLZJDjVyz/0y/D/Hl4xjm6Ru+DwbyXAlZHeVe/D3D79TGQPEjW1e6DmcXipXIfINSzr8A4t1H7ALl+xjU429kVise/1azDUHtqjuzjiByE+VYZ3TLZOf92/UfYJgNGCvOdDaT/3PNeeh8g8r5uHyDUyx+BfuN2yMD+Lcv/9Av6r8J9gCX0H9djleq/+SxeKvcBQj37Heg/qb2wOyTIyHYOpNR8vO0cXNI5EFwHpzDPltEt7u1fu/4jbHhWj8L8fQPpP6kxVZL9h7xTmH9BvfwP6Dd+p5X+v3nC+v/TL+i/yvTfiAnrYyB5cD32WjoH8hLUM6pHG+IcCK73VHIOhK892uw/PjeH9l+r4TVJt7hf57HrP8KG6zwUZuMyGKX0n9Rdh0n2H/JOYTaHNa4tQb/x7xvp/6db/qdf0H+V6b9pJfRfredAuli8NOq/baCeTQf91yj7z3aHle0cCO3Rw73/FKcR+/eSvuuF98bzM22okykezUWWukNpLksH18raS+jEFktcXa7bbjL4HO5Jrx13I+5JnwVhqrknfacy/WQa7knfrQRGTItwbrh70gfXtjhvtj0QFGafMvKXWC+WXFeq5p70A6H/OBjsENs96ass/9OvlJ0S7kkfeu4DO+X1dE/6YVDPVoGd0uh70nH913ZPeqPOD/B9ethH8X1bOL6gMGtL6Kyke9Jte7Skzl0m9bd4T7rtbkjOM+5f1O1hjnk/zxJnHvAltQaQtGZP+WmMs82zbY8g2j/8bMiGPr9CPOC5bKmx9GSGx5a3gCyK1a6x4J5dCVsFz8NXggfH3RL7GYX4LKCufzVy2/dzXcPP8zd633rSGAm/CRYwB8w2zHhnBu5Lo3DzU4LRNucgNZ5J6iuwDKkPnWWRWSPuNK1GZpMBj4CdUsB5JNxn9aEJovl2oH1E4zCOIwdhLsgPhf2IwdYKcdBWmszeSdpKSfUNbSWb3UfPeA5EoI8edt6GYyx1rpzzgWs1D5YZT4yxyICvfyTpqQ05F8l1haRNi/N/+Wj9sUwjbCuH6XZg/zkiQcY4Jv1ymTnCcn0xzh034rxzo87OEH7b3O9jZWTWlSAzrOP8zGEW8sL+Ds974JnsrCUNHV5IRsW0nMH5QRnZ8zkk/g1b2xkcId7a03J25mdlZLYgQWblvkXAv+OeN+95n8W/RYB2TCPmfbhup/zQBkX7JU12Sxu8Q37omc6T0Hos2vYSdmomGn62AzHjnmcK8zeYO6e6Q+dJZrF4aCNR2hQH7y0usLST1oAWOOe/Y9h5Gr5OtcCC8bkyGN3Xq46CDO/D1w2ofGZbeKcwL8D6wUuwDkX1ZQ7IcXR+/f/pl2H+PDzjXJ/AGZqB8sa7sfKQD+a9GLA6ynvY3o2MIcqH3ufgeVR+KCzfh0KyJuxap9NaD2Ln8SazeG0QZqGF/7xj/vkZxUUM88C3oqGeUT3SmOYKYVqYICNcp6IwtjOAFM92DwC1p1LrSRRmXN640fo/zf8c5/zb9R9hmwMY130bOF8ao5T+c8+7Xf/NtfBOYbbKD8lpG/OcdJ5uluV/+gX9V5n+m5kfCltOj1Wq/2axeGnUf9vnh56pHmlMs4UwLUyQEZ6nozA4rz+XxbOdJ6Zy4ufp0OZcZ2/mB93G3Vlv139zGa/D7s3Jl8Yopf+k5syT7D/bXb0L8kNyWmSek87T7Wn5n35B/1Wm//bID4Utp8cq1X/8rHwa9d+S/NAz1aNGnCnlMpoLMqIwpc7T8TsgbPbfXJYO2n8H5Afdxp2ns+s/23k6CnNIvjRGKf0ndZ6O67/JFt4pzJH5ITkdbZ5xnQ/3S621/E+/oP8q038n5YfCltNjleq/uSxeGvXfcfmhZ6pHjbT/uI6y7WXF74Pa5lpxH+CG2r+Gc60kO9TJFI/mIlFvE0/NLAzFxTnR8/KDbtJ5Eh5Xl+snNh58xnVsXMNN0/dZcA3XtvaMewRs+z025Nqz7a5tesbzJO0Jac2FMHxvcKl12Cvyg27DxjLmPAmti/F1T7TnKczV+WSMmBbhtK178jMmQmsrHTbeqGwKFt7emU/mTWrdWXJdCctPp23bR0JhbswPyelm84zfN8Nx2j2W/+lXyk7B8hZYax2wU/g6crcl717A6ijvYWcXyE7h32nHNey780Nh+TkM/s0q27d4bPH4NyTaIEyXhf+8Y/75WTK+Hq3L5Nb80DPVI8l+qitBRjhOozC410hq3Mj7H77PToeh8ufjPzwHRmE+nh90k/Z/2b7jZtvfJHV+M+ncRSdg5GvALRaecR+kbg/TzXvcNzqJvdN8TRTii/KitMlP+WmM08zzJHg3CfCSO5u9k1y74HYs+ecARuJhNuCRGkdMZHhseQvIoohyp1+pvmsO4BE4o9/eAnlUggfHShJrnEJ8Drvnw/V5Ej4m4WfO8JuRwueVBuo2v4OA/Hh2MGCWx6zxcD2H366anRKMfG5EqA2W1LtYhtQfTbLIrBH74qqR2UTAI9DnF3BOhtLXNskf86L5tqOtQWMajiMHYW6ZOBT2WYOtNRr+/TVyJ7J3knZHUn1Du8NmQ9Ezns0Q6O8G5DwnASPO5/C7vjgfeNfXf/KDbrmzGSgDekab0KanpOZHk9ocfhuP6wpJ+5DqRCYabmejLKTtFIfptmP/OSJBxrh2ljPCTppvK9cX47l2Cov7tum/V6Ph43AXttlq88PzM9Wku7rMz9HZ5Ji/iEAOWXjGua5y/9vCFiEOH5e/yvwjo8h6Tx39v3GJeiHVJwvNy7fjvAi1CT5vjGfeNi/TJvgcC7UJXIfgd+sI8VYUmttqx/ldPm+Pe/ApzHZlZNaRIDPbvD2FzUI4PB+n3/N+kc5/UDi0lRoxT8P7D8oP7Vy0kdJkG7XBO+SHnun8B80h4vhBwhbORMPPYiBm3KO37jzKxCHMVHfo/MckFg/tMEqb4uBZ5Dks7cbt/yt0IcYRjI8OC8bOMhgF6lWX5P4/1C867WkW3inMAhiPLDLP2L6mgxz3tPxPvwzz5+EZ5+YEvhc5UN/5vXRdlrxx/cdR3sPWVTLR8PONeDaSnveAtsbPQZKsCbvW6TQPX+rO44ksHt7B1WnhP++Yf76Gw89uDuz/g3pG9UhjmimEqTNBRpNARhSm1D4SCo/za9SemiP7mCcHYQ4oo1umu+ffqv8I23TASGEO2UD6T4B3q/6baeGdwhwJ9fJo0G/cDhnYt2X5n35B/1Wm/04qof+4HqtU/01i8dKo/46DerYW9N80IUydCTKaDTKiMHj+bSaLx+cm0B5uZmHQ5qQwZ5bRLQJzOFb9N5Pxivrv3A2k/6TmCJPsP+SdwrwR6uVFoN+oTHFu+2rL//QL+q8y/ff2EvqP67FK9d9sFi+N+u8SqGdXg/6bKISpM0FGM0FGFMb2XVCc36f2g/tWJgnhnsZw8z0qbfCOZIc6meLxvYRo2/J7qygunlu5qYRObLHE1eW60gTGtSKUI187kdobgfqf0iY/5YfrJLb1HVyHs62pbsj1Hf4tg1Z4xv3P8xPSmglhqH40R+XXOj5cpp90Pqdt9j/jN13y0fr3OGJ/dl8JjJgW4ZzD+EVZ4j0tAjZAu403Kps5Ft4+VUb+EvPYkvOq/B6ZiRbeKcxD0H98FuwQKje0Ux6z/E+/DPPn4Vn4Ox/D7tRNWhPAvZ6u7RQ85419JM4L0vM3wU5JGkuUOjNgi8fX1Gx9MPKfd8w/Pw/C74/TZfII1LPHwE6R6qeKCTJCO4XC4Hq+lN3E+x++l0WHofLn56jwuzwU5nsldBbu+8JzUrY9BFL7zycxfsmP393kayAtFp5xrxGerZoCcaayd5Ljf8qL0iY/5Yc22lR4NxXwkjudvdO4Zwjhns5wk38GYCQepsM7ekb7Z0ZCWliXqRybE/LDdbI/lul/nc9lG/uH3/1L2HC+hcI8W8b+4fv9pzJ+bXv3R0G4vCvezHcPOW9UNlMtvP2zjPwlvk0rw/tgXedrtJMsvFOY/0C/9CLYN1RueE/RqEnr/0+/UvYPlreAzTfsXkIq7zmWvPE7cY7yjjFvsn/4fl48/zty0lBY3ifyu/FwD1epb9zNYPFwf6zwfrmSY2Lsw16Bekb1SLKfmp0go4kgI752JTn/wvsfwoH7Ovj9RxMZPrz/aJyJmGT/kC1AfOPcCtoJUndlJJ23x3vy6N00wMh51vVlI5j/yZv3uDd9CnsnqVspL0qb/GjrcDm3RsPtNXKnsXeSa5dJ839o63BbbkPakUKyKKLc6Veq70LdILCnoAvt4Erw4LdXJWxlIT6H3cvj+vwX1/XTmaxQ16M9ILV3na918js9AuaAOWDesJhxvQvnISjctJRgpHczAI/U3rakPhnLkGyVKRaZtaRMZlMBj4A9WEB7ldLX9uqBML6Z4j7frgzLLw84KL8chDlx2lDYQw22JJs0bXNyfDxgm5OTss1KzfXhWie/t8M210dhVpYZt42xyICecbwwi72TbHNJd3nMBoy2uT2psQPViUw0vO5PAzna9JRtvCU1/k0ab+H4l++3kFx/SWprIW8RHV3EvoF+GebPw7P02g3Ok1SCpxFzAEllg3kLtM+CkK607g/luhL3h15aoi/AtAgn9QP4nWqSFe5HlNhXgXOKmJdUnzMd5JAH/+wG5h2VyFtg3b7qu4nwvJ/EmfWWqLr7iPHOF4m1BiE+C7jHzPXcFN8Xxu9/boMweKey1L6EpO/K43e4AmZ5zDgfgvs/KFwj9qhUgpHeNeKO5iS9i2VINtUMi8wmpkxmOJamsTjuS7gX5gkExq/tmWj9fRB8TgfHpnNgnuDjME/A92rhPAHKXGrNLale4Job1QfbPAHa1lL7bacmYKT8dBh+TzjnA/cJfK7C9V3bHivcGz+XvZPcB8C/8WPbT048o+0iZcdRnSAbcgaTBeoTnMOk/7FuS+3T5PPmvE/AfgLngDfUnNzrOW8BHV2sdi8Vrv9KtBucz68Ej/B4rIDz+Y0435NUD4TvZixWO9ZCe0zizic8n1QJHrSpJexDIT4LaCu6HvvxPfi2eywpDJ7TKArILwP5Utrkx3OKvM9ugXBzU4KxkXfMJukDLEPS31MtMpuRMpnhmITPTWq7/3kYk0joc5zXpP3JpeZI/zp1CNsLMCbhNhGOSVDmG3JMQnzZxiTYj0vZ40ljEtxLTG2o1JiEwjSZjY1JY5KZFhnQs22OA/WJVPtNGq/jnYB8nkHSvqA6QWOSWRZZSM9xuuapmnO040rUIUyLcFL9sZ1Txj5Tat9sUnlNb2DeUYm8BfRbsdo9qbjPRsoWnVoFHun5XUlbtJb7csv9tKz4GdWpTFZtEEb4btSSNgue4eV9EdpV01OCkX//TlLPJukDmy062yKzGSmTGX7Dh9+XoPuSePIQXol9ADj/RrYoPzeGd5fcD7Zop8GGd3ugLTqLvZO0RZPqBdphfO8t2qcbwhalvEvZopwPtEWXlrAjbLZ3ku7YkN/J5HaSpC2Be7Xzkf3sm/T8imueku4Ox3vKKMxeZexOPlfDdSuOE7B/lFoLTSqv+Q3MO0pp3gJ9gfUuer5mi/XpsCrrE/URqJP5XfS2eBQe9STfbzyVpYNrusdUOGbHOi11viCpTlN+2Wj98V7GvOdzC3SvPL/XJLOBeUAbDO/8sp3jkD7/T2lz2SWtqQjM9w20K9wHr9MuWvIWuAeiD+1K+mWYPw/POI6VqD9CZT7sbOUoZ+l2Fm3zMVyP4b4qxCDV5yedUYotebuTRVenbQxtk4Xt3i2psVaSLNoteTuUxbA7v0rJosOCR+rbBEmy6LDk7VAWw741XkoWnRY8UveRJcmi1B1qpTDHKcA8ij27ybt7QMd1VSCLLgsegTuHS8qiy5K3O1kUh913XEoW3RY8At91LykLvBu5GswdKcA8ij27ybtr4E6vngpk0WPBI3WHc5IsSt07XQpzh4eYu1KAeRR7dpN3V7/Ou7cCWfRa8PQ2WBa9lrwdymK1zntBBbJYYMGzoMGyWGDJ22G/OmAXLaxAFgsteBY2WBaUX7WYuzzE3Okh5thDzO0eYu7wELOPbTANdWMUe3aTd1efzntRBbJYZMGzqMGyoPxeD5i7PMTc4SHmdg8xL/AQcxrkrNczZpjn5imSeOJV1e6BIwwt8IzrGzuY56WR27M6lNcOkNdi5/IYLB9eX8i/WDTvuA/7S3fpDu5HWmbSGsHSRp6Wm+eMY3kug3QzkA+9z8Fz05ShsBSO5EHtdqlx9Vr3EvOM2Hm8RSxeG4RZYuE/75j/pQzPUoZ54AwC7EmTqFuV1Gu9lk9teTvj4rdSJhpXt/0d2DtJfbkDw03+RYCR9CXqhx2E8FBeGZP2hsg7SmHerfCMZ+MF1qYH7kSieks6jfLGfX0UZnMDKGlfzWLGW9HCG28vNn5taVEY3GtDGJtZmMWAfV1bLIF9Q9Zz3FeDbT8brV8WtK+G9+P5KLTVDZW3VLukPpXaJdVpbJcUZk6ZdrmE8UHt0tYGl5SIR+FLtcHFLB1sg8USOPHeDLQnBO7/K1mnKb8s8IL1Kwth6H9ql1yP5TcwD3iHBpU53jWIdofUOCDpmwyLASP/HgaetXGIZ9idsbTfbQmTj5TtWO2dkzimkKg/QmVeQJ1AaU9kPLVF6+/fFdKlsc2W4Lq0Wsyxh5jbPcTc4SFmH+tGp4eYuzzE7GN97vYQs49y9rE+93iIuddDzAs8xOxjffaxHwy2aGMwhz6lMZh9rBsLA+aGYA42f2Mw+9gGfbSR0iBn3CfznSmSeAb3ySAeklnEMEYMI+6vwXnRpeZ5qTOMg/tkpkK6lNcy5/IovY9pmWjeg/tkdnTP08D8704mrREm7R0tPO1snjOO5bkTpJuBfOh9Dp4fh30yFI7kQe2WsOs1Mtprgth5vKksXhuEWW7hP++Y/x0Znh0ZZl0mj0I7l6hbldRrvQZIbRn3ydB6TAu4S9k7SX25lOEm/1TASPpyKeBZKoQnaY2P8sDv6S1Jqcza4B3yQ89ZE2+C8eNa3FL3mAd0FK5PY9p4TwuFeRr0BNXZpmh4eeA9MVNZ2hRnAryfytJO2pcisBbZgxhHMD5se2f+UAajgK3QI8P78L2UVD6TLbxTmGenDMnpr+YZ21ce5Phfy//0q8TO2RB9Muadhj75lRJ9ct48V9snL2Xx0tgn/wPq2X+hf14ihGl5goxmgIwozDSQLf92KoXHPUHUnppZGIqbgzA5UwGTdEveOf92/Yff0SSM69pGGYxS+i/vPF27/sM6Ru8pTOvUITmNNc/4XZSlIMftLf/TL+i/yvTfdlOHwpbTY5XqvxksXhr13yZQz6geaUyThTAtT5ARfqeawswF2fLvaFF41H/UnppZGIqLtuXUMrplqXP+7fqPsC0FjBRm5gbSf+55L23/Ie8UZh7UywLoNyrTGSDHJZb/6Rf0X2X6b3EJ/cf1WKX6bxqLl0b91w71bAnov0bZf1xHof7D7z3zb6vwbxLZ7L+5LB20/3Ypo1tmOOffrv/492lQ/+2xgfSfe95L23/IO4XZF+rl/qDfqEyngRyPs/xPv6D/KtN/x5bQf1yPVar/5rJ4adR/B0E9O24D2H9cR6H+w/uO+TeLbN9t4vYf/4YR2n/Hl9Et05zzb9d/hA3H6BTmpA2k/9zzXtr+Q94pzGlQL88A/ca/Pan/v8TyP/2C/qtM/11cQv9xPVap/pvO4qVR/50N9eySDWD/2b7nTmHwHpDJLB7/Bj2OkZtZmHVzfhDm8jK6ReC+Dqv+m8x4Rf339g2k/6TuAkiy/5B3CnMd1Mt3gn6jMp0OcrzD8j/9gv6rTP/dXkL/cT1Wqf6bz+KlUf+9G+rZHaD/pL71uDxBRpNBRhRmB3g3yTxTeLzHYxLIUspuTbrHA3HTu1LzlrQWXeobTxNYOviNp/tK6MQWS1xdrreNHXzGb17hN6CmsnejosZ982oqkwd+p2oqvKPnGYB7PnuncW/Ib6YSD/hdTtu3WAoJac2BMHS+oDkhP/x+6BfK9JMC352wfhuo1LemvlwCI6ZFOKcyfm3fBpLcW8N54/euIW/fLCN/iW9cS/KO5afTtn1zjsI8Af3Hd8EOoXLD72j/yvI//UrZKVjeAt/KGLBTOgFnHvLBvLsAq6O8Y8yb7BT+XYUcPP8S7BT+jQaSNWHXbYb2OiN2Hq/A4uG3Hdot/Ocd88+/m9LBMOsy+T7Us1+BnSLVT7UnyGgOyIjCCH+Hzdr/8G9y6jBU/s0sDM5/UZg/lNBZ+J1Z4rslsn8fUUK3IS+UNvmLgJHezQOMpb6Zit8lxW+v8zklSd3K13H493xtNhp+ZxHtn3ns3ahI7huE8xhum61js+XoGe2f+QlpYV2meteckF8Owvy3TP8rYBO2Yz/J53JtNlpmWjJGTItw8nkhlCWePZUqb87bLIYHeRtZgjch+zOW5B3LT6c928I7hRkzbUhObeYZx1RzQI7bWf6nXyn7R/i7aQXsg6m8bd9sQzvFUd7D+n+yf/h3wXLwvO20obBJ3+si7Hj/Z6nvfE1l8fA7X0UL//lI1tZoZ5h1mWwM9YzqkcYk9W3kpPHYLJARhZkHMpojhIfbA4QDx8yEg38rG79nTmGmltBZmjeyBYhv7G/RTpD6pmNSfxsDRnqHczmcZ11fnjcTZK2W/3HPKH57VKpeUV6U9gzGg8bIvwuLZ38mAu457J3kvOUchpvbkWijzYF39DzFuLY5QT63YKvLPD+sywvL9L8CY6QutOOoz+B7knDeckkZ+4fbhDMYvyhLHG8J7NVpt/HG5x+Rt53LyF/ATmmX3KeE5afTnmnhncLsAf3SXmDfULnNAjkeafmffqXsHyxvAX1bsM33xZa82wGro7yH9bVk/1A+eCaOno8A+4fbDSRrwq7bDNmpiJ3Hm8vi4dxGwcJ/PpIZa1DaMcOsy2RfqGdHNsD+KSTIaCrIiM8JSc7/8O+Xc3sM+6hmFobi5iBMXxn7h2wBnCehuGgnSI3Bkvpb3CdB72xrWcSzri/3gv1D/0+DONPZO0ndmjT/g7bOFMZXK+OR3JnsXSPrH/lnAUbiYSa8o+cxxs1AHJ7WRAjD5zJ5fjiXeX6Z/ne2a5nEfb1YR/kcCY43KMyFZewfXt+nM35RlqhvBPRfl403KpvpFt7eXEb+AmPCLkndj+Wn055i4Z3CXA790pVg3/A1M/3/TZb/6VfK/sHyFrDlCzZ7d54l7wJgdZT3sLUNsn8oH5xvo+cbwf7hfbRt/pn6L8TO481i8bBvn2vhPx81ZqxP+ekyuRrq2U1g/0j1U3MTZDQRZERhZoKMpO7c5/0P4cBxNZV/MwuD9g+Fub2M/UO2APGNtgXaCVLzXUn7ZHD90bYnhvOs68uBYP+MhDQpziT2TnIfFeVFaZOf8msFHibBu0mAl9wp7J3kut0Uhpv8uG5HPEwBPFLtge8HtuUtIIsiyp1+pfou3Ocp0F+3V7uWgmvXEucchPgsoK5/NXLb9yeNLfFMDp8DGgXvHPJZcoyEa8gBszxm/EYMroNQuCkpwWgbv0uNDZL0LpYh9UeTLDJrSZnMJgMegT6/gHuSKX1tk/wEbNhJ7vNtz7D88oCD8sPz0BdPHwr7c4MN+3S0Oyawd5J2B+UVMR7Q7iB+JsA7eh4DGAX6u3abrUp54/1FVN+aE/jIQZg/lLHNx1hkQM9oE9r01Iac1yOe0QaRsg+pTmSi4XY2ykLaTnGYbjv2nyMSZJyDMM+XmW8r1xfjPCyObyXqj9C8bTvOZZHMCL9tHvXlMjKbnSAzrOMkKwqbhbywv8tCGPqfvufH09DhhWRUFBrDt+McCp8fpvzwPOYIU/GSZM/nY/j6D+4bxTmrCe55K6lfKD+0g7APTVPf2RatbxMgb1kTb1vjnyYr1wLaLLnI3peizbL59CHMVOZN0fDywD54Kkub4mwL76eytJPm9N3vs2kf9g3DEYyPuRaMW5fB6L5etRdkeB++5knlM9HCO4WZAPbqRPOM7WskyLFg+Z9+GebPwzPO3Qis8w6UN85x5yEfzHvdHurIrbxxTSAD+eD+33VrEdDW+H4FknWpvdq2eBNYvDYIM8/Cf94x/0lnGnHv9xSoZ1SPJOeH5yXIaBLIiMLg3D+fn6XwMyAMtafmyG4T5yBMdxndMtI5/3b9R9hGAkYKs3AD6T/3vNv132QL7xRmKdTL5aDfuB2i/9/f8j/9gv6rTP/tV0L/cT1Wqf7jZ/rTqP92hnq2P+i/iUKY5iXIaArIyHamio9nKTzqP34/IB/fom15WBnd4t7+tes/wma7w/+oDaT/pMZUSfYf8k5hVkC97AP9RmU6CeR4huV/+gX9V5n+O72E/uN6rFL9N4XFS6P+Ww317IwNYP9xHYX6bza8y5tnnP9FHU24BdYaYrQtKW3yo91K70h2qJMpHo3FUW8TT80sDM4VUJiLSujEFktcXa6bjR18tu1hwPV1nDuWuiMwad8L5YfrHbb5f1ynsa25bcj5f+LBtq8X98fOSEhrAoSh9tAclZ8Lv7ZMP+l8HdLsj8WzH/lo/f3BOQjzzjLzn3zPsG3ume+ZFZpbbLfxZlvPojA3lZG/xNy/5Lwqlp9Oe5KFdwrzPug/bgM7hMoN9dDHLP/Tr5SdguUtMJc/YKfwufw5lrzxTi9HeQ/bi0l2Cj+HiusI94GdwvtSkjWeT+R3aNjizWDxbH0w8p+PZOxiSnsOw6zL5E6oZx8DO0Wqn5qdICNc/7DdlyJlf/D+x7auwcd/fD0ax3+fLqGzcF8Q7j217UGUOo+StA8Hz6fz+4VbLDzjXhTdHkab9yMhTp69kxz/U16UNvkpP9xHkId3ecBLLt8zm7Z9vRvSHheSRbHaOUbcfyW1X3dyFXhw3C2xN0WIzwLqetf7Y7luncxk1eg9iEljJMrPR8x4xyvuF6Bwk1KC0TYWlrKzk3QYlmEL/M9l1pIymU0EPAL958Be01aWl+7fnwF7MO8+32KG5ZcHHJQfri2eOGMo7F8NNuwfsQ9vZe8k+3DKK2I8YB+eh2dy6Rn3mgr0HUWb3Ud5lzoHxvnANYQXy9i5YywyoGe0r2x6akPOkRHP2J9L2Vp5kxY95y2ykO7zHaZbxP5zRIKMcb9ys2nPSXNX5fpinNNsxPkkgTnQIs4Lkcz4t/pwXqi1jMxmJsgM6zg/15CN1j+PkTfvuQ6gvaY4F0vhRzH/UvNcqO9Xsq1QftinY3+Qpn6gLVq/f0Pe+L5JtJUE5FrA/jcX2fsF7H8nzhjCTHWH9k3mWTzsc/h9SLhvcjJLu2Fz7YXisH2jIxgftrX9qWUwuq9XxYIM78PvlON7ZpH3dfvewfaaY56xfY0GOS60/E+/DPPn4RnH9M7vHikM1nd+P8dsS944b+wo72HzsZlo+N5j3L9AzwugrfE97CRrwo73EyJ2Hq+VxcO7CGZZ+M875p/P/fJ997pM5kM9o3okOW84K0FGeZARhbHtdaewFB73jVN7ao7s9l0Owiwvo1tGO+ffrv8I22jAuO7bpxtI/7nn3a7/Jlp4pzB7Qr3cG/Rb3vzfCnI8yvI//YL+q0z/HVlC/3E9Vqn+y7N4adR/+0E9Owr0n9TeuVkJMsL9NxQG56ZwL7P+4b4RXO9p1LrddAtu2/4PfraJn1FCe5zvG8L9hBTmhBI6scUSV5fr7LbBZ9vaDq474DzAhroPBeeubHM5OOdmmz/dkHM5trtm6Bn3DU1LSKsVwvBz2KXmNc4v0086n1M2+4aor+LzCLhOTWEuLDOPMAP8+cg+j8D3EkmtDdp4s81NUpg3l5G/xDyO5LwCll8+Wr89Yt27HPqPK8EOoXKbCHK8yfI//UrZKVjeAvsUCthX8jPAmDfaE47yHtZPk53C72/Fs983gp3C99uQrEvdRWmLx+9QwztbZ1r4z0eyNgE/f63L5GqoZzeBndKoe+xQD5GMKAzO3eeF8PD+xzavR+XP11Nwvx+Fub2EzsI1XtyTw20HId1Wck11BmCkd7gHmvOM64r6P7OFetg87Uj2TtL+pbwobfLjnTB8bxPeB4j2T569S9t+J8n2kHRnQF5WFsVqx9gTAY9Af92B7bISPDjulhgrCfFZQF3vet8Q160TmawavZ8kaYxE+QXMAXMSZjxjRVhxjJ9PCUbbnIPUeCapr8AypD50pEVmjbgDpxqZTQA8EvfbaH7Hs7y0HfVzsLsF7hboyLD88oAD7xagML+dNRT21wZbK8RBW2kieyc5V4j9cT6y35NM/KD9RM+4P0vCZshE668ncb2mw/DzjJwPPM/45zLjiTEWGaD89Q/PPedBBlJtbgqTgW3+jo8xJG1aqhNkb/M5b9RTWMfz8EwYpcbFlBelnWfywf4H5+Wl7iJJamsh76E64jDvIo6X6Zdh/jw8jwc8eQFZYF9VCZ68LJ5CWzRc7pSXVHtMqgfhfvlwv3w1Py2rcFd7wGzDHO6XXx9Pkt617VmYZJHZyJTJDMdHfC51YA/BzCG8AuOmqu+B/yCM/eYbbLhPAMfxNtso756HkvWC8sNxj23sh/aSwNi+3WbDU964b4WfzeF84NmcBUb+/9/e2YXYdVVx/NzpZD5y5yPzYYhjS86dTGJMMtOZyWQmSftQEC0I9aHU+iAVNLWIfRARrAgKFYoGRYofWBFaCyK0LyL4+dSCohSlKFoRpBZfDIIo4oMIRvRMzr/zu2vWOedO2evOHZv7cvfdZ+2zPva+a6299tp7e3M/bw7F9d/gc863+8TmW3jnu9j8ikifjXmdeeaf+R7gk6xG+V4FH3vJBXl7zXjhu0Snxo+Xa0P7GDF+gvSzezaN1c88m+aeBpmdqZAZx/irufWQWQBv60H5pNsys/mk9gx65nTe1yCzqvwJ3otqcxEi41FVeuFkH3FnNbg76XFveH2al7+Fj3363j32qV33oK6vy4kRPPfqix6bX898YsE8WEMnYwQcVwHxmtpxNQd65BtxzcPG3iP9JsZw8mx3DIUyC14z6oqPKwfunJFPjCzWruw1vpaDnojxExUnoz4ZS/beC9u5mzbv3YujC4Y0BNis2pj5WQd3OllsXihwL/cgi2WHnqg9CXmFLJYd3All4Z5Z6slixaEn6ry0vEIWKw7uhLLY1m+39yCL2x16As4XrpUF75zeC81nB4DmMVNOg3trW8et9iCLVYeeqLux8wpZrDq408nixp7CtR5ksebQE3Vec14hi7ozputo7scZ03kDzWOmnAb35vY+kvUeZLHu0LPeZ1kI315pXjmANK8OAM1jppwG9+YHCtzne5DFeYee832WxXkHd0JZPFTg3uhBFhsOPRt9lsWGgzuhXd32iy70IIsLDj0X+iwL4dsrzasHkObbDyDNZw8gzcsHkOaVA0jzQfwPDsLYGDPlNLg3rxS4N3uQxaZDz2afZSF8rweaVw8gzSsHkOblA0jzxgGkeRDkXKxnaG1j9EwkPWsP7nWvpGhoG3pE41ZZvitLm68rXFvAdTG5PG70jx0v+n0xFPfaleK9l9PztB1/u6N8l9ZvLzs83VmWW4nleQfe2wIe1Q+zfGYHVnCSh/63or1YJ75Ulkm7bbdp2k0B5pLDf56Y/8uGnsuG5qJP/oXcvYix1cu4PpLt/JdvK78LGWtdlXu1tkxdpL7cMnTr9yZolL6kftgKoqdqrV74uAfo3IDKbAp15EflobKdveMuSK5d59ANG5p5po1g3gQ9kZd1t2Td/cF9cpvm3WrDc2c3zburzgrKk/O/sUoa7bmLuUPj8QYa04+rjdXI3JKL4LF4N893VL1glpBXfKos8/81DTlecJ7r04ufsx82mbgHwSZv1NhkyXqvNnnLtBtEm/wWjLML8MOjzli6VCGjRchIMDxT2+6RFTzz4vR/GjEwPNNbMHc26Jbp5Pz7+k+0TYNGwdy1T/ovPe++/jvn8C6Yt2Fc3g39Zv2Q4vn9znN9buq/3vTfu2r0n9Vjveq/RdNuEPXfOzDO7of+izp7+VKFjLhvXTCnsx3ZnjbtBE/9p//TiIFRW/qWDzTolvT+r6//RNsWaBTM+/ZJ/0XNqar8P/IumIcwLj8I/aY+XYQcH3Ge63NT//Wm/z5Wo/+sHutV/y2ZdoOo/x7GOHtkH/w/q6Oo/85AtnZfkeDr/D+7z4j+36cadEv6vaW+/rN3LFD/fXqf9F963uv9P/IumM9gXF6FflOfLkGOTzjP9bmp/3rTf1+t0X9Wj/Wq/06bdoOo/z6PcfbEPvh/VkdR//HMNZ0JK/h21n2+sujer7OReV+CZEedrHaKRVJviyd774B3H8k3a3Ri22lb9OujpYC4L597wDumLjIG2Mm65dFBWTRKH3ZQpzLPEzhp6oL2a/d870Belr17B7QnrJVV3zvAff97uXfgew12MmA/9gbHbS97zX9UQyPfJTo7ht+qewc66Xlz99GrbzoOb881yP90AI1BvLv3Diw6vAvmJ7AfP4Ufon7jWSIvOc/1qfNT2N+v93sHfgM/pWqP9f/jvQMvYJy9BD8lD6Kp6t6B45CRd+9A1Nm5i4Yee3YubdSIgeH8QjAv1+gsnjPFewe885UDdFutveU8mWcwiEbLM89M8s7Gp/+Tg6+oOaBw6d0dQ2/TmbTMz/DORd7P+6Lsmjz9Td67tFTxLvpIdixbfBzL/2iwv8nP6ijvXdJ/w65l8Z4Pwfyzwf+xPqH1ySlLno0U4ANseLypbzoOb9cb5B/gk29E+j/sv+Ldow7vghk6uyOn4bLMODTP0Z5znuvTMr9zlNnfAfq268xJuy5B3IxHJsLdZWvl/wgPz19SefbsDqz1GyRr0c47z+tiqV4M1t59GOR7rnlzHxsTKfpkFONM4yjSTr25QkY8q0YwzBuLOmfZ2h97Jk4BY+/dnTP08cz6N5UyrPJ/8rLMOIl3t01UvKHqroRToNH6Om2HZ94XUPwf5st6nls+aeoi43/CpXfbe8S9u6Ems+57ovQ9aurGssG6Lyry/2Djih7uAFns+dxx3pERYK/X+b/shZ4O6MnT07MWxGfXulTq86atbrWxrn7fE9Mx9Og357oHjWae7SZaq87E3U8aOXZFT5SfXaXD2IfS7ZOOzNoDJrNx0BNgP7fvAzpqcBX2/Z1nQ/Gu025rfmDpGAbMi/BV7y3Lk2hDGz5u6iJteNV4ow33/BGVeR9Qnp7Gdc/vsznyHJMjFXzw/MsHGvzcCUcGKjed3b2fMTKrKyJ9Ld4HnuM3ZRFt8xO+d53281CFjHnG+4dqxhDfJTqtLWZMsx/3XgbEQNcZF7J7d7yY5EcaZHayQmYc4/buuaFsd9w/L+utDvhPWS846pF+zO/sf0X4aNNpDwbJDkxl3fpf/Khs983loDnC7rcgq7q9U4J5DDEyjR3tm/Puqz5u3q023Dd33Ly7b7H2Mm/Q3kfo3aktmKsNNKYfVzfyBtPz3n0/nvpn2uFdMF+A7/U44s0aL/OQ41POc31a5neOMuf0Abkl2/19GnTmwEPcjBsnwt0Vj21l3fcEcR+Byk/iv2bXjCVrnv2v+F3dPUTjph3Xmk85/OeJ+W+6r6boky9hnD2F+cfRIJpOVchoEjISDGPCNm4n+EXA6P80kvn+3TBgvtWgW+aT8+/rP9E2DxoF8+w+6b/0vPv676jDu2C+jXH5Heg364cUz593nutzU//1pv+eq9F/Vo/1qv8mTbtB1H/fxTh7Hvovau/oqQoZjUJGNueOdzUwfmbzLfq5bnfCoVt1kh11strJF6XeFk82b5r7aQXzixqd2HbaFv367jI4wrgQYyI2ThKZj1a1Hih8jIl4sRzG3Dqmbr9jOXlZZrxAZeYNLVa86yhgNJbq7soWzMsNdjJ5TLnMG+LenTzbnTdFe/bHhjiCzaXy4giSAfP2ItYGPd7UN8cd3q41yD8ijhMZV2D/Fe/24rKC+Qvsx1/hh7Df9Py681yfOj8l+h472kq7B8DLEU3tp3APDf0W5q+r/G/4KYKTPCTrur0GXjv1BXMyBMOc4Kgc2ar7FOk7/h3j7Dr8lDyIJhvXlIyOQkaC6UBGUfFIa3/supXnRxw19NGPOFQmpVetp3h3zXrrBVF5ulX5NTxfwcYA2w7PXFcs4I+V9YzZzpm6SP+36l4y5grZ3KbJrDvPSd82l2jQ8p3Gsu4+uishPdav9nBHrCHvdY7NtfSoPKbXGvOMmCsF8dl1nlvqvCGrW711lA6eS36dAPnVzZGE7yDSTH3NNTLO8QaBRm8uHOVnV+kw9qF0+5wjs/aAyWwa9ATYz+28oQWDq7DvF8+F4l2n3db8wNIxDJgfntuBvbMsT6INbfi0qYu04VXjjTbc80dUZt5QgO3YlvN4BY11+fGWD64h3N3g5044MrBrMlV6Kk8vg55jZFZXRPpa3M+WZ7tjsf2w+Qnfu077eahCxsw9u69mDPViixl35VwxT8/bWj9zrUS/F5N8T4PMTlTILIfMJCvBMj+I9q6otzpAeUOCo13ox/zO/leEjzad9mCQ7MAU6siPyjZviL5ShN1vQVY2d4Rr24L58LkdmjV2lDfk7bcaN+9WG+YNjZt39y3WXq6bc72XfJxwaPxoA43px9WNdfPoMwPUP/MO74L5OHyvT5Rl/r+OQY5Xnef6tMzvHGXO6QNypbb72+5bPungZtw4Ee6ueGwr6z7Dh2f2qPxZ/NfserNkzXOEvPNObTubF8Y9mksO/3li/qvObOAawScxzq5i/rEQRNNShYy4j5V77CXbedNuDmXBqJ/sflPmpQjm8Qbdkt4H9fXfvOGV+u/L+6T/ovxvq/8WHN4F8zWMy69Dv1k/pHj+rPNcn5v6rzf990yN/rN6rFf9N2faDaL+exLj7Fnov2NBNC1VyGgeMhJMB3Va02H8TM+53hOV89cxdHcculUn2VEnq53N0ac/bvOG1JYxqe/X6MS207bo1+VyMsK4EGMiNk4SmX/VtE+cMREvlsOYmxc/zYPo7iWW4+3BV5l5Q3nFuxYAo7E0kjXHNX7WYCc7qWVS5g3JVtk4Qgc0CubnDXGERfzOMz+OYHOJIuNKlrcFQw95+1WD/CPiOJFjnf1XvJuxANUL5rewH7+DH6L/AuPt15zn+rTM7xxl9ndAnsIqbaU9O4u46U8kwt1lp+WnCA/306j8J/gpNt9Gsq47o8trN2raebm75D/PYn0Ce9Zf0Se/xzi7Bj8lKrZ2okJGC5CRYBi7nwuix8b6RAfjenY9xVvbEszfGtZT6vKL6SdE5elW2dtF0Kg6+gZ164oF3fKPZtDmmKmL3Ddk/UGbx8T1xWOoOwZ69T1v6iLHn40/eLlNdh8Mc6Do/8xVvIvxDrsHyuLjHqhDyze++3Z3WOn/HBb+zF8jGAbMeA2NfJfoPGb4pSwPg7eAedq6x5v65pjD23SD/A8H0Bg5R2X/Fe9ecHgXzPzyjpyOlmXGYW6FHE86z/Wp83/Y3wHzstr9fMSdg9ZEuLt0vfwf4WGeuspLyzuwgpM87DoW542k3baza0k8b2/c4T9PzH/VWW7CV/TJGzHONI4i7dR4hYy4v9Xu4S7ouTWIngVDj+gQPtoou2+Wa46CWa7RWQVv8gUYb1Jb+gkBuq3W3h4GjapjDrTluRgvfy47ahLth9Bm1NQVfI0E8VU11oXPO7eQsZWmnKsjQXRXrbUfAY3ioS7nqpV1j7k8253zXMDMQC4evmHAvLXB/s6klknp/8yW75LNEP4Z0CiYuxv8n1n8zrOd/qZ8JYNZ8BZgDzc93rw9+IK5p0H+swE0RsZo2X/Fu8cd3gVzL+zSffBvJAv6kVec5/rU+T/s74D4/rb/8wbQmQMPcXNfZyLca8Qt/0d4VD+M8vvh/whO8pCsOZ+ye2K8dkdMO2+9JdLXqLJ1wre99xnj7Ar8nyg7NVchI/o/dr7Xz1wvm4PPOZv1f7z56MMN/o98AT1vZ7t9hyDdtkZe9G79ngWN5Fc0Wp6L8TIL/8fbu9A2dZF+nXDp3fotfAV9E6BNdW3wo2cjpq6geyiI7hFDt34PgUbbH/SJbim/W2hj38VcPhv/sfg4B3+0//GfK/TjZDNEG/9vgnmswf+xPmHb8EtZHgFv7fS8XfJ4s/43eftcg/yT++T/ozGE94r4z4TDu2Aeh136Ivwb9pueP+0816fO/2F/B+jbVdo79fesg3setCbCvSvXmv4AY70qfwP+j/UbJGvRXvyWn0rabbsh045z6xmH/zwx/3buM2toLvrkKxhnT8P/ibJTMxUyYoyMc1TRMxFEj7U/ooPzartv3sYWuG/+mQb/R74A4yTWd4iMN0xm3fzq9xHQqLrDoNHyXIyXH4zdKDOOMoY246YuclxV5f/Q/xHtXv4P/R/rE0WOvyq/bQI0sh9UpzL9n4mKdw0Bxo5li49j+bkG+5s8n7X0f6bKd8lmUBaiUTA/bvB/pvA7z3afcU5ZToG3gP5e93gbMvSQtxca5D8VQGPkWGf/Fe8ecXgXzIuwS7+Ef6P/wijk+IrzXJ86/4f9HaBvV2nvbCyTuGdBayLcXbZW/o/wMA6n8h/g/7yWmKnX7rBpNwWYaYf/PDH/du5zxNBc9MmvMc5egf/Tr3iLjX1wbx3XH6Jistb/sf4YbdSIgaH/I5hrDf6PfAHaNPKp7wDdVmtvp/Bt4zZth+divNxTKhf6P8NOm2HwFTWubOxjyPBA/4dzyCHwI7oPm7rIOXFVPI6+jufLqUz/p13xrjHAyNaMVOAbBsz1Bvub3E6W/g/n9nlW76O1Vqpp5LtEJ+cdWdYtS+bfRcX7LG/qmyGHt9Ea3kL8z3J/fBTv7L/i3V7sUTATKztymirL1JX0f25znutT5/+wv6P2Zdt4n3cOF/2URLi77L/8H+HhWrfKt67swNoYhWRN2mUvSLtt1zbtGNuYcvjPs1hfY9rQXPTJDMaZxlGknZqqkNEY5CKY4Pw01/8RHfR/7PrXGH4XH65/nazRWVNZt3+g78N4j/iN0G119pbrj6/mloJGy3MxXiZa3XWUpY1Ds24YdS2nPJR1xyzsc6+u7eCZcepsHMu+r/jQBqQ8S654h/yVQw5tw3jO2GcrPS1r5PeWbLcMZhz5/Bf/MmKjFVYNAA==","debug_symbols":"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Uwk3m0q42VTCzaYSbjaVcLOphJtNJdxsKuFmUwk3m0q42VTCzaYSbjaVcLOphJtNJdxsKuFmUwk3m0q42VTCzabK3GyqzM2mytxsqszNpsob9ambudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSZm02VudlUmZtNlbnZVJmbTZW52VSFm01VuNlUhZtNVbjZVGWjPnULN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pws6kKN5uqcLOpCjebqnCzqQo3m6pys6kqN5uqcrOpKjebqm7Up27lZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmU1VuNlXlZlNVbjZV5WZTVW42VeVmUzVuNlXjZlM1bjZV42ZTtY361G3cbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqsbNpmrcbKrGzaZq3Gyqxs2matxsqs7NpurcbKrOzabq3GyqvlGfup2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZVJ2bTdW52VSdm03VudlUnZtN1bnZ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cv5VJudfZXL+VSbnX2Vy/lXeuM/fTM6/yuT8q0zOv8rk/KtMzr/K5PyrTM6/yuT8q0zOv8rk/KtMzr/K5PyrTM6/yuT8q0zOv8rk/KtMzr/K5PyrTM6/yuT8q0zOv8rk/KtMzr/K5PyrTM6/yuT8q0zOv8rk/KtMzr/K5PyrTM6/yuT8q0zOv8rk/KtMzr/K5PyrTM6/yuT8q0zOv8rk/KtMzr/K5PyrTM6/yuT8q0zOv8rk/KtMzr/K5PyrTM6/yuT8q0zOv8rk/KtMzr/K5PyrTM6/yuT8q0zOv8rk/KtMzr/K5PyrTM6/yuT8q0zOv8rk/KtMzr/K5PyrTM6/yuT8q0zOv8rk/KtMzr/K5PyrTM6/yuT8q0zOv8rk/KtMzr/K5PyrTM6/yuT8q0zOv8rk/KtMzr/K5PyrTM6/yuT8q0zOv8rk/KtMzr/K5PyrTM6/yuT8q0zOv8rk/KtMzr8q5PyrQs6/KuT8q0LOvyob9/lbyPlXhZx/Vcj5V4Wcf1XI+VeFnH9VyPlXhZx/Vcj5V4Wcf1XI+VeFnH9VyPlXhZx/Vcj5V4Wcf1XI+VeFnH9VyPlXhZx/Vcj5V4Wcf1XI+VeFnH9VyPlXhZx/Vcj5V4Wcf1XI+VeFnH9VyPlXhZx/Vcj5V4Wcf1XI+VeFnH9VyPlXhZx/Vcj5V4Wcf1XI+VeFnH9VyPlXhZx/Vcj5V4Wcf1XI+VeFnH9VyPlXhZx/Vcj5V4Wcf1XI+VeFnH9VyPlXhZx/Vcj5V4Wcf1XI+VeFnH9VyPlXhZx/Vcj5V4Wcf1XI+VeFnH9VyPlXhZx/Vcj5V4Wcf1XI+VeFnH9VyPlXhZx/Vcj5V4Wcf1XI+VeFnH9VyPlXhZx/Vcj5V4Wcf1XI+VeFnH9VyPlXhZx/Vcj5V4Wcf1XI+VeFnH9VyPlXhZx/Vcj5V4Wcf1XI+VeVnH9VyflXlZx/Vcn5V3XjPn8rOf+qkvOvKjn/qpLzryo5/6qS868qOf+qkvOvKjn/qpLzryo5/6qS868qOf+qkvOvKjn/qpLzryo5/6qS868qOf+qkvOvKjn/qpLzryo5/6qS868qOf+qkvOvKjn/qpLzryo5/6qS868qOf+qkvOvKjn/qpLzryo5/6qS868qOf+qkvOvKjn/qpLzryo5/6qS868qOf+qkvOvKjn/qpLzryo5/6qS868qOf+qkvOvKjn/qpLzryo5/6qS868qOf+qkvOvKjn/qpLzryo5/6qS868qOf+qkvOvKjn/qpLzryo5/6qS868qOf+qkvOvKjn/qpLzryo5/6qS868qOf+qkvOvKjn/qpLzryo5/6qS868qOf+qkvOvKjn/qpLzryo5/6qS868qOf+qkvOvKjn/qpLzryo5/6qS868qOf+qkvOvKjn/qpLzryo5/6qR868aOf+qkfOvGjn/qm3c528j5181cv5VI+dfNXL+VSPnXzVy/lUj5181cv5VI+dfNXL+VSPnXzVy/lUj5181cv5VI+dfNXL+VSPnXzVy/lUj5181cv5VI+dfNXL+VSPnXzVy/lUj5181cv5VI+dfNXL+VSPnXzVy/lUj5181cv5VI+dfNXL+VSPnXzVy/lUj5181cv5VI+dfNXL+VSPnXzVy/lUj5181cv5VI+dfNXL+VSPnXzVy/lUj5181cv5VI+dfNXL+VSPnXzVy/lUj5181cv5VI+dfNXL+VSPnXzVy/lUj5181cv5VI+dfNXL+VSPnXzVy/lUj5181cv5VI+dfNXL+VSPnXzVy/lUj5181cv5VI+dfNXL+VSPnXzVy/lUj5181cv5VI+dfNXL+VSPnXzVy/lUj5181cv5VI+dfNXL+VSPnXzVy/lUj5181cv5VI+dfNXL+VSPnX3Vy/lUn5191cv5VJ+df9Y37/O3k/KtOzr/q5PyrTs6/6uT8q07Ov+rk/KtOzr/q5PyrTs6/6uT8q07Ov+rk/KtOzr/q5PyrTs6/6uT8q07Ov+rk/KtOzr/q5PyrTs6/6uT8q07Ov+rk/KtOzr/q5PyrTs6/6uT8q07Ov+rk/KtOzr/q5PyrTs6/6uT8q07Ov+rk/KtOzr/q5PyrTs6/6uT8q07Ov+rk/KtOzr/q5PyrTs6/6uT8q07Ov+rk/KtOzr/q5PyrTs6/6uT8q07Ov+rk/KtOzr/q5PyrTs6/6uT8q07Ov+rk/KtOzr/q5PyrTs6/6uT8q07Ov+rk/KtOzr/q5PyrTs6/6uT8q07Ov+rk/KtOzr/q5PyrTs6/6uT8q07Ov+rk/KtOzr/q5PyrTs6/6uT8q07Ov+rk/KtOzr/q5PyrTs6/6uT8q07Ov+rk/KtOzr/q5PyrTs6/6tz8q7hx869u8VOfv7f4qc/fW/zU5+8tfurz9xY/9fl7i5/6/L3FT33+3uKnPn9v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kGX9dG25KmzEsn66tlwVNmBZP11brgobr6yfri1XhQ1X1k/XlqvCRivrp2vLVWGDlfXTteWqsLHK+unaclXYUGX9dG25Kmyksn66tlwVNlBZP11brgobp6yfri1XhQ1T1k/XlqvCRinrp2vLVWGDlPXTteWqsDHK+unaclXYEGX9dG25KmyEsn66tlwVNkBZP11brgobn6yfri1XhQ1P1k/XlqvCRifrp2vLVWGDk/XTteWqii1XhU3F1k/XlqsqtlxVEVvp2nJV2Nhz/XRtuSps8Ll+urZcFTb6XD9dW64KG36un64tV4WNP9dP15arwgag66dry1Vh49L107Xlqmyx1bsttnq3xVbvttjq3RZbvdtiq3dbbPVui63ebbHVuy22erfFVu+22OrdFlu922Krd1ts9W6Lrd5tsdW7Kba6bCvRtz/OLL+lu9C5eybdhXbmj5M2b+kutDOfSXehnflMugvtzGfSXajfPZPuQv3uiXRX4jOfSXelc/dEugv1u2fSXajfPZOu2ErXlqvi5TO/UqB1Sq8UkN3PLe7yiiPG+OG/uuN/+5Uvsv0ZkC80SXlEvsgGaES+yA5oRL7IFmhEvmIsX2QTNCJfZBc0Il9kyzQiX2P+ChqpPCBfaKbyiHyN+StoqvKIfI35K2iu8oh8jfkraLLyiHyN+StotvKIfI35K2i68oh8jfkraL7yiHyN+StowvKIfI35K2jG8oh8jfkraMryiHyN+StozvKIfI35K2jS8oh8jfkraNbyiHyN+Sto2vKIfI35K2je8oh8jfkraOLyiHyN+Sto5vKIfI35K2jq8oh8jfkraO7yiHyN+Sto8vKIfI35K2j28oh8jfkraPryiHyN+Sto/vKIfI35K2gC84h8jfkraAbziHyN+StoCvOIfI35K2gO84h8jfkraBLziHyN+StoFvOIfI35K2ga84h8jfkraB7ziHyN+StoIvOIfI35K2gm84h8jfkraCrziHyN+atuzF91W/4qQHO3R+Rry1/d/hVj+a50HmV5kNWzHOW70nl0Il9oXvG3880PCmgu9SDflfarM/mutF+dyXelfvBMvmIs35X6wTP5rnT+llD+/umS4kG+K52/Z/JdqR88k+9K/eCJfJfiIZ/JdyV/dSbflfzVmXxX8ldn8hVj+a7kr87ka8xfLcVDPpMvr7965cDrmZ45gHOL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6O796hzdvV8dqnuTA93FdZ+iu/erc3T3fvWU7uUlSPkax/tv1GV5Ts3J+Qtt/+s36pp3rLOU9551lvLetU5SvnvfOkt571xnKe+96wjlc3850HigvHevs5QXV36S8t7BzlLee9hZynsPO0t572EHKC99eyrffnWVf3S71r3fxa9S2rw3ZqiS99EDqlTq66e/KP/1rEmb99GzlPc+epby4spPUt776FnKex89S3nvo2cp7330COXbkyhUej9Q3nvjScoH73dnKe897CzlvYedpbz3sLOUF1d+kvLew45QPjwCCTX86uf/6EY5eL/LUCXvjRmq5H30gCq17fk3tF8i+eWs8T56kvLR++hZynsfPUt576NnKe999CzlxZWfpLz30SOUD/mpfGwHyntvPEt573dnKe897CzlvYedpHzyHnaW8t7DzlLee9gByv9mitgf3Sgn73cZqiReJYIqme2jS3pGffvD/ccqhefLy/JFkLi9VSQ/jppYwy9xvHQ320VP1t1sDz1Zd7Md9GTdzfbParo/tRSzHfEALc32uAO0NNu1DtDSbG85QEtxLdW09D5NT0vvvfS09H7qnJb9GUjd8i9avokjt79/uPYv38CNX2T3dmqK7N5N6cse4/Oflvy+i83eec3R3bu0Obp7RzdHd+/+5ugurvsU3b2rHKD751v57B3oHN29Wz2le43tqbuEH7dN2bvVKbJ7t6ov+4lTtXi3Okd371bn6O7d6hzdvVudo7u47lN09251gO6fu6bi3eoc3b1bPad7ef6durZP35n83DYV71anyO7dqr7sJ07V6t3qHN29W52ju3erc3T3bnWO7uK6T9Hdu9UBun/umqp3q3N09271lO5te/J1W9x+3DZV71anyO7dqr7sJ07V5t3qHN29W52ju3erc3T3bnWO7uK6T9Hdu9UBun/umpp3q3N09271+7rXX3R/aektqJ6W3leqadm9VzynZZWnlq3++6dXI91bxSmye6eoL/sJ59y9U5yju7juU3T3TnGO7t4pztHdO8U5untXOUD3zzcj3TvQGbrL5t3qOd1zeOnePuje0+NLLr28JrIH6X/SYsnmnS18ibwLhi+RN8zwJRIvEXqJvA2HL5F37PAl8uYevkR+DwBfIr8yQC9R8NsF+BL57cKpEnV5BtJz/lCiE7L7jcEU2f0WQF/2z39WkSCu+xTdvV+fo7s34XN09856ju7eLs/R3XvgAbp//rN59MZ2ju7erc7R3dvVObp7v3pO97Y9fnr7+FDvdz/9Ul5c+UnKe8+qr3xt/RlH/BDHccyvGnl/i18j74Xxa+R9M36NvMeGr1Hyfhy/Rt6749fI+3z8GvmdAH6NxGsEXyO/Z8Cvkd8z4NfI7xnwa+T3DPg18nsG+BqJ3zPg18jvGfBr5PcM+DXyewb8GonXCL5Gfs+AXyO/Z8Cvkd8z4NfI7xnwa+T3DPA1yn7PgF8jv2fAr5HfM+DXyO8Z8Gvk/dHcGuXnw6LbH4oOauT9EXyNivu6yTV6ImJyqQc1cl+HXyP3dfg1cl+HXyPxGsHXyP9+hF8j74/m1qiE8vfPlhQPauT9EX6N/O9H+DXyvx/B16j6PQN+jfyeAb9Gfs+AXyO/Z8CvkXiN4Gvk9wz4NfJ7Bvwa+T0Dfo38ngG/Rn7PMKBG34jjBbP9lWUbXjVqfs+AXyO/Z8Cvkd8z4NfI7xnwayReI/ga+T0Dfo38nmFyjfLjZ3vdDmrk9wz4NfJ7Bvwa+T0DfI263zPg18jvGfBr5PcM+DXye4Yra/TSXVz3Kbr7fcAc3b3Hn6O79+1zdPdefI7u3l/P0D1vNnrmV742+s9XvjZ6uVe+NvqiV75iLF8bfcArXxv++5UvuO99/nS4/Z/+Id+QH4GELAf5gvtN9XzBfd638tXlp+UA7sWmagPu26ZqA+7xpmoD7genaiOuzaE24D5zqjbgnnSqNiv5V21tVvK62tq4Lz7UJrovPtbGffGxNu6Lj7VxX3ysjbg2h9q4Lz7Wxn3xsTbui4+1cV98rI374kNtkvviY23cFx9r4774WBv3xcfaiGtzqI374mNt3Bcfa+O++Fgb98XH2rgvPtRG3Bcfa+O++Fgb98XH2rgvPtZGXJtDbdwXH2vjvvhYG/fFx9q4Lz7Wxn3xoTbZffGxNu6Lj7VxX3ysjfviY23EtTnUxn3xsTbui4+1cV98rI374mNt3BcfalPcFx9r4774WBv3xcfauC8+1kZcm0Nt3Bcfa2PV3+Qni/72d6gDbaz6mxPaoM+nHadNbg9tSj3Qxuo5dUYbq+fUGW2snlNntLF6f3NGG6v3N2e0sepvPs+5zOhzLmdqgz5fcqo2Vu9vzmhj1Ref0caqLz6jjbg2h9pY9cVntLHqi89oY9UXn9HGffGxNu6LD7VBn4c2VRv3xcfauC8+1sZ98bE24tocauO++FibpXzxd/7tnJ/4/NtfFJ4/faen/zPHnB8p1nCg5FIueqqSS3nuqUou5dAnKlnQZzVNUfKlzlKOXl2dpTy9ujpLuXp1dcTV+Y06Szl7dXXc2/9OHffrv1PHrAcv8dFgh/IlxffO8XOHXdaaujVTybVmdA1TMsZnipIPlDTr19WVNOvt1ZU02weoKymupJKSZvsLdSXN9iLqSprtW76n5Oc73bVmok1V0m6PU/JTydp+3uOsNW9tqpJ2e5zvKHnixFlrlttUJe32ONpKiiuppKTdHkdbSbs9jraSdnscbSXt9jjfUvJzj7PWNLyZSq41O2+qkt7jaClptsep26OVDjVvH5QM+ZHi/f//WyXN9jjqSooreUJJXdJbWWuaII3qZnunqaqb7bOmqm62J5uqutn+babqa82DpFHdbF84VXXvIWeo7v3mDNXFVZ+guvemM1T33nSG6t6bzlDde9MZqntvOkH1tWay0qjuvekM1b03naG696YzVBdXfYLq3pvOUN170xmqe286Q3XvTWeo7r3pBNXXmotMo7r3pjNU9950hurem85QXVz1Cap7bzpDde9NZ6juvekM1b03naG696YTVK/em85Q3XvTGap7bzpDde9NZ6gurvoE1b03naG696YzVPfedIbq3pvOUN170wmqN+9NZ6juvekM1b03naG6+3Vt1bM8BlJlOVLd/foM1d3DqKue20P1Ut+r3t3DzFDdPcwM1d3DzFDd79dnqC6u+gTV3a9rq35i+kp3vz5Ddb9fn6G636/PUN170+tVr5v3pjNU9950hurem85Q3XvTGaqLqz5Bde9NZ6juvekM1b03naG696YzVPfedILqwXvTGap7bzpDde9NZ6juvekp1b/xL8eYtpcer58O/Xt6vGokXiP4Gnnfi18j75Lxa+Q99ZU1eunuXfUc3b2vnqJ79M56ju7eW8/R3bvrObp7fz1Hd3Hdp+juffAc3b23naO796v6uren7imUX3R/E4c0ecSR05efbv1Llby7ZaiS98Jzq6TLFajJe+y16um9+1r19DuBterpdw1r1VO8nkvV0+9G1qqn37msVU+/y1mrnn7rs1Y9/X5oqXqK3w+tVU+/H1qrnn4/tFY9/X5orXqK13Opevr90Fr19Puhterp90Nr1dPv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eia/H1qrnn4/tFY9/X5orXr6/dBa9RSvJ089P3+/L/n90Fr19Puhterp90Nr1dPvh9aqp98PLVVP8fuhterp90Nr1dPvh9aqp98PrVVP8XouVU+/H1qrnn4/tFY9/X5orXr6/dBa9fT7oaXqmf1+aK16+v3QWvX0+6G16un3Q2vVU7yeS9XT74fWqqffD61VT78fWquefj+0Vj39fmipeha/H1qrnn4/tFY9/X5orXr6/dBa9RSv51L19Puhterp90Nr1dPvh9aqp98PrVVPvx9aqp7V74fWqqffD61VT78fWque3n+eqqcuRbp6lzhDde/lZqjuHdcM1b0vmqB68+5lhureY8xQ3TuBGar733NnqC6u+gTVvTedobr3puqqf56L0bw3naG696YzVPfedILq3XtTddU/8+C796YzVPfedIbq3pvOUF1c9Qmqe286Q3XvTdVV//wdge696QzVvTedobr3pter3jfvTWeo7r3pDNW9N52huvemM1QXV32C6t6bzlDde9MZqntvOkN1701nqO696QTVg/emM1T33nSG6t6bzlDde9MZqourPkF1701nqO696QzVvTedobr3pjNU9950gurRe9MZqntvOkN1701nqO696QzVxVWfoLr3pjNU9950hurem85Q3XvTGap7bzpB9eS96QzVvTedobr3pjNU9950huriqk9QfSm/rkos6mkpV62szVLeV1cbWcqhKmuzlI9U1mYpt6eszVKeTFkbcW0OtVnq7l1Zm6VuyJW1cV98rI1ZX/yRhtfFrC/+rE0264tPaGPWF5/Qxqwv/kiu6tmsLz6hjbg2h9qY9cUntDHri09oY9YXn9DGrC/+/HeGbNYXf9ammPXFJ7Qx64tPaGPWF5/QxqwvPqGNuDaH2pj1xSe0MeuLT2hj1hef0MZ98bE27osPtanui4+1cV98rI374mNt3BcfayOuzaE27ouPtXFffKyN++JjbdwXH2vjvvhQm+a++Fgb98XH2rgvPtbGffGxNuLaHGrjvvhYG/fFx9q4Lz7Wxn3xsTbuiw+1WWsSubI27ouPtXFffKyN++JjbcS1OdTGffGxNu6Lj7UB9zchPrXZcvikzTf+7VjSM+rSXt8wDvld1KE/n83ELW5f4th+WqNP7//qhj5V12t0qxG43/Ma3WoE7ju9Rrcagftfr9GtRuI1gq8ReD/g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ck0CT3JNAk9yTQJPck0CT3LNAb+SXJPAk1yTwJNck8CTXP/hg3zBGcA5h0MC/AEOKe0HOCSpH+CQdn6AQyI5h3MnNfwAB2f/Axzc9w9wcMg/wBnAOYfTyCEf+/7rp4/jcTJuI88bGbeRi42M28iXRsZt5DQD445G3jEybiM3GBm3kb+LjNvIsUXGHV7jermq4eWqhperGl6uani5qunlqqaXq5permp6uao5vMb1clXTy1VNL1c1vVzV9HJVm5er2rxc1eblqjYvV7UNr3G9XFWn6/GRcb1cVadL6ZFxvVxVp6vgkXG9XFWnC9iRcb1cVadrz5FxvVxVp8vGkXG9XFWnK76Rcb1cVaeLtZFxvVxVp+uskXG9XFWnS6SRcb1cVaerm5FxvVxVpwuTkXG9XFWna4qRcb1cVafLgZFxvVxVpyt5kXG9XFWni3CRcb1cVafrZ5FxrVzV7HTpKzKulauana5aRca1clXzNrzGtXJVs9O1osi4Vq5qdrrMExnXy1V1ukITGdfLVXW6uBIZ18tVdbouEhnXy1V1uqQRGdfLVXW6GhEZ18tVdbqQEBnXy1V1ugYQGdfLVXXaqh8Z18tVddp8HxnXy1V12k4fGdfLVXXaIB8Z18tVddryHhnXy1V12sQeGdfLVXntVp9eu9Wn12716bVbfXrtVp9eu9Wn12716bVbfXrtVp9eu9Wn12716bVbfXrtVp9eu9Wn12716bVbfXrtVp9eu9Wn12716bVbfXrtVp9eu9Wn12716bVbfXrtVp9eu9Wn12716bVbfXrtVp9eu9Wn12716bVbfXrtVp9eu9Wn12716bVbfXrtVp9eu9Wn12716bVbfXrtVp9eu9Wn12716bVbfXrtVp9eu9Wn12716bVbfXrtVp9eu9Wn12716bVbfXrtVp9eu9Wn12716bVbfXrtVp9eu9Wn12716bVbfXrtVp9eu9Wn12716bVbffParb557VbfvHarb1671bfb8BrXylVtXrvVN6/d6pvXbvXNa7f65rVbffParb557VbfvHarb1671Tev3eqb1271zWu3+ua1W33z2q2+ee1W37x2q29eu9U3r93qm9du9c1rt/rmtVt989qtvnntVt+8dqtvXrvVN6/d6pvXbvXNa7f65rVbffParb557VbfvHarb1671Tev3eqb1271zWu3+ua1W33z2q2+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"},{"name":"claim_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"get_token","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/+2c20/bMBTGk65ARpv0Qgu03AKM7bUd0G5v3cNeN2lvk/bS0XarxChqYWL/PBoOPnDwzoojjq1YwlLVk+Cc7+cvjnPBje/dlhc3H1/GC2idWqBOT363nlbajLlaJjl9RzhzjJw+4sT9465wmptHQticnLKswmCon2ihIb8/TKf9P/H4bDC8iieXF/FkFH+fXJ4NZndbnskgQJlirta9ax0touTqISVal5N/g2+BU/BQy+X6AtreR+vAOdh+6ebz0kPbBPdaolTQOvBg+eZTlnH/96/P5yeTwfDDYDAdzmbYYRga8Lpr79+im28xRb51Nd+ny9PT8Wg8nH68Gs8uHuRdIvKKJueItmCOHMFxLbddQHl6Mm49rSQ9H7TzMveSwhfI9osS82mPCt7DPq/6BXpQlhHPS36etqF2tkTeAvu+OxoKr4qKV4HiVYTqYIaiAf98pAu5YblIaPN50RkJ7VDDi5DgCS17ERLafF50j3zZ1se8iAieyLIXEaHN58Xb5BKipOFFieApWfaiRGgzHiPvhXZZw4sywVO27EWZ0Gb0Ihk7KxpeVAieimUvQC8tc8lB5tBB5iz4HCgxj3Yn0a5qeFEleKqWvagS2oxenAjtFQ0vVgieFctegF5a5lIGmAMl5tHu9oV2TcOLGsFTs+xFjdBm7MvHQruu4UWd4Klb9qJOaDN6kVwvr2p4sUrwrFr2AvTEvTrct8+M8rRbBYVHFF9ZjlEMDAUU43v3NRn3PL57bLx/1pDWOrsft/tH7S+wvG5WeyTyNvnzJvdJGzLXgszdJNq0KWPGx9FtrO3LD+jA+jyKz1FdqAd+wHEL7OJ6Ep7Ebs7ZblXZLkJ1GkT7Y+b2NxWepsIs9skQcZjoWzr9WtwHUfdo+Dlqj9EXeBaZl7nhWfMi0uZ/ZneYjHlr3sMyb8zD45uJc4LJZ5P4+ObJe9QRXjUUr9YUryJUBzM0DPg375zaILQZrzuPqeOb8qJJ8BgY6+d6AXppmcsZYA6UmEe7c4jPT/O82CB4Nix7gc+jaZhDB5lLDjIXHWQuO8gcZYA5UGIe7U6Xun6lvNgkeExdv/7Pi3nX3POYaw4yhxlgDpSYR/s4uTfY0vBii+DZsuwF6KVlDh1kLmaAOVBiHu3Od6G9reHFNsGzbdkL0EvLXHOQuewgc+Qgc9NB5oqDzM/92Q5z0UFmF/tGNQPMgRLzaHeTOUw7Gl7sEDw7lr0AvbTMUQaYAyXm0e689aXeY17EBE9s2QvQS8tcc5A5cpC56SBzxUHm6jOzFWYXx426g8xZGOsCJebR7ib/q9rV8GKX4Nm17AXopWUOHWSuOMjsos8lB5mbDjK72J+rz8xWmLczwCzmicHcsW++SZ7Ddtr5scBQQPEy8mxPxj2Pd34saO0hrX12P273j9pfYHnfqPZhMp/tgL9NyfzY1zIXzI89INr0RsY+s5+vUV4f6cD6PIq/+vd1oR74AcctsItz/CsZY3Z1u11luwjVeUW0P2Zu/4HCc6Awi33yCR3nJvqWTr/G82PbyBeYt3rt8flianwV49KS97DojGd47OLkEX7Cb9dnF5Np/8fwy7A/8BGa+roF/I3Rr9EyftVCnojnvYrB1GltD2nGaBlbvMyv3TJ5KoDhAYZN4N9HfkOdsdw5+GfKUHAu4IT9DjlD5BXULRA+4tebwN/EKyX+AjHF5j6OSAAA","debug_symbols":"1ZzdSpxXGEbvZY6lfPt59q+3UkoxiSmCaIimUCT33rEZjaVDyiJ5wniUjO53z4uLdbL4+B527y7ffPrj96ub97d3u/NfH3bXt28v7q9ub/afHnbbL+ufH959uLh5/Hx3f/Hxfne+ne0ub97t//18tnt/dX25O6/j89l/jq3uw8E12/PRPo8cbWpPl+7/u54Pl3LsdFdrh9Ndo/zr9G9n+63L9h1rl60+nSxb189dvHzP33utr3v723trG09wVPR/e49a6uH0qG0c2VuRvb/c7eDdNXh3C97dg3eP4N0zePfK3a0teHcJ3h30UkEvFfRSQS8V9FJBLxX0UkEvHfTSQS8d9NJBLx300kEvHfTSQS8d9NJBL2vQyxr0sga9rEEva9DLGvSyBr2sQS9r0Msa9LIFvWxBL1vQyxb0sgW9bEEvW9DLFvSyBb1sQS970Mse9LIHvexBL3vQyx70sge97EEve9DLHvRyBL0cQS9H0MsR9HIEvRxBL0fQyxH0cgS9HEEvZ9DLGfRyBr2cQS9n0MsZ9HIGvZxBL2fQyxn0cgW9XEEvV9DLFfRyBb1cQS9X0MsV9HIFvVxBL8u2JS8vycuTjxZsyWcLtpq8PPl0wZZ8vGBLPl+wJR8w2JKGlqShJWlo9OGf6NM/0cd/wPM/h4FOBwYdmHRgwQHwoMxhoNAB0QHTgUoHKGlR0qKkRUmLkjYlbUralLQpaVPSpqRNSZuSNiVtSrpS0pWSrpR0paQrJV0p6UpJV0q6UtKVkm6UdKOkGyXdKOlGSTdKulHSjZJulHSjpDsl3SnpTkl3SrpT0p2S7pR0p6Q7Jd0p6UFJD0p6UNKDkh6U9KCkByU9KOlBSQ9KelLSk5KelPSkpCclPSnpSUlPSnpS0pOSXpT0oqQXJb0o6UVJL0p6UdKLkl6U9IKktW10oNAB0QHTgUoHGh3odGDQgUkHKOlCSRdKulDShZIulDRtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UYm2shEG5loIxNtZKKNTLSRiTYy0UZm2shMG5lpIzNtZKaNzLSRmTYy00Zm2shMG5lpIzNtZKaNzLSRmTYy00Zm2shMG5lpIzNtZKaNzLSRmTYy00Zm2shMG5lpIzNtZKaNzLSRmTYy00Zm2shMG5lpIzNtZKaNzLSRmTYy00Zm2shMG5lpIzNtZKaNzLSRmTYy00bm442srTkPM33b5suxI+/ILH56fWQpvT4f7u3IYc9+OFv19d2Rqxx7LeUsh6Mu8+XRw+brtW5+vBq+is3Lq91cr3Zzv9rNa3Lzw3e0n/Ad/Qd8x6jP37H6twnsTzzdXLS9eMNufd5onNxG8+Q2Wqe2Ud9ObqNychvphDbaf/rz4uPVxZvry8dXoD/+8tPN26c3ou8/3v/14ctv9mf/Bg=="},{"name":"get_portal_address","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":32,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"tx_tree_height","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"_call_mint_on_token","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"portal_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"claim_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"selector","type":{"kind":"field"}},{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"message_leaf_index","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"5Z3djmTZbaXfpa+FwSa5f0i/ymAwkG15IMCQDEseYGD43Sc0qhOZPX26Tjc6yPxO7CuXpOPgYmWtRWYmv4j//OGf//CP//G//ucf//Qvf/7LD//w3//zh3/98z/9/q9//POfHv/pP39o/030//23f/m33//pb//FX/76+3//6w//0H73wx/+9M+P//tfv/vhX/74r3/44R/6+q//8bu/PW+/8vn+K58fv/L5+SufX7/yef+Vz8eve17br3xefuXzv/Lrq7/y66u//Ov7u588FtO+PRg+no9OP3l06Dhe9PHHeD4scvb01DG+PT11yY+e/rvs8RtkS+vHk9Km1gqfv+XvO+JDt31ft7Z1fHFU9Er36tK/Pb36WCe6V4ruv7+2J7525L22tcTXlsTX1sTXtsTX7omvPRJfeya+dqIvLdGXlujLnujLnujLnujLnujLnujLnujLnujLnujLnujLnujLkejLkejLkejLkejLkejLkejLkejLkejLkejLkejLmejLmejLmejLmejLmejLmejLmejLmejLmejLmejLlejLlejLlejLlejLlejLlejLlejLlejLlejLlehLT/SlJ/rSE33pib70RF96oi890Zee6EtP9KUn+jISfRmJvoxEX0aiLyPRl5Hoy0j0ZST6MhJ9GYm+lNYyX1wyX1wzX9wyX7xnvvjIfPGZ+eIr88U988UzHSqZDpVMh0qmQyXToZLpUMl0qGQ6VDIdKpkOlUyHaqZDNdOhmulQzXSoZjpUMx2qmQ7NvAWSzGMgybwGkvNzIFlx3GGJm32/hM317Vn721HXt0fV7Sgh+SU0v4Tll+j5JUZ+iZlfYuWX8PwSkV6i57u757u757u757u757u757u757u757u757u757t75Lt75Lt75Lt75Lt75Lt75Lt75Lt75Lt75Lt75Lt75rt75rt75rt75rt75rt75rt75rt75rt75rt75rt75bt75bt75bt75bt75bt75bt75bt75bt75bt75bvb893t+e72fHd7vrs9392e727Pd7fnu9vz3e357o58d0e+uyPf3ZHv7sh3d+S7O/LdHfnujnx3R7q7tbX8EpJfQvNLWH6Jnl9i5JeY+SVWfgnPL5Hvbsl3t+S7W/LdLfnulnx3S767Jd/dku9uyXe35Ltb892t+e7WfHdrvrs1392a727Nd7fmu1vz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"}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"TokenBridge::exit_to_l1_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::exit_to_l1_public_parameters","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"nonce","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::constructor_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"TokenBridge::get_token_abi","fields":[{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::_assert_token_is_same_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::_assert_token_is_same_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"TokenBridge::get_portal_address_public_abi","fields":[{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::claim_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::claim_private_parameters","fields":[{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::exit_to_l1_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::exit_to_l1_private_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"nonce","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::_call_mint_on_token_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::_call_mint_on_token_parameters","fields":[{"name":"amount","type":{"kind":"field"}},{"name":"secret_hash","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::claim_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::claim_public_parameters","fields":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"message_leaf_index","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::get_portal_address_abi","fields":[{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"token","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"1"}},{"name":"typ","value":{"kind":"string","value":"PublicMutable<AztecAddress, Context>"}}]}},{"name":"portal_address","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"2"}},{"name":"typ","value":{"kind":"string","value":"SharedImmutable<EthAddress, Context>"}}]}}]}]}},"file_map":{"21":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"22":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x  {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field.nr"},"29":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::embedded_curve_ops::EmbeddedCurvePoint;\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<N>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: false }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<N>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(input: [Field; N], separator: u32) -> Field {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<N>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<N>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, N> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n","path":"std/hash.nr"},"31":{"source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<N>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n","path":"std/merkle.nr"},"35":{"source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<N, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n","path":"std/option.nr"},"41":{"source":"impl<T> [T] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    // Append each element of the `other` slice to the end of `self`.\n    // This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<N>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::unsafe::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n}\n","path":"std/slice.nr"},"47":{"source":"// docs:start:token_bridge_imports\n\n// Minimal implementation of the token bridge that can move funds between L1 <> L2.\n// The bridge has a corresponding Portal contract on L1 that it is attached to\n// And corresponds to a Token on L2 that uses the `AuthWit` accounts pattern.\n// Bridge has to be set as a minter on the token before it can be used\n\ncontract TokenBridge {\n    use dep::aztec::prelude::{FunctionSelector, AztecAddress, EthAddress, PublicMutable, SharedImmutable};\n\n    use dep::token_portal_content_hash_lib::{get_mint_public_content_hash, get_mint_private_content_hash, get_withdraw_content_hash};\n\n    use dep::token::Token;\n    // docs:end:token_bridge_imports\n\n    // docs:start:token_bridge_storage_and_constructor\n    // Storage structure, containing all storage, and specifying what slots they use.\n    #[aztec(storage)]\n    struct Storage {\n        token: PublicMutable<AztecAddress>,\n        portal_address: SharedImmutable<EthAddress>,\n    }\n\n    // Constructs the contract.\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(token: AztecAddress, portal_address: EthAddress) {\n        storage.token.write(token);\n        storage.portal_address.initialize(portal_address);\n    }\n    // docs:end:token_bridge_storage_and_constructor\n\n    #[aztec(private)]\n    fn get_portal_address() -> EthAddress {\n        storage.portal_address.read_private()\n    }\n\n    #[aztec(public)]\n    fn get_portal_address_public() -> EthAddress {\n        storage.portal_address.read_public()\n    }\n\n    // docs:start:claim_public\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount publicly\n    #[aztec(public)]\n    fn claim_public(to: AztecAddress, amount: Field, secret: Field, message_leaf_index: Field) {\n        let content_hash = get_mint_public_content_hash(to, amount);\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret,\n            storage.portal_address.read_public(),\n            message_leaf_index\n        );\n\n        // Mint tokens\n        Token::at(storage.token.read()).mint_public(to, amount).call(&mut context);\n    }\n    // docs:end:claim_public\n\n    // docs:start:exit_to_l1_public\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message publicly\n    // Requires `msg.sender` to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[aztec(public)]\n    fn exit_to_l1_public(\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read_public(), content);\n\n        // Burn tokens\n        Token::at(storage.token.read()).burn_public(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    // docs:end:exit_to_l1_public\n    // docs:start:claim_private\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount in private assets\n    // User needs to call token.redeem_shield() to get the private assets\n    #[aztec(private)]\n    fn claim_private(\n        secret_hash_for_redeeming_minted_notes: Field, // secret hash used to redeem minted notes at a later time. This enables anyone to call this function and mint tokens to a user on their behalf\n        amount: Field,\n        secret_for_L1_to_L2_message_consumption: Field // secret used to consume the L1 to L2 message\n    ) {\n        // Consume L1 to L2 message and emit nullifier\n        let content_hash = get_mint_private_content_hash(secret_hash_for_redeeming_minted_notes, amount);\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret_for_L1_to_L2_message_consumption,\n            storage.portal_address.read_private()\n        );\n\n        // Mint tokens on L2\n        // `mint_private` on token is public. So we call an internal public function\n        // which then calls the public method on the token contract.\n        // Since the secret_hash is passed, no secret is leaked.\n        TokenBridge::at(context.this_address())._call_mint_on_token(amount, secret_hash_for_redeeming_minted_notes).enqueue(&mut context);\n    }\n    // docs:end:claim_private\n\n    // docs:start:exit_to_l1_private\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message privately\n    // Requires `msg.sender` (caller of the method) to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[aztec(private)]\n    fn exit_to_l1_private(\n        token: AztecAddress,\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read_private(), content);\n\n        // docs:start:call_assert_token_is_same\n        // Assert that user provided token address is same as seen in storage.\n        TokenBridge::at(context.this_address())._assert_token_is_same(token).enqueue(&mut context);\n        // docs:end:call_assert_token_is_same\n\n        // Burn tokens\n        Token::at(token).burn(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    /// docs:end:exit_to_l1_private\n\n    // docs:start:get_token\n    #[aztec(public)]\n    #[aztec(view)]\n    fn get_token() -> AztecAddress {\n        storage.token.read()\n    }\n    // docs:end:get_token\n\n    // docs:start:call_mint_on_token\n    // This is a public call as we need to read from public storage.\n    // Also, note that user hashes their secret in private and only sends the hash in public\n    // meaning only user can `redeem_shield` at a later time with their secret.\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _call_mint_on_token(amount: Field, secret_hash: Field) {\n        Token::at(storage.token.read()).mint_private(amount, secret_hash).call(&mut context);\n    }\n    // docs:end:call_mint_on_token\n\n    // docs:start:assert_token_is_same\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _assert_token_is_same(token: AztecAddress) {\n        assert(storage.token.read().eq(token), \"Token address is not the same as seen in storage\");\n    }\n    // docs:end:assert_token_is_same\n}\n","path":"/home/josh/Documents/test/token-bridge-tutorial-test/packages/aztec-contracts/token_bridge/src/main.nr"},"50":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    event_selector: Field,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let event_bytes = event_selector.to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = event_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[36 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[40 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() < ARGS_HASH_CHUNK_COUNT * ARGS_HASH_CHUNK_LENGTH);\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..800 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x05a1023fef839ac88731f49ae983e172c1b600a3c8f3393ad0ac25d819ac0f0f);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let event_selector = 5;\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x00846d6969c8c2f61d39cd2762efcb0abb14f88d59c2675910251ef2bcffe9a7);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let event_selector = 5;\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x00880a801230ea08c98a802a11b4786cba474513875f0fc69a615e81c5f9f21c);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let event_selector = 5;\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x00a78b5347813624ecfd26e5b8bc6146f418b0cfcc8296b5112d09b8ebba9496);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let event_selector = 5;\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x001f3390ea242afee7ce46dafdbdc4bd4f1cf20cd63850d12d60ff9956712c4f);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/aztec-nr/aztec/src/hash.nr"},"53":{"source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext},\n    oracle::{storage::{storage_read, storage_write}}, state_vars::storage::Storage\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like PublicImmutable but with the ability to read from private functions.\nstruct SharedImmutable<T, Context>{\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PublicContext> {\n    // Intended to be only called once. \n    pub fn initialize<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        // TODO(#4738): Uncomment the following assert\n        // assert(\n        //     self.context.public.unwrap_unchecked().is_deployment(), \"SharedImmutable can only be initialized during contract deployment\"\n        // );\n\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let fields_read: [Field; 1] = storage_read(initialization_slot);\n        assert(fields_read[0] == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        storage_write(initialization_slot, [0xdead]);\n\n        let fields_write = T::serialize(value);\n        storage_write(self.storage_slot, fields_write);\n    }\n\n    pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n}\n\nimpl<T> SharedImmutable<T, UnconstrainedContext> {\n    pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PrivateContext> {\n    pub fn read_private<T_SERIALIZED_LEN>(self) -> T  where T: Deserialize<T_SERIALIZED_LEN> {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] =\n                header.public_storage_historical_read(\n                    self.storage_slot + i as Field,\n                    (*self.context).this_address()\n                );\n        }\n        T::deserialize(fields)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr"},"65":{"source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse crate::oracle::storage::storage_write;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        let fields = T::serialize(value);\n        storage_write(self.storage_slot, fields);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UnconstrainedContext> {\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        // This looks the same as the &mut PublicContext impl, but is actually very different. In public execution the\n        // storage read oracle gets transpiled to SLOAD opcodes, whereas in unconstrained execution the PXE returns\n        // historical data.\n        let fields = storage_read(self.storage_slot);\n        T::deserialize(fields)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"68":{"source":"use dep::protocol_types::{\n    address::AztecAddress, hash::{compute_siloed_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_new_nullifier(init_nullifier, 0);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_new_nullifier(init_nullifier, 0);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_contract_initialization_nullifier(context.this_address());\n    let header = context.get_header();\n    header.prove_nullifier_inclusion(init_nullifier);\n}\n\nfn compute_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    compute_siloed_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(address)\n    )\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/aztec-nr/aztec/src/initializer.nr"},"73":{"source":"#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle<N>(_returns: [Field]) -> Field {}\n\nunconstrained pub fn pack_returns(returns: [Field]) {\n    let _unused = pack_returns_oracle(returns);\n}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<N>(_return_hash: Field) -> [Field; N] {}\n\nunconstrained pub fn unpack_returns<N>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr"},"75":{"source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"78":{"source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr"},"80":{"source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> PrivateCallStackItem {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    PrivateCallStackItem::deserialize(fields)\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr"},"81":{"source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<N>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<N>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr"},"82":{"source":"use dep::protocol_types::{\n    abis::{\n    function_selector::FunctionSelector, public_call_stack_item::PublicCallStackItem,\n    function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs,\n    call_context::CallContext, read_request::ReadRequest, note_hash::NoteHash, nullifier::Nullifier,\n    log_hash::LogHash, global_variables::GlobalVariables, gas::Gas\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    messaging::l2_to_l1_message::L2ToL1Message, header::Header, address::AztecAddress,\n    utils::reader::Reader,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n}\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\npub fn parse_public_call_stack_item_from_oracle(fields: [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH]) -> PublicCallStackItem {\n    let mut reader = Reader::new(fields);\n\n    // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n    // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n    let item = PublicCallStackItem {\n        contract_address: AztecAddress::from_field(reader.read()),\n        function_data: FunctionData { selector: FunctionSelector::from_field(reader.read()), is_private: false },\n        public_inputs: PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            new_note_hashes: [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n            new_nullifiers: [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n            new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0\n        },\n        is_execution_request: true\n    };\n    reader.finish();\n\n    item\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr"},"84":{"source":"use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, hash::pedersen_hash, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr"},"88":{"source":"use dep::protocol_types::{address::AztecAddress};\n\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: u64 = 17;\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {}\n\nunconstrained pub fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {\n    get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret)\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr"},"91":{"source":"use dep::protocol_types::traits::{Deserialize, Serialize};\n\n#[oracle(storageRead)]\nunconstrained fn storage_read_oracle<N>(_storage_slot: Field, _number_of_elements: Field) -> [Field; N] {}\n\nunconstrained fn storage_read_oracle_wrapper<N>(_storage_slot: Field) -> [Field; N] {\n    storage_read_oracle(_storage_slot, N)\n}\n\npub fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_oracle_wrapper(storage_slot)\n}\n\n#[oracle(storageWrite)]\nunconstrained fn storage_write_oracle<N>(_storage_slot: Field, _values: [Field; N]) -> [Field; N] {}\n\nunconstrained pub fn storage_write<N>(storage_slot: Field, fields: [Field; N]) {\n    let _hash = storage_write_oracle(storage_slot, fields);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/aztec-nr/aztec/src/oracle/storage.nr"},"108":{"source":"use dep::protocol_types::{abis::function_selector::FunctionSelector, address::AztecAddress, traits::Deserialize};\n\nuse crate::context::private_context::PrivateContext;\nuse crate::context::public_context::PublicContext;\nuse crate::context::gas::GasOpts;\nuse crate::context::public_context::FunctionReturns;\n\nuse crate::oracle::arguments;\n\nstruct PrivateCallInterface<T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args_hash: Field,\n}\n\nimpl<T> PrivateCallInterface<T> {\n    pub fn call<N>(self, context: &mut PrivateContext) -> T where T: Deserialize<N> {\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<N>(self, context: &mut PrivateContext) -> T where T: Deserialize<N> {\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<N>(self, context: &mut PrivateContext) -> T where T: Deserialize<N> {\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nstruct PrivateVoidCallInterface {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args_hash: Field,\n}\n\nimpl PrivateVoidCallInterface {\n    pub fn call(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nstruct PrivateStaticCallInterface<T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args_hash: Field,\n}\n\nimpl<T> PrivateStaticCallInterface<T> {\n    pub fn view<N>(self, context: &mut PrivateContext) -> T where T: Deserialize<N> {\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nstruct PrivateStaticVoidCallInterface {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args_hash: Field,\n}\n\nimpl PrivateStaticVoidCallInterface {\n    pub fn view(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nstruct PublicCallInterface<T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args: [Field],\n    gas_opts: GasOpts,\n}\n\nimpl<T> PublicCallInterface<T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<N>(self, context: &mut PublicContext) -> T where T: Deserialize<N> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<N>(self, context: &mut PublicContext) -> T where T: Deserialize<N> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<N>(self, context: &mut PublicContext) -> T where T: Deserialize<N> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nstruct PublicVoidCallInterface {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args: [Field],\n    gas_opts: GasOpts,\n}\n\nimpl PublicVoidCallInterface {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<N>(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view<N>(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call<N>(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nstruct PublicStaticCallInterface<T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args: [Field],\n    gas_opts: GasOpts,\n}\n\nimpl<T> PublicStaticCallInterface<T> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<N>(self, context: &mut PublicContext) -> T where T: Deserialize<N> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nstruct PublicStaticVoidCallInterface {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    args: [Field],\n    gas_opts: GasOpts,\n}\n\nimpl PublicStaticVoidCallInterface {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<N>(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr"},"113":{"source":"use crate::encrypted_logs::{payload::compute_encrypted_note_log};\n\nuse crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message,\n    hash::{hash_args_array, ArgsHasher, compute_unencrypted_log_hash},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    note::{note_interface::NoteInterface, utils::compute_note_hash_for_insertion},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{\n    emit_encrypted_note_log, emit_encrypted_event_log, compute_encrypted_event_log,\n    emit_contract_class_unencrypted_log_private_internal, emit_unencrypted_log_private_internal\n},\n    logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    hash::sha256_to_field,\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    grumpkin_private_key::GrumpkinPrivateKey, grumpkin_point::GrumpkinPoint, header::Header,\n    messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::{is_empty, Empty},\n    utils::arrays::find_index\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<NoteHash, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<Nullifier, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.new_nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // TODO: We might want to remove this since emitting unencrypted logs from private functions is violating privacy.\n    // --> might be a better approach to force devs to make a public function call that emits the log if needed then\n    // it would be less easy to accidentally leak information.\n    // If we decide to keep this function around would make sense to wait for traits and then merge it with emit_unencrypted_log.\n    pub fn emit_unencrypted_log<T, N, M>(\n        &mut self,\n        log: T\n    ) where T: ToBytesForUnencryptedLog<N, M> {\n        let event_selector = 5; // TODO: compute actual event selector.\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n        let log_slice = log.to_be_bytes_arr();\n        let log_hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n        // 44 = addr (32) + selector (4) + raw log len (4) + processed log len (4)\n        let len = 44 + log_slice.len().to_field();\n        let side_effect = LogHash { value: log_hash, counter, length: len };\n        self.unencrypted_logs_hashes.push(side_effect);\n        // call oracle\n        let _void = emit_unencrypted_log_private_internal(contract_address, event_selector, log, counter);\n    }\n\n    // This fn exists separately from emit_unencrypted_log because sha hashing the preimage\n    // is too large to compile (16,200 fields, 518,400 bytes) => the oracle hashes it\n    // It is ONLY used with contract_class_registerer_contract since we already assert correctness:\n    // - Contract class -> we will commit to the packed bytecode (currently a TODO)\n    // - Private function -> we provide a membership proof\n    // - Unconstrained function -> we provide a membership proof\n    // Ordinary logs are not protected by the above so this fn shouldn't be called by anything else\n    pub fn emit_contract_class_unencrypted_log<N>(&mut self, log: [Field; N]) {\n        let event_selector = 5; // TODO: compute actual event selector.\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n        let log_hash = emit_contract_class_unencrypted_log_private_internal(contract_address, event_selector, log, counter);\n        // 44 = addr (32) + selector (4) + raw log len (4) + processed log len (4)\n        let len = 44 + N * 32;\n        let side_effect = LogHash { value: log_hash, counter, length: len };\n        self.unencrypted_logs_hashes.push(side_effect);\n    }\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn encrypt_and_emit_event<N, M>(\n        &mut self,\n        randomness: Field, // Secret random value used later for masked_contract_address\n        event_type_id: Field,\n        ovpk_m: GrumpkinPoint,\n        ivpk_m: GrumpkinPoint,\n        preimage: [Field; N]\n    ) where [Field; N]: LensForEncryptedLog<N, M> {\n        let ovsk_app = self.request_ovsk_app(ovpk_m.hash());\n        let contract_address = self.this_address();\n\n        // We are currently just encrypting it unconstrained, but otherwise the same way as if it was a note.\n        let encrypted_log: [u8; M] = compute_encrypted_event_log(\n            contract_address,\n            randomness,\n            event_type_id,\n            ovsk_app,\n            ovpk_m,\n            ivpk_m,\n            preimage\n        );\n\n        self.emit_raw_event_log_with_masked_address(randomness, encrypted_log);\n    }\n\n    pub fn emit_raw_event_log_with_masked_address<M>(\n        &mut self,\n        randomness: Field,\n        encrypted_log: [u8; M]\n    ) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = encrypted_log.len() as Field + 4;\n        let log_hash = sha256_to_field(encrypted_log);\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, encrypted_log, counter);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, encrypted_log: [u8; M]) {\n        let counter = self.next_counter();\n        let len = encrypted_log.len() as Field + 4;\n        let log_hash = sha256_to_field(encrypted_log);\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, encrypted_log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, start_side_effect_counter);\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest { hash: item.hash(), caller_context, start_side_effect_counter, end_side_effect_counter }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"116":{"source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\nstruct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<N>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, N>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr"},"118":{"source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n    /**\n    * Emit a log with the given event selector and message.\n    *\n    * @param event_selector The event selector for the log.\n    * @param message The message to emit in the log.\n    */\n    pub fn emit_unencrypted_log_with_selector<T, N>(\n        &mut self,\n        event_selector: Field,\n        log: T\n    ) where T: Serialize<N> {\n        emit_unencrypted_log(event_selector, Serialize::serialize(log).as_slice());\n    }\n    // For compatibility with the selector-less API. We'll probably rename the above one.\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\n        self.emit_unencrypted_log_with_selector(/*event_selector=*/ 5, log);\n    }\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn block_number(self) -> Field {\n        block_number()\n    }\n\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        temporary_function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            temporary_function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        temporary_function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            temporary_function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_field(self.inputs.selector)\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn l2_gas_left(self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(self) -> Field {\n        da_gas_left()\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(event_selector: Field, message: [Field]) {\n    emit_unencrypted_log_opcode(event_selector, message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(amvOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(event_selector: Field, message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"125":{"source":"use crate::{\n    hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness\n};\n\nuse dep::std::merkle::compute_merkle_root;\nuse dep::protocol_types::{constants::L1_TO_L2_MSG_TREE_HEIGHT, address::{AztecAddress, EthAddress}, utils::arr_copy_slice};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_message_hash(\n        portal_contract_address,\n        chain_id,\n        storage_contract_address,\n        version,\n        content,\n        secret_hash\n    );\n\n    let returned_message = get_l1_to_l2_membership_witness(storage_contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = arr_copy_slice(returned_message, [0; L1_TO_L2_MSG_TREE_HEIGHT], 1);\n\n    // Check that the message is in the tree\n    // This is implicitly checking that the values of the message are correct\n    let root = compute_merkle_root(message_hash, leaf_index, sibling_path);\n    assert(root == l1_to_l2_root, \"Message not in state\");\n\n    compute_message_nullifier(message_hash, secret, leaf_index)\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/aztec-nr/aztec/src/messaging.nr"},"131":{"source":"use dep::std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::PrivateContext, oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::NoteInterface}\n};\n\ntrait ProveNullifierInclusion {\n    fn prove_nullifier_inclusion(header: Header, nullifier: Field);\n}\n\nimpl ProveNullifierInclusion for Header {\n    fn prove_nullifier_inclusion(self, nullifier: Field) {\n        // 1) Get the membership witness of the nullifier\n        let witness = get_nullifier_membership_witness(self.global_variables.block_number as u32, nullifier);\n\n        // 2) Check that the witness we obtained matches the nullifier\n        assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n\n        // 3) Compute the nullifier tree leaf\n        let nullifier_leaf = witness.leaf_preimage.hash();\n\n        // 4) Prove that the nullifier is in the nullifier tree\n        assert(\n            self.state.partial.nullifier_tree.root\n            == compute_merkle_root(nullifier_leaf, witness.index, witness.path), \"Proving nullifier inclusion failed\"\n        );\n        // --> Now we have traversed the trees all the way up to archive root and verified that the nullifier\n        //     was included in the nullifier tree.\n    }\n}\n\ntrait ProveNoteIsNullified {\n    fn prove_note_is_nullified<Note, N, M>(header: Header, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M>;\n}\n\nimpl ProveNoteIsNullified for Header {\n    fn prove_note_is_nullified<Note, N, M>(self, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M> {\n        let nullifier = compute_siloed_nullifier(note, context);\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr"},"132":{"source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::AztecAddress,\n    header::Header, utils::field::full_field_less_than\n};\nuse dep::std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header { \n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_value_leaf_slot = pedersen_hash(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_value_leaf_slot\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n        let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr"},"145":{"source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"149":{"source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr"},"151":{"source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    contract_class_id::ContractClassId, merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::{L2ToL1Message, ScopedL2ToL1Message},\n    recursion::verification_key::VerificationKey, traits::{Hash, is_empty},\n    utils::{uint256::U256, field::field_from_bytes_32_trunc}\n};\nuse dep::std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\npub fn compute_note_hash_nonce(first_nullifier: Field, note_hash_index: u32) -> Field {\n    pedersen_hash(\n        [\n        first_nullifier,\n        note_hash_index as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\nfn compute_unique_note_hash(nonce: Field, note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        nonce,\n        note_hash\n    ],\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH\n    )\n}\n\npub fn compute_siloed_note_hash(address: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, first_nullifier: Field, index: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(first_nullifier, index);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(address: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        address.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    dep::std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    dep::std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"154":{"source":"use crate::{\n    constants::{GENERATOR_INDEX__TX_CONTEXT, TX_CONTEXT_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    abis::gas_settings::GasSettings\n};\n\n// docs:start:tx-context\nstruct TxContext {\n    chain_id : Field,\n    version : Field,\n    gas_settings: GasSettings,\n}\n// docs:end:tx-context\n\nimpl TxContext {\n    pub fn new(chain_id: Field, version: Field, gas_settings: GasSettings) -> Self {\n        TxContext { chain_id, version, gas_settings }\n    }\n}\n\nimpl Eq for TxContext {\n    fn eq(self, other: Self) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.gas_settings.eq(other.gas_settings))\n    }\n}\n\nimpl Empty for TxContext {\n    fn empty() -> Self {\n        TxContext {\n            chain_id: 0,\n            version: 0,\n            gas_settings: GasSettings::empty(),\n        }\n    }\n}\n\nimpl Serialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn serialize(self) -> [Field; TX_CONTEXT_LENGTH] {\n        let mut fields: BoundedVec<Field, TX_CONTEXT_LENGTH> = BoundedVec::new();\n\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.extend_from_array(self.gas_settings.serialize());\n\n        assert_eq(fields.len(), TX_CONTEXT_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn deserialize(serialized: [Field; TX_CONTEXT_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let context = Self {\n            chain_id: reader.read(),\n            version: reader.read(),\n            gas_settings: reader.read_struct(GasSettings::deserialize),\n        };\n\n        reader.finish();\n        context\n    }\n}\n\nimpl Hash for TxContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__TX_CONTEXT)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context = TxContext::empty();\n    let serialized = context.serialize();\n    let deserialized = TxContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let context = TxContext::empty();\n    let hash = context.hash();\n\n    // Value from tx_context.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x17e4357684c5a4349b4587c95b0b6161dcb4a3c5b02d4eb2ecc3b02c80193261;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/transaction/tx_context.nr"},"155":{"source":"use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, STATE_REFERENCE_LENGTH, CONTENT_COMMITMENT_LENGTH},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n    total_fees: Field\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables) &\n        self.total_fees.eq(other.total_fees)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.total_fees);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n        offset = offset + GLOBAL_VARIABLES_LENGTH;\n\n        let total_fees = serialized[offset];\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n            total_fees\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n            total_fees: 0\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header = Header::empty();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header = Header::empty();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header = Header::empty();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/header.nr"},"163":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    for i in 0..dst.len() {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/utils.nr"},"167":{"source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"182":{"source":"use crate::{\n    address::{AztecAddress, EthAddress},\n    constants::{L2_TO_L1_MESSAGE_LENGTH, SCOPED_L2_TO_L1_MESSAGE_LENGTH},\n    abis::side_effect::{Ordered, Scoped}, traits::{Deserialize, Empty, Serialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\n// Note: Not to be confused with L2ToL1Msg in Solidity\nstruct L2ToL1Message {\n    recipient: EthAddress,\n    content: Field,\n    counter: u32,\n}\n\nimpl Ordered for L2ToL1Message {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Empty for L2ToL1Message {\n    fn empty() -> Self {\n        Self {\n            recipient: EthAddress::empty(),\n            content: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Eq for L2ToL1Message {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient) & (self.content == other.content) & (self.counter == other.counter)\n    }\n}\n\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\n        [self.recipient.to_field(), self.content, self.counter as Field]\n    }\n}\n\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        Self {\n            recipient: EthAddress::from_field(values[0]),\n            content: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n\nimpl L2ToL1Message {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedL2ToL1Message {\n        ScopedL2ToL1Message { message: self, contract_address }\n    }\n}\n\nstruct ScopedL2ToL1Message {\n    message: L2ToL1Message,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<L2ToL1Message> for ScopedL2ToL1Message {\n    fn inner(self) -> L2ToL1Message {\n        self.message\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedL2ToL1Message {\n    fn counter(self) -> u32 {\n        self.message.counter\n    }\n}\n\nimpl Eq for ScopedL2ToL1Message {\n    fn eq(self, other: ScopedL2ToL1Message) -> bool {\n        (self.message == other.message)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedL2ToL1Message {\n    fn empty() -> Self {\n        ScopedL2ToL1Message {\n            message: L2ToL1Message::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn serialize(self) -> [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH] {\n        array_concat(self.message.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn deserialize(values: [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            message: reader.read_struct(L2ToL1Message::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\n#[test]\nfn serialization_of_empty_l2() {\n    let item = L2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = L2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped_l2() {\n    let item = ScopedL2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedL2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr"},"187":{"source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr"},"188":{"source":"use crate::{\n    abis::{side_effect::{Ordered, OrderedValue, Readable, Scoped}, read_request::ScopedReadRequest},\n    address::AztecAddress, constants::{NULLIFIER_LENGTH, SCOPED_NULLIFIER_LENGTH},\n    hash::compute_siloed_nullifier, traits::{Empty, Hash, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct Nullifier {\n    value: Field,\n    counter: u32,\n    note_hash: Field,\n}\n\nimpl Ordered for Nullifier {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for Nullifier {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for Nullifier {\n    fn eq(self, other: Nullifier) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.note_hash == other.note_hash) \n    }\n}\n\nimpl Empty for Nullifier {\n    fn empty() -> Self {\n        Nullifier {\n            value: 0,\n            counter: 0,\n            note_hash: 0,\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_LENGTH> for Nullifier {\n    fn serialize(self) -> [Field; NULLIFIER_LENGTH] {\n        [self.value, self.counter as Field, self.note_hash]\n    }\n}\n\nimpl Deserialize<NULLIFIER_LENGTH> for Nullifier {\n    fn deserialize(values: [Field; NULLIFIER_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            note_hash: values[2],\n        }\n    }\n}\n\nimpl Readable for Nullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        // Public kernels output Nullifier instead of ScopedNullifier.\n        // The nullifier value has been siloed.\n        let siloed_request_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.value, siloed_request_value, \"Value of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl Nullifier {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNullifier {\n        ScopedNullifier { nullifier: self, contract_address }\n    }\n}\n\nstruct ScopedNullifier {\n    nullifier: Nullifier,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<Nullifier> for ScopedNullifier {\n    fn inner(self) -> Nullifier {\n        self.nullifier\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNullifier {\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNullifier {\n    fn value(self) -> Field {\n        self.nullifier.value\n    }\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl Eq for ScopedNullifier {\n    fn eq(self, other: ScopedNullifier) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedNullifier {\n    fn empty() -> Self {\n        ScopedNullifier {\n            nullifier: Nullifier::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn serialize(self) -> [Field; SCOPED_NULLIFIER_LENGTH] {\n        array_concat(self.nullifier.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn deserialize(values: [Field; SCOPED_NULLIFIER_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            nullifier: reader.read_struct(Nullifier::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.nullifier.value, read_request.value(), \"Value of the nullifier does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.nullifier.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl ScopedNullifier {\n    pub fn nullified_note_hash(self) -> Field {\n        self.nullifier.note_hash\n    }\n\n    pub fn expose_to_public(self) -> Nullifier {\n        // Hide the actual counter and note hash when exposing it to the public kernel.\n        Nullifier { value: self.nullifier.value, counter: 0, note_hash: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Nullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = Nullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier.nr"},"189":{"source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{GAS_LENGTH, FIXED_DA_GAS}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered, utils::reader::Reader,\n    abis::gas_fees::GasFees\n};\nuse dep::std::ops::{Add, Sub};\n\nstruct Gas {\n    da_gas: u32,\n    l2_gas: u32,\n}\n\nimpl Gas {\n    pub fn new(da_gas: u32, l2_gas: u32) -> Self {\n        Self { da_gas, l2_gas }\n    }\n\n    pub fn tx_overhead() -> Self {\n        Self { da_gas: FIXED_DA_GAS, l2_gas: 0 }\n    }\n\n    pub fn compute_fee(self, fees: GasFees) -> Field {\n        (self.da_gas as Field) * fees.fee_per_da_gas + (self.l2_gas as Field) * fees.fee_per_l2_gas\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.da_gas == 0) & (self.l2_gas == 0)\n    }\n\n    pub fn within(self, limits: Gas) -> bool {\n        (self.da_gas <= limits.da_gas) & (self.l2_gas <= limits.l2_gas)\n    }\n}\n\nimpl Add for Gas {\n    fn add(self, other: Gas) -> Self {\n        Gas::new(self.da_gas + other.da_gas, self.l2_gas + other.l2_gas)\n    }\n}\n\nimpl Sub for Gas {\n    fn sub(self, other: Gas) -> Self {\n        Gas::new(self.da_gas - other.da_gas, self.l2_gas - other.l2_gas)\n    }\n}\n\nimpl Serialize<GAS_LENGTH> for Gas {\n    fn serialize(self) -> [Field; GAS_LENGTH] {\n        [self.da_gas as Field, self.l2_gas as Field]\n    }\n}\n\nimpl Deserialize<GAS_LENGTH> for Gas {\n    fn deserialize(serialized: [Field; GAS_LENGTH]) -> Gas {\n        Gas::new(serialized[0] as u32, serialized[1] as u32)\n    }\n}\n\nimpl Eq for Gas {\n    fn eq(self, other : Gas) -> bool {\n        (self.da_gas == other.da_gas) & (self.l2_gas == other.l2_gas)\n    }\n}\n\nimpl Empty for Gas {\n    fn empty() -> Self {\n        Gas::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Gas::empty();\n    let serialized = item.serialize();\n    let deserialized = Gas::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas.nr"},"190":{"source":"use crate::address::AztecAddress;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Empty, Serialize, Deserialize};\nuse crate::constants::CALLER_CONTEXT_LENGTH;\nuse crate::utils::reader::Reader;\n\nstruct CallerContext {\n    msg_sender: AztecAddress,\n    storage_contract_address: AztecAddress,\n    is_static_call: bool,\n}\n\nimpl Eq for CallerContext {\n    fn eq(self, other: CallerContext) -> bool {\n        other.msg_sender.eq(self.msg_sender)\n            & other.storage_contract_address.eq(self.storage_contract_address)\n            & other.is_static_call == self.is_static_call\n    }\n}\n\nimpl Empty for CallerContext {\n    fn empty() -> Self {\n        CallerContext {\n            msg_sender: AztecAddress::zero(),\n            storage_contract_address: AztecAddress::zero(),\n            is_static_call: false,\n        }\n    }\n}\n\nimpl CallerContext {\n    pub fn is_empty(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero() & !self.is_static_call\n    }\n\n    // Different to an empty context, a hidden context won't reveal the caller's msg_sender and storage_contract_address,\n    // but will still propagate the is_static_call flag.\n    pub fn is_hidden(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero()\n    }\n}\n\nimpl Serialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn serialize(self) -> [Field; CALLER_CONTEXT_LENGTH] {\n    let mut fields: BoundedVec<Field, CALLER_CONTEXT_LENGTH> = BoundedVec::new();\n\n    fields.extend_from_array(self.msg_sender.serialize());\n    fields.extend_from_array(self.storage_contract_address.serialize());\n    fields.push(self.is_static_call as Field);\n\n    assert_eq(fields.len(), CALLER_CONTEXT_LENGTH);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn deserialize(fields: [Field; CALLER_CONTEXT_LENGTH]) -> CallerContext {\n    let mut reader = Reader::new(fields);\n\n    let item = CallerContext {\n      msg_sender: reader.read_struct(AztecAddress::deserialize),\n      storage_contract_address: reader.read_struct(AztecAddress::deserialize),\n      is_static_call: reader.read_bool(),\n    };\n    reader.finish();\n    item\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = CallerContext::empty();\n    let serialized = item.serialize();\n    let deserialized = CallerContext::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/caller_context.nr"},"191":{"source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize, Empty}\n};\n\nstruct FunctionData {\n    selector : FunctionSelector,\n    is_private : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        (self.is_private == other.is_private)\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_private as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_private: serialized[1] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nimpl Empty for FunctionData {\n    fn empty() -> Self {\n        FunctionData {\n            selector: FunctionSelector::empty(),\n            is_private: false\n        }\n    }\n\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data = FunctionData::empty();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data = FunctionData::empty();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty function data hash\" test\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr"},"194":{"source":"use dep::std::cmp::Eq;\n\nstruct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u32 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr"},"195":{"source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress}, abis::gas::Gas,\n    abis::gas_fees::GasFees,\n    constants::{\n    GAS_SETTINGS_LENGTH, DEFAULT_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_MAX_FEE_PER_GAS,\n    DEFAULT_INCLUSION_FEE\n},\n    hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    utils::reader::Reader\n};\n\nstruct GasSettings {\n    gas_limits: Gas,\n    teardown_gas_limits: Gas,\n    max_fees_per_gas: GasFees,\n    inclusion_fee: Field,\n}\n\nimpl GasSettings {\n    pub fn new(\n        gas_limits: Gas,\n        teardown_gas_limits: Gas,\n        max_fees_per_gas: GasFees,\n        inclusion_fee: Field\n    ) -> Self {\n        Self { gas_limits, teardown_gas_limits, max_fees_per_gas, inclusion_fee }\n    }\n\n    pub fn default() -> Self {\n        GasSettings::new(\n            Gas::new(DEFAULT_GAS_LIMIT, DEFAULT_GAS_LIMIT),\n            Gas::new(DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT),\n            GasFees::new(DEFAULT_MAX_FEE_PER_GAS, DEFAULT_MAX_FEE_PER_GAS),\n            DEFAULT_INCLUSION_FEE\n        )\n    }\n}\n\nimpl Eq for GasSettings {\n    fn eq(self, other: Self) -> bool {\n        (self.gas_limits == other.gas_limits) & (self.teardown_gas_limits == other.teardown_gas_limits) & (self.max_fees_per_gas == other.max_fees_per_gas) & (self.inclusion_fee == other.inclusion_fee)\n    }\n}\n\nimpl Empty for GasSettings {\n    fn empty() -> Self {\n        GasSettings::new(\n            Gas::empty(), Gas::empty(), GasFees::empty(), 0\n        )\n    }\n}\n\nimpl Serialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn serialize(self) -> [Field; GAS_SETTINGS_LENGTH] {\n        let mut serialized: BoundedVec<Field, GAS_SETTINGS_LENGTH> = BoundedVec::new();\n\n        serialized.extend_from_array(self.gas_limits.serialize());\n        serialized.extend_from_array(self.teardown_gas_limits.serialize());\n        serialized.extend_from_array(self.max_fees_per_gas.serialize());\n        serialized.push(self.inclusion_fee);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn deserialize(serialized: [Field; GAS_SETTINGS_LENGTH]) -> GasSettings {\n        let mut reader = Reader::new(serialized);\n        GasSettings::new(reader.read_struct(Gas::deserialize), reader.read_struct(Gas::deserialize), reader.read_struct(GasFees::deserialize), reader.read())\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasSettings::empty();\n    let serialized = item.serialize();\n    let deserialized = GasSettings::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_settings.nr"},"198":{"source":"use crate::abis::{function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs};\nuse crate::address::AztecAddress;\nuse crate::constants::GENERATOR_INDEX__CALL_STACK_ITEM;\nuse crate::traits::Hash;\n\nstruct PublicCallStackItem {\n    contract_address: AztecAddress,\n    public_inputs: PublicCircuitPublicInputs,\n    function_data: FunctionData,\n    // True if this call stack item represents a request to execute a function rather than a\n    // fulfilled execution. Used when enqueuing calls from private to public functions.\n    is_execution_request: bool,\n}\n\nimpl Hash for PublicCallStackItem {\n    fn hash(self) -> Field {\n        let item = if self.is_execution_request {\n            self.as_execution_request()\n        } else {\n            self\n        };\n\n        dep::std::hash::pedersen_hash_with_separator([\n            item.contract_address.to_field(),\n            item.function_data.hash(),\n            item.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl PublicCallStackItem {\n    fn as_execution_request(self) -> Self {\n        let public_inputs = self.public_inputs;\n        let mut request_public_inputs = PublicCircuitPublicInputs::empty();\n        request_public_inputs.call_context = public_inputs.call_context;\n        request_public_inputs.args_hash = public_inputs.args_hash;\n\n        let call_stack_item = PublicCallStackItem {\n            contract_address: self.contract_address,\n            function_data: self.function_data,\n            is_execution_request: true,\n            public_inputs: request_public_inputs\n        };\n        call_stack_item\n    }\n}\n\nmod tests {\n    use crate::{\n        abis::{\n        function_data::FunctionData, function_selector::FunctionSelector, note_hash::NoteHash,\n        public_circuit_public_inputs::PublicCircuitPublicInputs,\n        public_call_stack_item::PublicCallStackItem\n    },\n        address::AztecAddress, constants::GENERATOR_INDEX__CALL_STACK_ITEM, traits::Hash\n    };\n\n    #[test]\n    fn compute_call_stack_item_request_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_private: false };\n\n        let mut public_inputs = PublicCircuitPublicInputs::empty();\n        public_inputs.new_note_hashes[0] = NoteHash {\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: true, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item request hash\" test\n        let test_data_call_stack_item_request_hash = 0x2751111aa213d9d21279da53531bf90c2da272cf3f959e2a2a1dfceb487bf102;\n        assert_eq(call_stack_item.hash(), test_data_call_stack_item_request_hash);\n    }\n\n    #[test]\n    fn compute_call_stack_item_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_private: false };\n\n        let mut public_inputs = PublicCircuitPublicInputs::empty();\n        public_inputs.new_note_hashes[0] = NoteHash {\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: false, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item hash\" test\n        let test_data_call_stack_item_hash = 0x1860d00d9602966e398c6d585216baba2ffa8c5eddda5faee041136665d8482a;\n        assert_eq(call_stack_item.hash(), test_data_call_stack_item_hash);\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item.nr"},"200":{"source":"use dep::std::cmp::Eq;\nuse crate::{\n    address::{AztecAddress, EthAddress}, abis::gas_fees::GasFees,\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::reader::Reader\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : u64,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n    gas_fees : GasFees\n}\n// docs:end:global-variables\n\nimpl GlobalVariables {\n    fn is_empty(self) -> bool {\n        (self.chain_id == 0)\n            & (self.version == 0)\n            & (self.block_number == 0)\n            & (self.timestamp == 0)\n            & (self.coinbase.is_zero())\n            & (self.fee_recipient.is_zero())\n            & (self.gas_fees.is_empty())\n    }\n}\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        let mut serialized: BoundedVec<Field, GLOBAL_VARIABLES_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.chain_id);\n        serialized.push(self.version);\n        serialized.push(self.block_number);\n        serialized.push(self.timestamp as Field);\n        serialized.push(self.coinbase.to_field());\n        serialized.push(self.fee_recipient.to_field());\n        serialized.extend_from_array(self.gas_fees.serialize());\n\n        serialized.storage\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        let mut reader = Reader::new(serialized);\n        GlobalVariables {\n            chain_id: reader.read(),\n            version: reader.read(),\n            block_number: reader.read(),\n            timestamp: reader.read() as u64,\n            coinbase: EthAddress::from_field(reader.read()),\n            fee_recipient: AztecAddress::from_field(reader.read()),\n            gas_fees: reader.read_struct(GasFees::deserialize)\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient) &\n        (self.gas_fees == other.gas_fees) \n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n            gas_fees: GasFees::empty()\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars = GlobalVariables::empty();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr"},"201":{"source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::GAS_FEES_LENGTH, hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty},\n    abis::side_effect::Ordered, utils::reader::Reader\n};\n\nstruct GasFees {\n    fee_per_da_gas: Field,\n    fee_per_l2_gas: Field,\n}\n\nimpl GasFees {\n    pub fn new(fee_per_da_gas: Field, fee_per_l2_gas: Field) -> Self {\n        Self { fee_per_da_gas, fee_per_l2_gas }\n    }\n\n    pub fn default() -> Self {\n        GasFees::new(1, 1)\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.fee_per_da_gas == 0) & (self.fee_per_l2_gas == 0)\n    }\n}\n\nimpl Serialize<GAS_FEES_LENGTH> for GasFees {\n    fn serialize(self) -> [Field; GAS_FEES_LENGTH] {\n        [self.fee_per_da_gas, self.fee_per_l2_gas]\n    }\n}\n\nimpl Deserialize<GAS_FEES_LENGTH> for GasFees {\n    fn deserialize(serialized: [Field; GAS_FEES_LENGTH]) -> GasFees {\n        GasFees::new(serialized[0], serialized[1])\n    }\n}\n\nimpl Eq for GasFees {\n    fn eq(self, other : GasFees) -> bool {\n        (self.fee_per_da_gas == other.fee_per_da_gas) & (self.fee_per_l2_gas == other.fee_per_l2_gas)\n    }\n}\n\nimpl Empty for GasFees {\n    fn empty() -> Self {\n        GasFees::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasFees::empty();\n    let serialized = item.serialize();\n    let deserialized = GasFees::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_fees.nr"},"202":{"source":"use crate::utils::field::field_from_bytes;\nuse dep::std::cmp::Eq;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = dep::std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"206":{"source":"use crate::{\n    abis::{\n    call_context::CallContext, max_block_number::MaxBlockNumber, gas_settings::GasSettings,\n    validation_requests::KeyValidationRequestAndGenerator, note_hash::NoteHash, nullifier::Nullifier,\n    private_call_request::PrivateCallRequest, read_request::ReadRequest,\n    log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS, MAX_ENCRYPTED_LOGS_PER_CALL,\n    MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    transaction::tx_context::TxContext, utils::arrays::validate_array\n};\n\nstruct PrivateCircuitPublicInputsArrayLengths {\n    note_hash_read_requests: u32,\n    nullifier_read_requests: u32,\n    key_validation_requests_and_generators: u32,\n    new_note_hashes: u32,\n    new_nullifiers: u32,\n    new_l2_to_l1_msgs: u32,\n    private_call_requests: u32,\n    public_call_stack_hashes: u32,\n    note_encrypted_logs_hashes: u32,\n    encrypted_logs_hashes: u32,\n    unencrypted_logs_hashes: u32,\n}\n\nimpl PrivateCircuitPublicInputsArrayLengths {\n    pub fn new(public_inputs: PrivateCircuitPublicInputs) -> Self {\n        PrivateCircuitPublicInputsArrayLengths {\n            note_hash_read_requests: validate_array(public_inputs.note_hash_read_requests),\n            nullifier_read_requests: validate_array(public_inputs.nullifier_read_requests),\n            key_validation_requests_and_generators: validate_array(public_inputs.key_validation_requests_and_generators),\n            new_note_hashes: validate_array(public_inputs.new_note_hashes),\n            new_nullifiers: validate_array(public_inputs.new_nullifiers),\n            new_l2_to_l1_msgs: validate_array(public_inputs.new_l2_to_l1_msgs),\n            private_call_requests: validate_array(public_inputs.private_call_requests),\n            public_call_stack_hashes: validate_array(public_inputs.public_call_stack_hashes),\n            note_encrypted_logs_hashes: validate_array(public_inputs.note_encrypted_logs_hashes),\n            encrypted_logs_hashes: validate_array(public_inputs.encrypted_logs_hashes),\n            unencrypted_logs_hashes: validate_array(public_inputs.unencrypted_logs_hashes)\n        }\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    key_validation_requests_and_generators: [KeyValidationRequestAndGenerator; MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n\n    new_note_hashes: [NoteHash; MAX_NEW_NOTE_HASHES_PER_CALL],\n    new_nullifiers: [Nullifier; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_requests: [PrivateCallRequest; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    public_teardown_function_hash: Field,\n    new_l2_to_l1_msgs: [L2ToL1Message; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter : u32,\n    end_side_effect_counter : u32,\n    note_encrypted_logs_hashes: [NoteLogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n    encrypted_logs_hashes: [EncryptedLogHash; MAX_ENCRYPTED_LOGS_PER_CALL],\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // Note: The chain_id and version here are not redundant to the values in self.historical_header.global_variables because\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\n    tx_context: TxContext,\n}\n\nimpl Eq for PrivateCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.call_context.eq(other.call_context) &\n        self.args_hash.eq(other.args_hash) &\n        (self.returns_hash == other.returns_hash) &\n        (self.min_revertible_side_effect_counter == other.min_revertible_side_effect_counter) &\n        (self.is_fee_payer == other.is_fee_payer) &\n        (self.max_block_number == other.max_block_number) &\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\n        (self.key_validation_requests_and_generators == other.key_validation_requests_and_generators) &\n        (self.new_note_hashes == other.new_note_hashes) &\n        (self.new_nullifiers == other.new_nullifiers) &\n        (self.private_call_requests == other.private_call_requests) &\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\n        (self.new_l2_to_l1_msgs == other.new_l2_to_l1_msgs) &\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\n        (self.note_encrypted_logs_hashes == other.note_encrypted_logs_hashes) &\n        (self.encrypted_logs_hashes == other.encrypted_logs_hashes) &\n        (self.unencrypted_logs_hashes == other.unencrypted_logs_hashes) &\n        self.historical_header.eq(other.historical_header) &\n        self.tx_context.eq(other.tx_context)\n    }\n}\n\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n\n        fields.push(self.min_revertible_side_effect_counter as Field);\n        fields.push(if self.is_fee_payer { 1 } else { 0 } as Field);\n\n        fields.extend_from_array(self.max_block_number.serialize());\n\n        for i in 0..self.note_hash_read_requests.len() {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..self.nullifier_read_requests.len() {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..self.key_validation_requests_and_generators.len() {\n            fields.extend_from_array(self.key_validation_requests_and_generators[i].serialize());\n        }\n        for i in 0..self.new_note_hashes.len() {\n            fields.extend_from_array(self.new_note_hashes[i].serialize());\n        }\n        for i in 0..self.new_nullifiers.len() {\n            fields.extend_from_array(self.new_nullifiers[i].serialize());\n        }\n        for i in 0..self.private_call_requests.len() {\n            fields.extend_from_array(self.private_call_requests[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n        fields.push(self.public_teardown_function_hash);\n        for i in 0..self.new_l2_to_l1_msgs.len() {\n            fields.extend_from_array(self.new_l2_to_l1_msgs[i].serialize());\n        }\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n        for i in 0..self.note_encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.note_encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.unencrypted_logs_hashes.len() {\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.tx_context.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = Self {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            min_revertible_side_effect_counter: reader.read() as u32,\n            is_fee_payer: reader.read() == 1,\n            max_block_number: reader.read_struct(MaxBlockNumber::deserialize),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            key_validation_requests_and_generators: reader.read_struct_array(KeyValidationRequestAndGenerator::deserialize, [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL]),\n            new_note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL]),\n            new_nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n            private_call_requests: reader.read_struct_array(PrivateCallRequest::deserialize, [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            public_teardown_function_hash: reader.read(),\n            new_l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            note_encrypted_logs_hashes: reader.read_struct_array(NoteLogHash::deserialize, [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL]),\n            encrypted_logs_hashes: reader.read_struct_array(EncryptedLogHash::deserialize, [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL]),\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            tx_context: reader.read_struct(TxContext::deserialize),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PrivateCircuitPublicInputs {\n    fn empty() -> Self {\n        PrivateCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            key_validation_requests_and_generators: [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n            new_note_hashes: [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n            new_nullifiers: [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n            private_call_requests: [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            public_teardown_function_hash: 0,\n            new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter : 0 as u32,\n            end_side_effect_counter : 0 as u32,\n            note_encrypted_logs_hashes: [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n            encrypted_logs_hashes: [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL],\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            tx_context: TxContext::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PrivateCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PrivateCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n    // Value from private_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x1970bf189adc837d1769f9f44a8b55c97d45690e7744859b71b647e808ee8622;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr"},"215":{"source":"use dep::std::cmp::Eq;\nuse crate::{\n    constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize},\n    grumpkin_point::GrumpkinPoint\n};\n\nstruct KeyValidationRequest {\n    pk_m: GrumpkinPoint,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: GrumpkinPoint::zero(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: GrumpkinPoint::new(fields[0], fields[1]),\n            sk_app: fields[2],\n        }\n    }\n}\n\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"218":{"source":"use dep::std::cmp::Eq;\nuse crate::{\n    address::AztecAddress,\n    abis::validation_requests::{\n    key_validation_request::KeyValidationRequest,\n    scoped_key_validation_request_and_generator::ScopedKeyValidationRequestAndGenerator\n},\n    constants::KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct KeyValidationRequestAndGenerator {\n    request: KeyValidationRequest,\n    sk_app_generator: Field,\n}\n\nimpl Eq for KeyValidationRequestAndGenerator {\n    fn eq(self, other: KeyValidationRequestAndGenerator) -> bool {\n        (self.request == other.request) & (self.sk_app_generator == other.sk_app_generator)\n    }\n}\n\nimpl Empty for KeyValidationRequestAndGenerator {\n    fn empty() -> Self {\n        KeyValidationRequestAndGenerator {\n            request: KeyValidationRequest::empty(),\n            sk_app_generator: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH] {\n        array_concat(self.request.serialize(), [self.sk_app_generator])\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH]) -> Self {\n        let mut reader = Reader::new(fields);\n        let res = Self {\n            request: reader.read_struct(KeyValidationRequest::deserialize),\n            sk_app_generator: reader.read(),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl KeyValidationRequestAndGenerator {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedKeyValidationRequestAndGenerator {\n        ScopedKeyValidationRequestAndGenerator { request: self, contract_address }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = KeyValidationRequestAndGenerator::empty();\n    let serialized = item.serialize();\n    let deserialized = KeyValidationRequestAndGenerator::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request_and_generator.nr"},"220":{"source":"use crate::{\n    abis::side_effect::{Ordered, Scoped}, traits::{Empty, Serialize, Deserialize},\n    address::AztecAddress, constants::{READ_REQUEST_LENGTH, SCOPED_READ_REQUEST_LEN},\n    utils::{arrays::array_concat, reader::Reader}\n};\nuse dep::std::cmp::Eq;\n\nstruct ReadRequest {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for ReadRequest {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for ReadRequest {\n    fn eq(self, read_request: ReadRequest) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n    }\n}\n\nimpl Empty for ReadRequest {\n    fn empty() -> Self {\n        ReadRequest {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn serialize(self) -> [Field; READ_REQUEST_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn deserialize(values: [Field; READ_REQUEST_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl ReadRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedReadRequest {\n        ScopedReadRequest { read_request: self, contract_address }\n    }\n}\n\nstruct ScopedReadRequest {\n    read_request: ReadRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<ReadRequest> for ScopedReadRequest {\n    fn inner(self) -> ReadRequest {\n        self.read_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Eq for ScopedReadRequest {\n    fn eq(self, other: ScopedReadRequest) -> bool {\n        (self.read_request == other.read_request)\n        & (self.contract_address.eq(other.contract_address))\n    }\n}\n\nimpl Empty for ScopedReadRequest {\n    fn empty() -> Self {\n        ScopedReadRequest {\n            read_request: ReadRequest::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn serialize(self) -> [Field; SCOPED_READ_REQUEST_LEN] {\n        array_concat(self.read_request.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn deserialize(values: [Field; SCOPED_READ_REQUEST_LEN]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            read_request: reader.read_struct(ReadRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedReadRequest {\n    pub fn value(self) -> Field {\n        self.read_request.value\n    }\n    pub fn counter(self) -> u32 {\n        self.read_request.counter\n    }\n}\n\n#[test]\nfn serialization_of_empty_read() {\n    let item = ReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr"},"221":{"source":"use crate::{\n    abis::side_effect::{Ordered, OrderedValue, Scoped}, address::AztecAddress,\n    constants::{\n    LOG_HASH_LENGTH, NOTE_LOG_HASH_LENGTH, ENCRYPTED_LOG_HASH_LENGTH, SCOPED_LOG_HASH_LENGTH,\n    SCOPED_ENCRYPTED_LOG_HASH_LENGTH\n},\n    traits::{Empty, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct LogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n}\n\nimpl Ordered for LogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for LogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for LogHash {\n    fn eq(self, other: LogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n    }\n}\n\nimpl Empty for LogHash {\n    fn empty() -> Self {\n        LogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n        }\n    }\n}\n\nimpl Serialize<LOG_HASH_LENGTH> for LogHash {\n    fn serialize(self) -> [Field; LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length]\n    }\n}\n\nimpl Deserialize<LOG_HASH_LENGTH> for LogHash {\n    fn deserialize(values: [Field; LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n        }\n    }\n}\n\nimpl LogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedLogHash {\n        ScopedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedLogHash {\n    log_hash: LogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<LogHash> for ScopedLogHash {\n    fn inner(self) -> LogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedLogHash {\n    fn eq(self, other: ScopedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedLogHash {\n    fn empty() -> Self {\n        ScopedLogHash {\n            log_hash: LogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn serialize(self) -> [Field; SCOPED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn deserialize(values: [Field; SCOPED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(LogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct EncryptedLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    randomness: Field,\n}\n\nimpl Ordered for EncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for EncryptedLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for EncryptedLogHash {\n    fn eq(self, other: EncryptedLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.randomness == other.randomness) \n    }\n}\n\nimpl Empty for EncryptedLogHash {\n    fn empty() -> Self {\n        EncryptedLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            randomness: 0,\n        }\n    }\n}\n\nimpl Serialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn serialize(self) -> [Field; ENCRYPTED_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.randomness]\n    }\n}\n\nimpl Deserialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn deserialize(values: [Field; ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            randomness: values[3],\n        }\n    }\n}\n\nimpl EncryptedLogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedEncryptedLogHash {\n        ScopedEncryptedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedEncryptedLogHash {\n    log_hash: EncryptedLogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<EncryptedLogHash> for ScopedEncryptedLogHash {\n    fn inner(self) -> EncryptedLogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl ScopedEncryptedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the secret randomness and counter when exposing to public\n        // Expose as a LogHash rather than EncryptedLogHash to avoid bringing an unnec. 0 value around\n        // The log hash will already be silo'd when we call this\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nimpl Ordered for ScopedEncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedEncryptedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedEncryptedLogHash {\n    fn eq(self, other: ScopedEncryptedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedEncryptedLogHash {\n    fn empty() -> Self {\n        ScopedEncryptedLogHash {\n            log_hash: EncryptedLogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn serialize(self) -> [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn deserialize(values: [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(EncryptedLogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct NoteLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    note_hash_counter: u32,\n}\n\nimpl NoteLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the actual counter and note hash counter when exposing it to the public kernel.\n        // The counter is usually note_hash.counter + 1, so it can be revealing.\n        // Expose as a LogHash rather than NoteLogHash to avoid bringing an unnec. 0 value around\n        LogHash { value: self.value, counter: 0, length: self.length }\n    }\n}\n\nimpl Ordered for NoteLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for NoteLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteLogHash {\n    fn eq(self, other: NoteLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.note_hash_counter == other.note_hash_counter) \n    }\n}\n\nimpl Empty for NoteLogHash {\n    fn empty() -> Self {\n        NoteLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            note_hash_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn serialize(self) -> [Field; NOTE_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.note_hash_counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn deserialize(values: [Field; NOTE_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            note_hash_counter: values[3] as u32,\n        }\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/log_hash.nr"},"222":{"source":"use dep::std::cmp::Eq;\nuse crate::{\n    abis::{caller_context::CallerContext, side_effect::{Ordered, RangeOrdered, Scoped}},\n    address::AztecAddress, constants::{PRIVATE_CALL_REQUEST_LENGTH, SCOPED_PRIVATE_CALL_REQUEST_LENGTH},\n    traits::{Empty, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PrivateCallRequest {\n    hash: Field,\n    caller_context: CallerContext,\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n}\n\nimpl Ordered for PrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.start_side_effect_counter\n    }\n}\n\nimpl RangeOrdered for PrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.start_side_effect_counter\n    }\n    fn counter_end(self) -> u32 {\n        self.end_side_effect_counter\n    }\n}\n\nimpl Eq for PrivateCallRequest {\n    fn eq(self, other: PrivateCallRequest) -> bool {\n        (self.hash == other.hash)\n            & (self.caller_context == other.caller_context)\n            & (self.start_side_effect_counter == other.start_side_effect_counter)\n            & (self.end_side_effect_counter == other.end_side_effect_counter)\n    }\n}\n\nimpl Empty for PrivateCallRequest {\n    fn empty() -> Self {\n        PrivateCallRequest {\n            hash: 0,\n            caller_context: CallerContext::empty(),\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn serialize(self) -> [Field; PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.push(self.hash);\n        fields.extend_from_array(self.caller_context.serialize());\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        assert_eq(fields.len(), PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn deserialize(fields: [Field; PRIVATE_CALL_REQUEST_LENGTH]) -> PrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = PrivateCallRequest {\n            hash: reader.read(),\n            caller_context: reader.read_struct(CallerContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            end_side_effect_counter: reader.read_u32(),\n        };\n        reader.finish();\n        item\n    }\n}\n\nimpl PrivateCallRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedPrivateCallRequest {\n        ScopedPrivateCallRequest { call_request: self, contract_address }\n    }\n}\n\nstruct ScopedPrivateCallRequest {\n    call_request: PrivateCallRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<PrivateCallRequest> for ScopedPrivateCallRequest {\n    fn inner(self) -> PrivateCallRequest {\n        self.call_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedPrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.call_request.counter_start()\n    }\n}\n\nimpl RangeOrdered for ScopedPrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.call_request.counter_start()\n    }\n    fn counter_end(self) -> u32 {\n        self.call_request.counter_end()\n    }\n}\n\nimpl Eq for ScopedPrivateCallRequest {\n    fn eq(self, other: ScopedPrivateCallRequest) -> bool {\n        (self.call_request == other.call_request)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedPrivateCallRequest {\n    fn empty() -> Self {\n        ScopedPrivateCallRequest {\n            call_request: PrivateCallRequest::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn serialize(self) -> [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, SCOPED_PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.call_request.serialize());\n        fields.extend_from_array(self.contract_address.serialize());\n\n        assert_eq(fields.len(), SCOPED_PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn deserialize(fields: [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH]) -> ScopedPrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = ScopedPrivateCallRequest {\n            call_request: reader.read_struct(PrivateCallRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        item\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = ScopedPrivateCallRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedPrivateCallRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_request.nr"},"226":{"source":"global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable}, hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}\n};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            dep::std::hash::pedersen_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl Readable for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.nullifier, siloed_value, \"Value of the nullifier leaf does not match read request\");\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n  fn eq(self, other: Self) -> bool {\n    (self.nullifier == other.nullifier) &\n    (self.next_nullifier == other.next_nullifier) &\n    (self.next_index == other.next_index)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr"},"228":{"source":"use crate::{\n    abis::read_request::ScopedReadRequest, address::AztecAddress,\n    abis::side_effect::{Ordered, OrderedValue, Readable, Scoped},\n    constants::{NOTE_HASH_LENGTH, SCOPED_NOTE_HASH_LENGTH}, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\nuse dep::std::cmp::Eq;\n\nstruct NoteHash {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for NoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteHash {\n    fn eq(self, other: NoteHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter) \n    }\n}\n\nimpl Empty for NoteHash {\n    fn empty() -> Self {\n        NoteHash {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn serialize(self) -> [Field; NOTE_HASH_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn deserialize(values: [Field; NOTE_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl NoteHash {\n    pub fn scope(self, nullifier_counter: u32, contract_address: AztecAddress) -> ScopedNoteHash {\n        ScopedNoteHash { note_hash: self, nullifier_counter, contract_address }\n    }\n}\n\nstruct ScopedNoteHash {\n    note_hash: NoteHash,\n    nullifier_counter: u32,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<NoteHash> for ScopedNoteHash {\n    fn inner(self) -> NoteHash {\n        self.note_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNoteHash {\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNoteHash {\n    fn value(self) -> Field {\n        self.note_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl Eq for ScopedNoteHash {\n    fn eq(self, other: ScopedNoteHash) -> bool {\n        (self.note_hash == other.note_hash)\n            & (self.nullifier_counter == other.nullifier_counter)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedNoteHash {\n    fn empty() -> Self {\n        ScopedNoteHash {\n            note_hash: NoteHash::empty(),\n            nullifier_counter: 0,\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn serialize(self) -> [Field; SCOPED_NOTE_HASH_LENGTH] {\n        array_concat(self.note_hash.serialize(), [self.nullifier_counter as Field, self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn deserialize(values: [Field; SCOPED_NOTE_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            note_hash: reader.read_struct(NoteHash::deserialize),\n            nullifier_counter: reader.read_u32(),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNoteHash {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.note_hash.value, read_request.value(), \"Value of the note hash does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the note hash does not match read request\");\n        assert(\n            read_request.counter() > self.note_hash.counter, \"Read request counter must be greater than the counter of the note hash\"\n        );\n        assert(\n            (self.nullifier_counter == 0) | (read_request.counter() < self.nullifier_counter), \"Read request counter must be less than the nullifier counter of the note hash\"\n        );\n    }\n}\n\nimpl ScopedNoteHash {\n    pub fn expose_to_public(self) -> NoteHash {\n        // Hide the actual counter when exposing it to the public kernel.\n        NoteHash { value: self.note_hash.value, counter: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = NoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/note_hash.nr"},"229":{"source":"use crate::{\n    abis::{\n    call_context::CallContext, note_hash::NoteHash, nullifier::Nullifier, read_request::ReadRequest,\n    gas::Gas, global_variables::GlobalVariables, log_hash::LogHash\n},\n    address::AztecAddress,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL, MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH, MAX_UNENCRYPTED_LOGS_PER_CALL\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::pedersen_hash, header::Header, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Hash, Serialize, Deserialize, Empty}, utils::reader::Reader\n};\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    nullifier_non_existent_read_requests: [ReadRequest; MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n    l1_to_l2_msg_read_requests: [ReadRequest; MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n    contract_storage_update_requests: [StorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_reads: [StorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n\n    // todo: add sideeffect ranges for the input to these hashes\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_note_hashes: [NoteHash; MAX_NEW_NOTE_HASHES_PER_CALL],\n    new_nullifiers: [Nullifier; MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [L2ToL1Message; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n\n    // Global variables injected into this circuit\n    global_variables: GlobalVariables,\n\n    prover_address: AztecAddress,\n\n    revert_code: u8,\n    \n    start_gas_left: Gas,\n    end_gas_left: Gas,\n    transaction_fee: Field,\n}\n\nimpl Eq for PublicCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Serialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        for i in 0..MAX_NOTE_HASH_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.nullifier_non_existent_read_requests[i].serialize());\n        }\n        for i in 0..MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.l1_to_l2_msg_read_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_reads[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n\n        for i in 0..MAX_NEW_NOTE_HASHES_PER_CALL {\n            fields.extend_from_array(self.new_note_hashes[i].serialize());\n        }\n        for i in 0..MAX_NEW_NULLIFIERS_PER_CALL {\n            fields.extend_from_array(self.new_nullifiers[i].serialize());\n        }\n        for i in 0..MAX_NEW_L2_TO_L1_MSGS_PER_CALL {\n            fields.extend_from_array(self.new_l2_to_l1_msgs[i].serialize());\n        }\n\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        for i in 0..MAX_UNENCRYPTED_LOGS_PER_CALL{\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.prover_address.to_field());\n        fields.push(self.revert_code as Field);\n        fields.extend_from_array(self.start_gas_left.serialize());\n        fields.extend_from_array(self.end_gas_left.serialize());\n        fields.push(self.transaction_fee);\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            nullifier_non_existent_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL]),\n            l1_to_l2_msg_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL]),\n            contract_storage_update_requests: reader.read_struct_array(StorageUpdateRequest::deserialize, [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL]),\n            contract_storage_reads: reader.read_struct_array(StorageRead::deserialize, [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            new_note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL]),\n            new_nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n            new_l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            global_variables: reader.read_struct(GlobalVariables::deserialize),\n            prover_address: reader.read_struct(AztecAddress::deserialize),\n            revert_code: reader.read() as u8,\n            start_gas_left: reader.read_struct(Gas::deserialize),\n            end_gas_left: reader.read_struct(Gas::deserialize),\n            transaction_fee: reader.read(),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PublicCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PublicCircuitPublicInputs {\n    fn empty() -> Self {\n        PublicCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            new_note_hashes: [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n            new_nullifiers: [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n            new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter: 0 as u32,\n            end_side_effect_counter: 0 as u32,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0 as u8,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0,\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PublicCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PublicCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PublicCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n\n    // Value from public_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x01681b19fb7fe21aa9c2cf9fb47520149f46edd679b2e7c2b2c4a279fd685125;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_circuit_public_inputs.nr"},"235":{"source":"use crate::{\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\nstruct PrivateCallStackItem {\n    // This is the _actual_ contract address relating to where this function's code resides in the\n    // contract tree. Regardless of whether this is a call or delegatecall, this\n    // `contract_address` _does not change_. Amongst other things, it's used as a lookup for\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\n    contract_address: AztecAddress,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n}\n\nimpl Eq for PrivateCallStackItem {\n    fn eq(self, other: Self) -> bool {\n        self.contract_address.eq(other.contract_address) &\n        self.function_data.eq(other.function_data) &\n        self.public_inputs.eq(other.public_inputs)\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.extend_from_array(self.public_inputs.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let item = Self {\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\n        };\n\n        reader.finish();\n        item\n    }\n}\n\nimpl Hash for PrivateCallStackItem {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PrivateCallStackItem {\n    fn empty() -> Self {\n        PrivateCallStackItem {\n            contract_address: AztecAddress::empty(),\n            function_data: FunctionData::empty(),\n            public_inputs: PrivateCircuitPublicInputs::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = PrivateCallStackItem::empty();\n    let serialized = item.serialize();\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let mut item = PrivateCallStackItem::empty();\n    item.function_data.is_private = true;\n    let hash = item.hash();\n\n    // Value from private_call_stack_item.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x22786e4f971661d2e49095e6b038e5170bc47b795253916d5657c4bdd1df50bf;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr"},"236":{"source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    abis::{gas_settings::GasSettings, gas::Gas}, utils::reader::Reader\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n\n    side_effect_counter : u32,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn assert_is_zero(self) {\n        let serialized: [Field; CALL_CONTEXT_LENGTH] = self.serialize();\n\n        for i in 0..CALL_CONTEXT_LENGTH {\n            assert(serialized[i] == 0);\n        }\n    }\n}\n\nimpl Eq for CallContext {\n    fn eq(self, other: CallContext) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.msg_sender.to_field());\n        serialized.push(self.storage_contract_address.to_field());\n        serialized.push(self.function_selector.to_field());\n        serialized.push(self.is_delegate_call as Field);\n        serialized.push(self.is_static_call as Field);\n        serialized.push(self.side_effect_counter as Field);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        let mut reader = Reader::new(serialized);\n        CallContext {\n            msg_sender: AztecAddress::from_field(reader.read()),\n            storage_contract_address: AztecAddress::from_field(reader.read()),\n            function_selector: FunctionSelector::from_field(reader.read()),\n            is_delegate_call: reader.read() as bool,\n            is_static_call: reader.read() as bool,\n            side_effect_counter: reader.read() as u32,\n        }\n    }\n}\n\nimpl Empty for CallContext {\n    fn empty() -> Self {\n        CallContext {\n            msg_sender: AztecAddress::empty(),\n            storage_contract_address: AztecAddress::empty(),\n            function_selector: FunctionSelector::empty(),\n            is_delegate_call: false,\n            is_static_call: false,\n            side_effect_counter: 0,\n        }\n    }\n}\n\n#[test]\nfn serialize_deserialize_of_empty() {\n    let context = CallContext::empty();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn assert_is_zero() {\n    let context = CallContext::empty();\n    context.assert_is_zero();\n}\n\n#[test(should_fail)]\nfn not_zero_assert_is_zero() {\n    let mut context = CallContext::empty();\n    context.is_delegate_call = true;\n    context.assert_is_zero();\n}\n\n#[test]\nfn test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = true;\n\n    let address: AztecAddress = AztecAddress::from_field(69420);\n    context1.msg_sender = address;\n    context2.msg_sender = address;\n\n    assert(context1.eq(context2));\n}\n\n#[test(should_fail)]\nfn not_eq_test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = false;\n\n    let address1: AztecAddress = AztecAddress::from_field(69420);\n    let address2: AztecAddress = AztecAddress::from_field(42069);\n\n    context1.msg_sender = address1;\n    context2.msg_sender = address2;\n\n    assert(context1.eq(context2));\n}\n\n#[test]\nfn hash_smoke() {\n    let context = CallContext::empty();\n    let _hashed = context.hash();\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr"},"241":{"source":"use crate::{\n    constants::CONTENT_COMMITMENT_LENGTH, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct ContentCommitment {\n  tx_tree_height: Field,\n  txs_effects_hash: Field,\n  in_hash: Field,\n  out_hash: Field,\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.push(self.tx_tree_height);\n    fields.push(self.txs_effects_hash);\n    fields.push(self.in_hash);\n    fields.push(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let tx_tree_height = serialized[0];\n\n    let txs_effects_hash = serialized[1];\n\n    let in_hash = serialized[2];\n\n    let out_hash = serialized[3];\n\n    Self {\n      tx_tree_height,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      tx_tree_height: 0,\n      txs_effects_hash: 0,\n      in_hash: 0,\n      out_hash: 0,\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.tx_tree_height == other.tx_tree_height)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr"},"244":{"source":"use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state = StateReference::empty();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr"},"245":{"source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"253":{"source":"struct Reader<N> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"254":{"source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            dep::std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr"},"266":{"source":"use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial = PartialStateReference::empty();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr"},"267":{"source":"// docs:start:token_all\n// docs:start:imports\nmod types;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n\ncontract Token {\n    // Libs\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        hash::compute_secret_hash,\n        prelude::{NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress},\n        encrypted_logs::encrypted_note_emission::{encode_and_encrypt, encode_and_encrypt_with_keys}\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::{auth::{assert_current_call_valid_authwit, assert_current_call_valid_authwit_public}};\n    // docs:end:import_authwit\n\n    use crate::types::{transparent_note::TransparentNote, token_note::{TokenNote, TOKEN_NOTE_LEN}, balances_map::BalancesMap};\n    // docs:end::imports\n\n    // docs:start:storage_struct\n    #[aztec(storage)]\n    struct Storage {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool>>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: BalancesMap<TokenNote>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128>>,\n        symbol: SharedImmutable<FieldCompressedString>,\n        name: SharedImmutable<FieldCompressedString>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[aztec(public)]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n\n    // docs:start:admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[aztec(public)]\n    #[aztec(view)]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[aztec(public)]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_public\n    #[aztec(public)]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n\n    // docs:start:mint_private\n    #[aztec(public)]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[aztec(private)]\n    fn privately_mint_private_note(amount: Field) {\n        let caller = context.msg_sender();\n        storage.balances.add(caller, U128::from_integer(amount)).emit(encode_and_encrypt(&mut context, caller, caller));\n\n        Token::at(context.this_address()).assert_minter_and_mint(context.msg_sender(), amount).enqueue(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n\n    // docs:start:shield\n    #[aztec(public)]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n\n    // docs:start:transfer_public\n    #[aztec(public)]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n\n    // docs:start:burn_public\n    #[aztec(public)]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:redeem_shield\n    #[aztec(private)]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let pending_shields = storage.pending_shields;\n        let secret_hash = compute_secret_hash(secret);\n        // Get 1 note (set_limit(1)) which has amount stored in field with index 0 (select(0, amount)) and secret_hash\n        // stored in field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options.select(TransparentNote::properties().amount, amount, Option::none()).select(\n            TransparentNote::properties().secret_hash,\n            secret_hash,\n            Option::none()\n        ).set_limit(1);\n        let notes = pending_shields.get_notes(options);\n        let note = notes[0].unwrap_unchecked();\n        // Remove the note from the pending shields set\n        pending_shields.remove(note);\n\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        let from = context.msg_sender();\n        storage.balances.add(to, U128::from_integer(amount)).emit(encode_and_encrypt(&mut context, from, to));\n    }\n    // docs:end:redeem_shield\n\n    // docs:start:unshield\n    #[aztec(private)]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount)).emit(encode_and_encrypt(&mut context, from, from));\n\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n\n    // docs:start:transfer\n    #[aztec(private)]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        // By fetching the keys here, we can avoid doing an extra read from the storage, since from_ovpk would\n        // be needed twice.\n        let header = context.get_header();\n        let from_ovpk = header.get_ovpk_m(&mut context, from);\n        let from_ivpk = header.get_ivpk_m(&mut context, from);\n        let to_ivpk = header.get_ivpk_m(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        storage.balances.sub(from, amount).emit(encode_and_encrypt_with_keys(&mut context, from_ovpk, from_ivpk));\n        storage.balances.add(to, amount).emit(encode_and_encrypt_with_keys(&mut context, from_ovpk, to_ivpk));\n    }\n    // docs:end:transfer\n\n    #[aztec(private)]\n    fn transfer_from(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        // By fetching the keys here, we can avoid doing an extra read from the storage, since from_ovpk would\n        // be needed twice.\n        let header = context.get_header();\n        let from_ovpk = header.get_ovpk_m(&mut context, from);\n        let from_ivpk = header.get_ivpk_m(&mut context, from);\n        let to_ivpk = header.get_ivpk_m(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.sub(from, amount).emit(encode_and_encrypt_with_keys(&mut context, from_ovpk, from_ivpk));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.add(to, amount).emit(encode_and_encrypt_with_keys(&mut context, from_ovpk, to_ivpk));\n    }\n\n    // docs:start:burn\n    #[aztec(private)]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount)).emit(encode_and_encrypt(&mut context, from, from));\n\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n\n    /// Internal ///\n\n    // docs:start:increase_public_balance\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n\n    // docs:start:reduce_total_supply\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n\n    // docs:start:balance_of_private\n    unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.balance_of(owner).to_field()\n    }\n    // docs:end:balance_of_private\n}\n// docs:end:token_all","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-contracts/contracts/token_contract/src/main.nr"},"283":{"source":"// docs:start:mint_public_content_hash_nr\nuse dep::aztec::prelude::{AztecAddress, EthAddress};\nuse dep::aztec::protocol_types::hash::sha256_to_field;\n\n// Computes a content hash of a deposit/mint_public message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_public_content_hash(owner: AztecAddress, amount: Field) -> Field {\n    let mut hash_bytes = [0; 68];\n    let recipient_bytes = owner.to_field().to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0x3e87b9be keccak256('mint_public(bytes32,uint256)')\n    hash_bytes[0] = 0x3e;\n    hash_bytes[1] = 0x87;\n    hash_bytes[2] = 0xb9;\n    hash_bytes[3] = 0xbe;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:mint_public_content_hash_nr\n\n// docs:start:get_mint_private_content_hash\n// Computes a content hash of a deposit/mint_private message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_private_content_hash(\n    secret_hash_for_redeeming_minted_notes: Field,\n    amount: Field\n) -> Field {\n    let mut hash_bytes = [0; 68];\n    let secret_hash_bytes = secret_hash_for_redeeming_minted_notes.to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = secret_hash_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0xefa012c1 keccak256('mint_private(bytes32,uint256)')\n    hash_bytes[0] = 0xef;\n    hash_bytes[1] = 0xa0;\n    hash_bytes[2] = 0x12;\n    hash_bytes[3] = 0xc1;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_mint_private_content_hash\n\n// docs:start:get_withdraw_content_hash\n// Computes a content hash of a withdraw message.\npub fn get_withdraw_content_hash(recipient: EthAddress, amount: Field, caller_on_l1: EthAddress) -> Field {\n    // Compute the content hash\n    // Compute sha256(selector || amount || recipient)\n    // then convert to a single field element\n    // add that to the l2 to l1 messages\n    let mut hash_bytes: [u8; 100] = [0; 100];\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n    let caller_on_l1_bytes = caller_on_l1.to_field().to_be_bytes(32);\n\n    //  0x69328dec, selector for \"withdraw(address,uint256,address)\"\n    hash_bytes[0] = 0x69;\n    hash_bytes[1] = 0x32;\n    hash_bytes[2] = 0x8d;\n    hash_bytes[3] = 0xec;\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n        hash_bytes[i + 68] = caller_on_l1_bytes[i];\n    }\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_withdraw_content_hash\n","path":"/home/josh/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.43.0/noir-projects/noir-contracts/contracts/token_portal_content_hash_lib/src/lib.nr"}}}