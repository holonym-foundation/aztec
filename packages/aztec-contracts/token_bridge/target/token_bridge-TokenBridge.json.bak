{"noir_version":"0.31.0+10076d9663dcf40ac712df69e3a71a1bb54866e2","name":"TokenBridge","functions":[{"name":"_call_mint_on_token","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_hash","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/+2dy28cSR3Hex62xxnPeMav+BHbPXbiR5Jl5+VHtBLKgvbABSS4cB3HY4iUXa8cZ3cRF85InOHP4bBc4II4cIYbe0ACLYJbINXTP/s7P/+6U5PUr3ZapCVrqttV9fvUt6urqrt/XZULBlvh1V8uDk/Ev8Xg5kZxHse/zbfbWg7zampy5jLCmc8IZ0GDMweVtsjgjTCF4OZ2ixXQbL+GnZX498OLi97PwqefnPa/CM9fXIbnZ+HJ+YtPTp9jwpf563Aj/u1dXvY//vQyvDwPn784ubzoPbkMP396+dPw/LP+xdmz888xg0LhLTOYLrwh+jIkvHPTcu/0NNnol29q9PdvmvBvb0H7NaSdj3+/l25ut2iV5KoS/TiOX4I8wsBRjT9udichc95KmyqYi/939fvqrxz/D8HMMVIjB8cozzwco16hEB+bevU3HR+rmzRY2NhEyXXZX7Uc5dg2bjm2HzIOs1UhXR7+lx8DxrzASOfFNFC1ONz77OMffPrk/LT/4enpRf/5UB29Oo9w7GVwc7PNb2qE/JZ5ft9/8ezZ07On/YuPvnj6/HIo37yQL54HLAty5AWOl3HaAuTzOA43326LenyyXWSMaI86kNCd7bNyMNx2cL3IHm23gGfaPU9LqZxNk2/Z+bnr9o1WM0yrEtOqCnGQYUZBvxzYpbxpf0aw7U6LwzNju2KhRUXgqXjWoiLYdqfFUTcXl/V1WlQFnqpnLaqCbXdatJvG9qyFFrMCz6xnLWYF2w6vkUfGds1Ci5rAU/OsRU2w7VCLqO2sW2hRF3jqnrUge6Myz2aQuZJB5nHQucTCbmwfRrbnLLSYE3jmPGsxJ9h2qMUTY3veQot5gWfesxZkb1Tm2TFgLrGwG9tHPWN7wUKLBYFnwbMWC4Jth3X5wNhetNBiUeBZ9KzFomDboRbReHnJQoslgWfJsxZkz9yr0337z1V5Ws0y4zFbju2HECaGMoTx3v12HH4cuLvHxvNzG2wtO9djcH54faH9ZV3bZybfVYUymXzX3Ocb3X/Ro+uJOO81Qav1OOzwDVQLbefiP7JDx4sQ/gLiUjzSg9oDYjfjVHqWv56Sbomlq0KcFUi3xtLRPp1ro90ncVirbtnUa3MfxO/RzD6NG66ejf6o/+rNwcXrHon6eHRrNmoSJoCD0uvI2elh8xcIrGSPNrwcFB5DtpSqTfR4cwXY3eTbPTRarTKteHWsQhxk0Ggic2CX8qb9VcG2w6HrgdRESFqsCTwKzXqqFmRvVObaGDCXWNiN7cMOdkVpWtwReO541gK7zFGYKxlkns0g80wGmWsZZK6OAXOJhd3YPjhLG6qiFusCz7pnLWyG1xLzWgaZ6xlknnvH7IV5HK7BEgu7sX14amxvWGixIfBseNaC7I3KPJtB5loGmSsZZL6TQeaZDDJnsT5nsW5k8Roch/pcYmE3tg9PjO1NCy02BZ5Nz1qQvVGZFzLIXMsgczWDzGsZZK5nkPldffbDPJNB5izWjbkxYC6xsBvbR5E7cGihRSjwhJ61IHujMlfHgLnEwm5sH7aN7YaFFg2Bp+FZC7I3KvNCBpmrGWReyyBzPYPMc++YvTBnsd1YzCBzFtu62Qwy1zLIXMkg8zi0GyUWdmP7KBovbllosSXwbHnWguyNylzLIHM9g8xz75i9MG+OAbNxkSf/6V/lNHk6J2XGQ5oFjDFgjGUIL4Nm23H4ceD2UxOytQ227jrXY3B+eH2h/buqtjs9k++OQplMvrvu840+NdmL86JPTXYFrfbjcM7xedqDfHNgh44XIfzL3HVcikd6UHtA7GYcdS8OIztPt8XSVSHOPUi3y9LRPp1ro90v4DrXqFs29dr05XQtfxBc89B3Gy8Dt3Vy2Xk5B1Mk5YPhLa09w7brtgKP+a6ExrjXn+pcnl/0ftL/Yb93mgNG/r0O/mIZXsI+lnVKCOdZOvpVaj+jb1PuKehoyovXSwj8ZK8IcX4TC4TTb9CGeREn6UR5mjaA6gbFLQV603rdFhgDxkgbMVQhHba3Cn1IZ9TrCjVTqA/RJ7I7I/DcAx6FvrBVBX2IyzBS/5MH+/sK9rE/pLxpn+xV4dg9YNwXGO+7Z2xLfSjt3wdGOrYLPHsKmpUZj9nS6tCewHhXV7MO1iEbRtSR0mF9vM/KYrgfuOeO6uN9xkj7D4CRjmF9fCAwPnTPGNXHB4yR9h8CIx3bBcbJOEzn3/RJv4UxnEIb3MSxZDHOmzh24PjVGLx4zfZlzFaBuFSHK8HNsbMp4zY7pnlPTLYob9rfAkaqI9v+Gdu2jHcZo1bblQNblPddpgWOD3bgGLXz+6Cj1E9tK3En9VPbwCj1U9sC4zd1rqtwDPsArX4Kecxm209Ruh1dxs6o4zFk5O0R1kfk1mp7kuojnmupPm4JjA33jO20e/cGMPp5TjUYe/PnPKaP+bvqM4xB/4f3eqHAUYQ4/yhcs/0T+j/eRleCm9dJObiur3h+tXzSyBblTfubwIj13zNj25axwRi1nmnmgpvvGRtMC+n+GPs/HEfQ//MeuJP6beSmY/i8fUdgDN0ztqXnI6gFMdKxBvBo9MflYPhcmy2tb9kCHoVz2MW234YHr02NMZXW/Qa246XAbTseMq14X4o+pcgQKuhnU9/fMb9jTmJGfxapvW6MCSMdw3tTjXbDlJ3GYPjMfi9/bVehHexi30rvCPgzgyLEWYPx4cOYzYxhaDxD582UZ50dM2XQmqOEz1HA5yMwjNJ3+RpzFIza90o8Dt8bNvFaQ1sa81eVg+H5a15XdmlOK5fvTJPmq1KYe62J9xY4JeK386qad7H+0zUcsjIXIc5/8tdxvwPXMKWhumL+hfdF9JuHOPT/lywPuoeoQJjG4Ng24Lj8m2wbqBzr/hnb49Z+5YKb36Rz2xVBH6PZqqDZihIjn3eRz7FYAf1W/TO2bRml+RC15oZ83RSueK+/7l8zq/OK82neAcYVgVFh6uvovK4wRtpfAkY6pjxPYntUPwOcq0NjDKBUzqE5XEcZI3Sah91u/6jdb3VavWb70cnxQbN7cHJ43DpuHRwfnOL1Nkq+7eNOp3/cPT56dPLoqPmo1e30W2cHjzpnwLv0BvmyrcUPBMFwXed1z+b/Uly8xtdZPPKf4lMvU73D+QgpDvZTWlPQ87kS7zDuLDIb2wrLFzRHHZtrLyFg/Pzo+5srP7/v9p49Q6c+DoxgGA8LwifYNgWYgLh5lt5s3MGc/k+DV/wgnwa/Eyn282yf8s0HMis5GOLN8uM43Hy7behlCa2fuMjKouPM2YpecuJgkvTCLYQwroug8eJIp5yDxn7Z+bkbrJ/I14PZYFrhejDIoLUezG3GQ/s+1oOZt9BiXuDRWicoSQvldYKiybrnLLSYE3i01rxK0kJ3zavBWpJ1Cy3qAo/WWmhJWqSt35bGvDAGzKVAZf226PzVLLSoCTxaaz4maaG75qO8FqikxazAo7UWaJIWymuBRm1c1UKLqsBT9axFVbDtUIvIdsVCi4rAo7V2cJIWumsHD9Y4nLHQYkbg0VpTOkkLsvf/wFwbA+ZSoLJ2d7TQT9lCi7LAU/asBdkblbk6BsylQGMd+sG60rcstLgl8GgsdJWmBdkblbmSQeaFDDLXx4C5xMJubLcj29MWWkwLPNOetSB75Nhstn/nNXla3VE/PCWGMoTxGVcpDj8O3Dp8TIMN+p1yrkdTrC+0P6Vqu9XB57ru8h08Iyy6zze6t4v9p64cNYqCVltxOOf4PBUg3xzYoeNFCH+dv45L8UiPDYhvNtPv0Ed1yM7TTbN0+AHGJKQrsnS0PwG/X8F1rlG3bOq1Ge/yZ5/Tga5zFTqKkF4B46RN2eEpem6DCymGzA4dpxeMk/Fx+h/FLUKc/8bnVZqEQPOl3AorB5ULXyQusnLwdXOLEKdYSC4HLpiEjiCSw6TCi8DovFF9pXaIOK74Ic6tlLJgXsS5KZSNNKK4+GIaHf8wLr77S0vHw+ssjTSJrGRHxQGzNXhhj/xrjBOdFCmepGsYh7FOUl782qK0RYizknIey0JadF7Ej8AakGaLHdN02Ob9yRaEiZF/dGp43C+U0h5y9qQtrS3WXqxEp5yD95ruF1NrDa25Tswh0wqvC2TQchRNcnrUXejy6BCv4zQtpPZKaxHiJC10FyHuRM9pVi20WBV4tJwmk7TQXVC7IzoahoIWKwKPlnNmkhYrgm13WgycLpcstFgSeLTGjElaLAm2HbadbRyLpmmxKPAojCdTtVgUbLvToneYNk5CLRYEHi3/mCQtdP1jutF7sXkLLXz6xyRpoesfcxqNL+YstPDpH5OkhbJ/TLSwXt1CC5/+MUla6PqaHEX1omahhU9fkyQtlH1NorZz1kILn74mSVqQvVGZl8aAWcc/phtNUFu10MKnf0ySFrr+MU+ivq9ioYVP/5gkLXT9Y54cGdszFlr49DVJ0kLXb+M0ukbKFlr49NtI0kLXB6IZXSO3LLTw6QORpIXue+6jqF5MW2jh8z13khbTgm13WhxEWpQstCgJPCXPWpC9UZmXxoC5xMJubLej5wFTFlpMCTxaPgFJWkg+AQ61iCaHn7TQYlLgmfSsxaRg250WZ8fG9oSFFhMCj4ZfRZoWE4Jth89So++oihZaFAUeBV+QVC2Kgm13WvQj34aChRYFgafgWYuCYNvh80NxIqhQ0GJH4NGa7DBJix3BtsPnymfG9q6FFrsCj8YCAWla7Aq23WlxPLRQT5oWewLPnmctyN6ozNUMMs+OAXOJhd3YPhAXewgFLfYFHq0FMpK02AfbGv4VqAWfmA77SYrzu9f4KCXpSnniZMFYNoUFKiL/qwcJZbsPZaM4f0gpWylQWYyiq1T2qE49hDKavLeFslOcP8KEg3+Kw7gICU5e+Ffh/7Tl2H4I4Qeg5bcUymzyfd99vtE10oTyh2AHy9QCDVyVCW3n4j+yQ8eLEP5L4TouxSM96BwSu7kW34vDyM7T7bN0VYjzHqR7n6WjfTrXRrs/Qz2jeqTTtg20ey+hLPegLBQHfdm0FpjYYjx8ElATh87TJItDaXGi0K9e4//aiMO4gAH3L1Rq21InFMeFdugYPp/lZeaTtI7DJP7/StFeWhQG+z6czH+THdO8HnB+nRD28Z0J1YtN/4xtW8aQMWr66HEeOq9rHmzzCSsbzPao8/5o+3dq+Qcq+dpF1zw9s+Y++tg+LoK2rsqEtqlv575kRQjXi9dxuV8atSvStwDIztNxv0L0Z8NvTpImYsQJeKdiPqXrITpXSRNrNoB1NaGMa1BG5Cbm0D1z6kR0IfBQH7EJx6itxX5RaodDJe6kdhi5pQl9Q4Gx4Z4xdeGXBjDSMcm/3CFPCxcfovz54kPjsPjeXnydJo1bKB4uwkd9Hj0LwW9S8PmIwnlO/SalAYzSwjSeGNu2jH6+m5E1o/O64cF2yGxLY/xGMLzl2H4ohA2z1nc960r5akzSi30hjVvIDi48sgrauioT2qZxC/9OBL+H+wjGLbxvpnZFmoAd2Xm6BkuHffoGpEvqe3Ei/w9g3KJwPUTnKun57l1gTRrr4zNpioPvCrXeCSX1/7vAQ33EFhyjtpb4k9phLe6kdhi5+TeN2Hcjo8JzoDb215Q37eNCo3QM73E12j5cNJjyx0WD/wfPZ0jDMtEAAA==","debug_symbols":"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"},{"name":"_assert_token_is_same","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(internal)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"5dzhah1HFsTxd9Fns8yc6nO626+yLIuSOIvAyCFWFhaTd19lcyVvyE3Mv5wTUPwpKJ4e7qSqQPwy1x9uvnnz1Q//+ufd/bfv3t+8/vuHm7fvvr59uHt3//jTh5vjb+t///L9d7f3P/38/uH2+4eb18ermzf33zz+88dXN9/evX1z83rsH1/96rJduly4Vz5fuuaVS8e55uXace56vvhUXrm6YuzL1RWVv7j6H68eP/X+jE99HuPpyvOo+FM/93l8zn/uvT9+bv3+5z7PczxdfM7jE597juennKnjyuc+Wz73z/eOxnur8d6j8d7ZeO9qvPdsvPdqvPfuu3ccjfdu3GU07jIadxmNu4zGXUbjLqNxl9G4y2jcpRp3qcZdqnGXatylGnepxl2qcZdq3KUad6nGXY7GXY7GXY7GXY7GXY7GXY7GXY7GXY7GXY7GXY7GXWbjLrNxl9m4y2zcZTbuMht3mY27zMZdZuMus3GX1bjLatxlNe6yGndZjbusxl1W4y6rcZfVuMtq3OVs3OVs3OVs3OVs3OVs3OVs3OVs3OVs3OVs3OVs3OVq3OVq3OVq3OVq3OVq3OVq3OVq3OVq3OVq3OVq3OVu3OVu3OVu3OVu3OVu3OVu3OVu3OVu3OVu3OVu3OV5HJ0373yz4Oh8teDofLfgGJ0373y74Oh8veDofL/g6HzB4Ohc6Nm50NZ3f1pf/ml9++ezXv8ZUl2uHBrj+eLfeK1sHE/3rXFee63ss94X+qPfcQMvGF0OTHpg0QMbHgAv7VwOnPRA0AOiBwY9kPQATTpo0kGTDpq0aNKiSYsmLZq0aNKiSYsmLZq0aNKiSQ+a9KBJD5r0oEkPmvSgSQ+a9KBJD5r0oEknTTpp0kmTTpp00qSTJp006aRJJ006adJFky6adNGkiyZdNOmiSRdNumjSRZMumvSkSU+a9KRJT5r0pElPmvSkSU+a9KRJT5r0okkvmvSiSS+a9KJJL5r0okkvmvSiSS+a9KZJb5r0pklvmvSmSW+a9KZJb5r0pklvmHQcBz1w0gNBD4geGPRA0gNFD0x6YNEDNOmTJn3SpE+a9EmTPmnSJ02aGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNLKiRBTWyoEYW1MiCGllQIwtqZEGNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIRI1M1MhEjUzUyESNTNTIdN3Iap55OVNT+f/Hrv1l6/Ppu2XnGefzxWdc+25ZPv7WeLk6H9f48eqr30TLOJ4+SIY+dfXK8+l7ayvzyvfWdF34/rqPu7+kxx3XdfWv+7jnl/W48WU9rv70x9X58XHjEw9wnns93TuO+Xz14//cfXqA8dIfIF/6A9RLf4D50h9gvfQH2C/8Ac5P/04w8le/F4/z9I6Fd0zeseEdS+9Yecemd2x5x7Z1LLyWhNeS8FoSXkvCa0l4LQmvJeG1JLyWhNcSeS2R1xJ5LZHXEnktkdcSeS2R1xJ5LZHXkuG1ZHgtGV5LhteS4bVkeC0ZXkuG15LhtWR4LUmvJem1JL2WpNeS9FqSXkvSa0l6LUmvJem1pLyWlNeS8lpSXkvKa0l5LSmvJeW1pLyWlNeS6bVkei2ZXkum15LptWR6LZleS6bXkum1ZHotWV5LlteS5bVkeS1ZXkuW15LltWR5LVleS5bXku21ZHst2V5LtteS7bVkey3ZXku215LttWRbLcnj8I6d3rHwjsk7Nrxj6R0r79j0ji3vmNcSz17Ts9f07DU9e03PXtOz1/TsNT17Tc9e07PX9Ow1PXtNz17Ts9f07DU9e03PXtOz1/TsNT17Tc9e07PX9Ow1PXtNz17Ts9f07DU9e03PXtOz1/TsNT17Tc9e07PX9Ow1PXtNz17Ts9f07DU9e03PXtOz1/TsNT17Tc9e07PX9Ow1PXtNz17Ts9f07DU9e03PXtOz1/TsNT17Tc9e07PX9Ow1PXtNz17Ts9f07DU9e03PXtOz1/TsNT17Tc9e07PX9Ow1PXtNz17Ts9f07DU9e03PXtOz1/TsNT17Tc9e07PX9Ow1PXtNz17Ts9f07DU9e03PXtOz1/LstTx7Lc9ey7PX8uy1PHstz17Ls9fy7LU8ey3PXsuz1/LstTx7Lc9ey7PX8uy1PHstz17Ls9fy7LU8ey3PXsuz1/LstTx7Lc9ey7PX8uy1PHstz17Ls9fy7LU8ey3PXovb6+MP/779/u72q7dv3j8e+enPfrj/+uHu3f3lx4f/fPfznzxe+18="},{"name":"claim_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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EVzbXpQVcG17UVbAte1FWQHXthdlhTwri6yAa9uLsgKubS/KimvbVVZc266y4tp2kZXk2naVFde2q6y4tl1lxbXtKivkWVlkxbXtKiuubVdZcW27yopr21VWXNsuspJd266y4tp2lRXXtqusuLZdZYU8K4usuLZdZcW17Sorrm1XWXFtu8qKa9tFVsi17Sorrm1XWXFtu8qKa9tVVsizssiKa9tVVlzbrrLi2naVFde2q6y4tl1kpbi2XWXFte0qK65tV1lxbbvKCnlWFllxbbvKCra2rbntWal0Xlawte1VWcHWtldlBVvbXpQVcF+yq7KCrW2vygq2tr0qK9ja9qqskGdlkRVsbXtVVlzbrrLi2naVFde2q6y4tl1kBdyX7KqsuLZdZcW17Sorrm1XWSHPyiIrrm1XWXFtu8qKa9tVVlzbrrLi2naRFXBfsquy4tp2lRXXtqusuLZdZYU8K4usuLZdZcW17Sorrm1XWXFtu8qKa9tFVsB9ya7KimvbVVZc266y4tp2lRXyrCyy4tp2lRXXtqusuLZdZcW17Sorrm1/zEoH9yW7KiuubVdZcW27yopr21VWyLOyyAq2tm0hbH+5pXxeVrC17VVZwda2V2UFW9telRVsbXtRVsB9ya7KCra2vSor2Nr2qqxga9urskKelUVWXNuusuLadpUV17arrLi2XWXFte0iK+C+ZFdlxbXtKiuubVdZcW27ygp5VhZZcW27yopr21VWXNuusuLadpUV17aLrID7kl2VFde2q6y4tl1lxbXtKivkWVlkxbXtKiuubVdZcW27yopr21VWXNsusgLuS3ZVVlzbrrLi2naVFde2q6yQZ2WRFde2q6y4tl1lxbXtKiuubVdZcW27yAq4L9lVWXFtu8qKa9tVVlzbrrJC2FnZr42tpvOyAq5tL8oKuLa9KCvg2vairIBr24uyAq5tr8kKuC/ZVVkB17YXZQVc216UFXBte1FWyLOyyIpr21VWXNuusuLadpUV17arrLi2XWQF3Jfsqqy4tl1lxbXtKiuubVdZIc/KIiuubVdZcW27yopr21VWXNuusuLadpEVcF+yq7Li2naVFde2q6y4tl1lhTwri6y4tl1lxbXtKiuubVdZcW27yopr20VWwH3JrsqKa9tVVlzbrrLi2naVFfKsLLLi2naVFde2q6y4tl1lxbXtKiuubX/M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"},{"name":"exit_to_l1_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"claim_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"message_leaf_index","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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BvQ9eciAvicPGazUk68ZrNSTrxmw9+Sqx+9E1yaXDNh78pgBe08eMlD2njxmQP/7uEMG7D15zIC9J39iYOWSAXtPHjNg78lV+8HArxmw9+QqPmBA35OHDOh78pABfU8e/F66V/qePGSw+m/We6XvyUMG9D15yIC+Jw8Z0PfkIYM39IP6/CKqun/F4ECVjKhaoUQllKiUEtU7PLMcF5cmcomqUaIySlROiSooUXVKVMmIygolKqFEpZSoKL3dKL3dKL3dKL3dKL3dKL3dKL3dKb3dKb3dKb3dKb3dKb3dKb3dKb3dKb3dKb3dKb09KL09KL09KL09KL09KL09KL09KL09KL09KL09KL29U3p7p/T2TuntndLbO6W3d0pv75Te3im9vVN6e6f09qT09qT09qT09qT09qT09qT09qT09qT09qT09mT09iiM3h6F0dujMHp7FEZvj8Lo7VEYvT0Ko7dHYfT2KIzeHoXS24XS24XS24XS24XS24XS24XS24XS24XS24XS24XS25XS25XS25XS25XS25XS25XS25XS25XS25XS25XS2yult1dKb6+U3l4pvb1Senul9PZK6e2V0tsrpbdXSm9vlN7eKL29UXo75V5qUO6lBuVealDupQblXmpQ7qUG5V5qUO6lBuVealDupQblXmpQ7qUG5V5qUO6lBuVealDupQblXmpQ7qUG5V5qUO6lBuVealDupQblXmpQ7qUG5V5qUO6lBuVealDupQblXmpQ7qUG5V5qUO6lBuVealDupQblXmpQ7qUG5V5qUO6lBuVealDupQblXmpQ7qUG5V5qUO6lBuVealDupQblXmpQ7qUG5V5qUO6lBuVealDupQblXmpQ7qUG5V5qUO6lBuVeaqfcS+2Ue6mdci+1U+6l9sLo7Z1yL7VT7qV2yr3UTrmX2in3UjvlXmqn3EvtlHupnXIvtb9jL7X283gr16iMEpVTogpKVJ0SVTKiesde6i9AJZSolBJVpURF6e1K6e1K6e1K6e1K6e1K6e2V0tsrpbdXSm+vlN5eKb29Unp7pfT2SuntldLbK6W3N0pvb5Te3ii9vVF6e6P09kbp7Y3S2xultzdKb2+U3m6U3m6U3m6U3v6SXctHNz3KSI8+QmWmx3GzeF68nqCcEVQwguqMoJIQ1EvWLF8OShhBKSOoygiqMYJidHRndHRndHRn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"},{"name":"exit_to_l1_private","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"},{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"amount","type":{"kind":"field"},"visibility":"private"},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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"},{"name":"get_portal_address","is_unconstrained":false,"custom_attributes":["aztec(private)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::private_context_inputs::PrivateContextInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs","fields":[{"name":"call_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::call_context::CallContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"function_selector","type":{"kind":"struct","path":"aztec::protocol_types::abis::function_selector::FunctionSelector","fields":[{"name":"inner","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"is_delegate_call","type":{"kind":"boolean"}},{"name":"is_static_call","type":{"kind":"boolean"}},{"name":"side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"args_hash","type":{"kind":"field"}},{"name":"returns_hash","type":{"kind":"field"}},{"name":"min_revertible_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"is_fee_payer","type":{"kind":"boolean"}},{"name":"max_block_number","type":{"kind":"struct","path":"aztec::protocol_types::abis::max_block_number::MaxBlockNumber","fields":[{"name":"_opt","type":{"kind":"struct","path":"std::option::Option","fields":[{"name":"_is_some","type":{"kind":"boolean"}},{"name":"_value","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}},{"name":"note_hash_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"nullifier_read_requests","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::read_request::ReadRequest","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"key_validation_requests_and_generators","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator","fields":[{"name":"request","type":{"kind":"struct","path":"aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest","fields":[{"name":"pk_m","type":{"kind":"struct","path":"aztec::protocol_types::grumpkin_point::GrumpkinPoint","fields":[{"name":"x","type":{"kind":"field"}},{"name":"y","type":{"kind":"field"}}]}},{"name":"sk_app","type":{"kind":"field"}}]}},{"name":"sk_app_generator","type":{"kind":"field"}}]}}},{"name":"new_note_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::note_hash::NoteHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"new_nullifiers","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::nullifier::Nullifier","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_hash","type":{"kind":"field"}}]}}},{"name":"private_call_requests","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::private_call_request::PrivateCallRequest","fields":[{"name":"hash","type":{"kind":"field"}},{"name":"caller_context","type":{"kind":"struct","path":"aztec::protocol_types::abis::caller_context::CallerContext","fields":[{"name":"msg_sender","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"storage_contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"is_static_call","type":{"kind":"boolean"}}]}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"public_call_stack_hashes","type":{"kind":"array","length":16,"type":{"kind":"field"}}},{"name":"public_teardown_function_hash","type":{"kind":"field"}},{"name":"new_l2_to_l1_msgs","type":{"kind":"array","length":2,"type":{"kind":"struct","path":"aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"content","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"start_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"end_side_effect_counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"note_encrypted_logs_hashes","type":{"kind":"array","length":16,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::NoteLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"note_hash_counter","type":{"kind":"integer","sign":"unsigned","width":32}}]}}},{"name":"encrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::EncryptedLogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}},{"name":"randomness","type":{"kind":"field"}}]}}},{"name":"unencrypted_logs_hashes","type":{"kind":"array","length":4,"type":{"kind":"struct","path":"aztec::protocol_types::abis::log_hash::LogHash","fields":[{"name":"value","type":{"kind":"field"}},{"name":"counter","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"length","type":{"kind":"field"}}]}}},{"name":"historical_header","type":{"kind":"struct","path":"aztec::protocol_types::header::Header","fields":[{"name":"last_archive","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"content_commitment","type":{"kind":"struct","path":"aztec::protocol_types::content_commitment::ContentCommitment","fields":[{"name":"num_txs","type":{"kind":"field"}},{"name":"txs_effects_hash","type":{"kind":"field"}},{"name":"in_hash","type":{"kind":"field"}},{"name":"out_hash","type":{"kind":"field"}}]}},{"name":"state","type":{"kind":"struct","path":"aztec::protocol_types::state_reference::StateReference","fields":[{"name":"l1_to_l2_message_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"partial","type":{"kind":"struct","path":"aztec::protocol_types::partial_state_reference::PartialStateReference","fields":[{"name":"note_hash_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"nullifier_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"public_data_tree","type":{"kind":"struct","path":"aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot","fields":[{"name":"root","type":{"kind":"field"}},{"name":"next_available_leaf_index","type":{"kind":"integer","sign":"unsigned","width":32}}]}}]}}]}},{"name":"global_variables","type":{"kind":"struct","path":"aztec::protocol_types::abis::global_variables::GlobalVariables","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"block_number","type":{"kind":"field"}},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64}},{"name":"coinbase","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"fee_recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"gas_fees","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}}]}},{"name":"total_fees","type":{"kind":"field"}}]}},{"name":"tx_context","type":{"kind":"struct","path":"aztec::protocol_types::transaction::tx_context::TxContext","fields":[{"name":"chain_id","type":{"kind":"field"}},{"name":"version","type":{"kind":"field"}},{"name":"gas_settings","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_settings::GasSettings","fields":[{"name":"gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"teardown_gas_limits","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas::Gas","fields":[{"name":"da_gas","type":{"kind":"integer","sign":"unsigned","width":32}},{"name":"l2_gas","type":{"kind":"integer","sign":"unsigned","width":32}}]}},{"name":"max_fees_per_gas","type":{"kind":"struct","path":"aztec::protocol_types::abis::gas_fees::GasFees","fields":[{"name":"fee_per_da_gas","type":{"kind":"field"}},{"name":"fee_per_l2_gas","type":{"kind":"field"}}]}},{"name":"inclusion_fee","type":{"kind":"field"}}]}}]}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"7Z3trjS3ca3vRb8NgywWv3wrB8GBkjgHAgw5iJUDBIbuPVPcb/fe9tszI013cVaR/GXJ6t7r4XDIqmF31fr7D//+53/97//3f3/6+T/++rcf/vR//v7DX/76bz/+8tNff779299/8LH9f3/7zx9/ln/92y8//tcvP/zJ/eGHP//877f//fUPP/zHT3/58w9/4vrrH767LJSYvl0ZSqX9Yh/Cr//yhx98Uvzb+cTf9r7Qtys9cd4vLvnoYqayXRyZH19MqWwMVNwnxk3w4OrKlb9dXWMM/3C1jLGcGSPVfYyB3WPsuHOkEPdLk2sUFYGCHASFh6AgCIoAQcEQFBGCIkFQZAiKfntn8hvFl1DyjaIiUIRue2cOW8zOxf0zRbe9s7o9qgb6SvH9pSm4/WP7/Ar5mo4YYskbQ3LpH66W8dHg4wuDj4+tjy95v48vxO/GFwcfXxp8fNn8+Njt40vuu/GVwcdXxx4fO/vxIX2Oz383Psj8pW5bRg7h2fhK2feX6ut+NXEbHmT6ct3wumUv3n1yeI6PBxjDdrYU0+fRUvDH4WH7s6V8jq6dFDEPPbo49OjS0KPLQ4+uDD26OvLooht6dH7o0dHQoxs6V4k89OiGzlXi0LlKHDpXiUPnKnHoXCUNnaukoXOVNHSukobOVRIPPbqhc5U0dK6Shs5V0tC5Sho6V8lD5yp56FwlD52r5KFzlcyQo8sUv12bQ/46OkHGTEAeImNmFWV/zn17CvrkO/TwOWnGzCuuGx9mZnHd+DBzi8vGVzCzi+vGh5lfXDc+zAzjuvFh5hjXjY8HHx9mSnLd+AbPX8rg+UsZPH8pg+cvdfD8pQ6ev9TB85c6eP5SefDxDZ6/1MHzlzp4/lIHz1/q4PmLd4MnMN4NnsF4N3gK493gOYx3PPoAB89ivBs8jfFu8Dzmpjr6AEfPZPzomYwfPZPxo2cyfvRMxvPoAxw9k/GjZzJ+9EzGj57J+NEzGRo9k6HRMxkaPZOh0TOZfo1I3zXA0TMZGj2TodEzGRo9k6HRM5kweiYTRs9kwuiZTBg9k+nXCPddAxw9kwmjZzJh9EwmjJ7JhNEzGR49k+HRMxkePZMB7Yl74QB59AGOnsmANse9cICjZzKgLXIvHODomQxoo9wLBzh6JgPaLvfCAY6eyYA2zb1wgKNnMqCtcy8c4OiZDGgD3QsHOHomA9pG98IBjp7JgDbTvXCAo2cyoC11Lxzg6JkMaGPdCwc4eiYD2l73wgGOnsmANtm9cICjZzKgrXYvHODomQxow90LBzh6JjN6M18/ejdf37OdL+U7A2wghxnH7c/ulsKhhMc4FHYF4vLFn94ffYY58v4ZfnHRpYNLK9fdcTfGLz66pTUO98c9dY2w+87sNW3frttXnr/CNxzCwgmdcW4PC3eeGOvjufXkt0brnujLn85HC5Aib33yKebPbYOO/nTg3cs73L5Bnxcf7THB7zbTt3/MXy9uHyKvD/H8hxjXh3j+Q0zrQzz/Ieb1If6GD5H2uBuCd999iGV9iOc/xLo+xN/wIYbdjiV8zdIPL6ay50NUMj25OOwfBwX/3UZR3Zqe907P7nZEodTHF+e4jS9/Jf5Ig6tfMznITNKayUFmcv00ffNM1rp/eJTPzCSvmRxkJteP9PfOJJd9JuOXEW4J6fr5Dz0962ABenrWkQX09KzDkPdOT6LtYSil5B9ffDvOD9vHUTL/01ySWycn48zlOjsxNJe17n/Z+fL6TwFy66BlymlfpzJTTjuvaTcz7be9mfdpj3Rm2td5z5TTvs6Rrp/2uv1lqu7JVvz4uTO5dY705um56BkXuXXkNMpMrtOpN8/kRc+4yK+zqVFmcp1MvXcmHx7ok18nSNDTs056oKeH1/QgT886OXnv9Fz4hMuv45Bx5nKdnRiay8ueX/h10DLltK9TmRmnndYRjp1pv+6xFa3znimnfZ0jXT7tNe91yc7lUxk3rXMk6OnhNT1vnZ7rsp515DTKTK4Dp1Fmch03jTKT6wTprTN54e+FdSg0yEyGdc7zm2Zyf1J5m0h+9oP/sv5IFNZ5zJun56q3G8M6YhllJtdpzCgzyWsm3zuTV72nGtbBzSgzuQ5u3juTj1/KC+s0Bnp61hEL9PSscxPk6eF1GPLe6bnwLVVeJyfjzOU6OzE0l5c9L+J10DLltPOa9hmnfR3h2Jn26x5A8jrvmXLa1znS9dN+XX8kXudIb56eq55x8TpyGmQm4zqdevNMXvWMK66zqVFmcp1MvXcmHx/ox3WCBD09vKYHeXrWiQz09KyTk/dOz4VPuOI6DhlnLtfZiaG5vOz5RVwHLTNOe1qnMlNO+zrCsTPt1z22Suu8Z8ppX+dIl0/7hQ14Eq/pQZ6edY703um5LutZR06jzOQ6cBplJtdx0ygzuU6Q3jqT1/1eyOtQaJSZ7H/Os/8c9ik5IzPp6/aS2+0fv3ubNNP6EM9/iGF9iOc/RF4f4vkPMa4P8Td8iFT3gBW8++5DTOtDPP8h5vUhvtVc/XEVSS5ret47PVfVHuS6ZnKMmSxuzeQgM7l+mr55Jq+qIinr9/EoM7l+pL93Jh+/Ml94TQ/y9KyDBejpWUcW0NOzDkPeOz0X1pCUdXIyzlyusxNDc3nZ2xx1HbRMOe3rVGbKaV9HOHam/brXg+o675ly2nlN++XTfl33wrrOkd48PVc946rryGmUmVynU2+eyauecdV1NjXKTK6TqffO5MMD/VuOs6YHeXrWSQ/09KwTGejpWScn752e655wBcdrLoeZy3V2Ymgur3p+Edw6aJly2tepzJTTvo5w7Ez7ZY+tglvnPTNOu1/nSJdP+3Xt8YJf50jQ07POkd47PZdlPX4dOY0yk7xmcpCZXMdNo8zkOkF660xe+HthHQqNMpPrnOd6u4LL+iMFv85j3jw9F73dGGgdsYwyk+s0ZpSZXAc3b57Ji95TDbQObkaZSV4z+daZfPxSHq3TGOjpWUcs0NOzzk2gp2cdhrx3ei58S5XWyckwcxnW2YmhubzseVFYBy1TTvs6lZly2tcRjp1pv+4BZOA17TNO+zpHun7aL+uPFMI6R3rz9Fz1jCusI6dRZnKdTr15Jq96xhXW2dQgM8nrZOq9M/n4QJ/XCRL09KyTHujpWScy0NPDa3reOj0XPuHidRwyzlyusxNDc3nZ8wteBy1TTvs6lZly2tcRjp1pv+6xVVznPVNO+zpHunzaL2zAE9c5EvT0rHOk907PZVlP5DWTg8zkOnAaZSbXcdMoM7lOkN46kxf+XliHQqPMZPdznlT2ycmufp1J4UkOjMeD8XT/KZg97zwhf8cTwHgYjKd7HppL2X+r+u95EhhP95wgp/zJU77jKWA83ffn6rb3eW+Zn/9nnuzAeDwYD4Hx9N6f6bMpJH1tCnmYqXHd2KP78v5PLgfX1v1a71z8h4vbQHmWgcZZBppGGah33u0jpYOR5mlGWqYZaR1nmX4ONLrvBlrciAPN389o8cgDjXF7cJw4PvvulvKZM/gvNVv8MVCaZaD9kyP3OdD8bKBh++EU0+e5TTg8o91r8G4j/ucjnsJTjDJOMco0xSjzFKMsU4yyzjDK6qYYpZ9ilDTFKKfIfSpPMcopcp86Re5Tp8h96hS5T50h92E3Q+7Dbobch90MuQ+7GXIfdjzFKGfIfdjNkPuwmyH3YTdD7sNuitzHT5H7+ClyHz9F7uOnyH2626O/Z5RT5D5+itzHT5H7+ClyHz9F7kNT5D40Re5DU+Q+NEXu091h9D2jnCL3oSlyH5oi96Epch+aIvcJU+Q+YYrcJ0yR+4Qpcp/ublvvGeUUuU+YIvcJU+Q+YYrcJ0yR+/AUuQ9PkfvwFLkPT5H7dPfL+F2jzHuJ39cuKcF/oEMnNI/RobOUEraS1lL8k+/Ww1pJZug85cJxQmcqF44TOle5bpwROlu5cJzQ+cqF44TOWC4cJ3TOcuE4eZJxQqc4F45zknwoTpIPxUnyoThJPpQmyYfSJPlQmiQfSpPkQ90b2L5rnJPkQ2mSfChNkg+lSfKhNEk+lCfJh/Ik+VCeJB/Kk+RDb+jr/J5xTpIP5UnyoTxJPpQnyYfyJPlQmSQfKpPkQ2WSfAi7l/OF4+RJxjlJPoTd0fnCcU6SD2F3db5wnJPkQ9idnS8c5yT5EHZ35wvHOUk+hN3h+cJxTpIPYXd5vnCck+RD2J2eLxznHPlQxO72fOE458iHInbH5wvHOUc+FB1PMs458qGI3fn5wnHOkQ9F7O7PF45zknwIuwP0heOcJB/C7gJ94TgnyYewO0FfOM5J8iHsbtAXjnOSfAi7I/SF45wkH8LuCn3hOCfJh7A7Q184zknyIezu0BeOc5J8CLtD9IXjnCQfwu4SfeE4J8mHsDtFXzjOSfIh7G7RF45zknwIu2P0heOcJB/C7hp94TgnyYewO0dfOM5J8iHs7tEXjnOSfAi7g/SF45wkH8LuIn3hOCfJhybpTx0n6U8dJ+lPHSfpTx0n6U8dJ+lPHSfpTx0n6U8dJ+lPHSfpTx0n6U8dJ+lPHSfpTx0n6U8dJ+lPHSfpTx0n6U8dJ+lPHSfpTx0n6U8dJ+lPHSfpTx0n6U8dJ+lPHSfpTx0n6U8dJ+lPHSfpTx0n6U8dJ+lPHSfpTx0n6U8dJ+lPHSfpTx0n6U8dJ+lPHSfpTx0n6U8dJ+lPHSfpTx0n6U8dJ+lPHSfpTx0n6U8dJ+lPHSfpTx0n6U8dJ+lPHSfpTx0n6U8dJ+lPHSfpTx0n6U8dJ+lPnSbpT50m6U+dJulPnSbpT50cTzLOOfKhNEl/6jRJf+o0SX/qNEl/6jRJf+o0SX/qNEl/6jRJf+o0SX/qNEl/6jRJf+o0SX/qNEl/6jRJf+o0SX/qNEl/6jRJf+o0SX/qNEl/6jRJf+o0SX/qNEl/6jRJf+o0SX/qNEl/6jRJf+o0SX/qNEl/6jRJf+o0SX/qNEl/6jRJf+o0SX/qNEl/6jRJf+o0SX/qNEl/6jRJf+o0SX/qNEl/6jRJf+o0SX/q1L8/NXG9M87Gc0HeEt12MUUqT3hyCt8uzvWTnXI4uLaGDb2m+uTaHMv+d/nz2o9RXtFF2sAoD3OW7ZvrHo8vxUDfrkwx5c/xhfDxx+nUH6/bh5duj8b/4Y8ffNQ5bp8e5Rw/v7Lx4OJQ8raOQ2V6fHHlyttnHePnjPvy7RMMMwySMQfJwW3cHBKfGiSVPx4/QSIf9m3f18/llsN2W3rttvzabeW12+pLtx0fZj+/zb922+GOQfQZd28b6dfbDr5tfot0KdfHl/qayx53v+yN/rb/fuMJYDwMxhPBeBIYTwbjKWA8FYvn+KjqjTwejAdsf2aw/ZnB9mcG258ZbH9msP2ZwfZnBtufI9j+HMH25wi2P0ew/TmC7c8RbH+OYPtzBNufU9f1HuN2yhfz5xGyz2WjISiart/lWLajx1jKEU2CoslQNAWKpiLRZMUM45uCV1c4vy9kv12biQ8UgroCqytEdYWkrpDVFYq6wvn1//nIoLinMZ4+Y3zIBzG+ODAeD8ZDYDwBjIfBeGJfnhh3nnSUQ5cExpPBeAoYT8XiqQ6Mx4PxdN6fv/xmLkf7Tw1gPAzGE8F4EhhPBuMpYDz1bTyHZ2TeOTQgjwZ0fosutL8BmPOLl240AYqGoWgiFE2CoslQNAWKpiLReAdF46FooPZiD7UXe6i92EPtxR5qL/ZQe7GH2os91F5MUHsxQe3FBLUXE9ReTFB7MUHtxdR1v3n2IoSnCoUTuq6qZw/YfQhYOIyFE7FwEhaOYpqzSRR1iUhQ+0MMWDiMhROxcBIWTtffHbFufza5eIhTsHAqFE5yWDgeC6fvrlz9jpMOcQIWDmPhRCychIWTsXAKVBKZKhROdlg4HgsH68drxvrxmhkLB+vHa8b68ZozFg7WrpyxduWCtSsXrF25YO3KBWtXLli7csHalQvWrlywduWCtSsXrF25Yu3KFWtXrli7csXalSvWrlyxduWKtStXrF25Yu3KFWpXJge1K5OD2pXJQe3K5KB2ZXJQuzI5qF2ZHNSuTK5vq4YnDx/JOywcqOYw5KG6w5APWDjcFefJw0fyEQsnYeFkLJyChdN3V37ytI/IYeF4LBzCwglYOIyFA9XSjAiqpxkRVFMzIqiuZkRQbc0oOCwcj4VDWDgBC4excLB25YC1KwesXTlg7coBa1dmrF2ZsXZlxtqVGWtXZqxdmbF2ZcbalRlrV2asXZmxduWItStHrF05Yu3KEWtXjli7csTalSPWrhyxduWIsyv74u/YGma/24nKn90U6n5Xfumu8tJd9ZW7jo9Cnt7lX7qLXrrrcE8rfrOvLHR4F790V3zprvTSXfmlu8pLd9VX7jr+QVbK3v2v0tFd/qW76KW7wkt38Ut3xZfuSi/ddfjdqG47oq/eHd1VXrqrvnLXcVr49C7/0l300l3hpbsOvxuVdrPccLRSjjOLp3ell+7KL91VXrqrvnLXcWn107v8k7v4aL6OC5Wf3hVeuuv4u7F3Q63paC0fV+c+vSu9dFd+6a7y0l31lbuOCzyf3nX83Sib6bZ3sXy97Q+/49pNgvQlgr4E60tEfYmkL5H1JYq+RFWXOK79u1ZCf3UX/dVd9Fd30V/dRX91F/3VXfRXd9Ff3UV/dVf91V31V3fVX91Vf3VX/dVdT6+Lh+8SN4miLnHHw+B3aTw777tjS3CxRuigwR00YgeN3xk19vvya/dR0P8eE3fQiB00UgeN3EHj/N716P30D42qrxFcBw3fQYM6aJxf54/enP7Q4A4asYNG6qCRO2iUDhpVPyay66DRIdfiDrkWd8i1uEOuxR1yLU4dNHIHjdJBo8M6jx3WeeywzmOHdR47rPPYYZ3HDus8dljnscM6jx3WeeywzlOHdZ46rPPUYZ2nDus8dVjnqcM6Tx3WeeqwzlOHdZ46rPPcYZ3nDus8d1jnucM6zx3Wee6wznOHdZ6113n+46HCLena3ua95S2fzXvIH0iUuEmU4h9f6n1J29+lL69BEm04BQunYuEc9x16I48H4yEwngDGw2A8EYwngfGA7c4ebHv2YPszge3PBLY/E9j+TGD7M4HtzwS2P5Pi/rxJZH2J87vol8qK4E5/qhWLJzgwHg/GQ2A8AYyHwXgiGE8C48lgPGD7cwDbnxlsf2aw/ZnB9mcG258ZbH9msP2ZwfZnVtyfN4miL1HVJaLTl/D6EqQvEfQlWF8i6kskfQn91Z3Of2m9c1vVsneejkSoh8j5KffEn/ttOjofSLXDSLLrIdJj4jNfIJLqLlLSkUjsIZJ6iOQeIqWHyBXrJPlPkXwgUlwPEd9DhHqIhB4i3EMk9hBJPURyD5HSQ+SCFe/3Rly3fzrKVqrrIeJ7iFAPkdBDhHuIxB4iqYdI7iFywYr3mXaRL++nfRGpHUS8c11UQocfD3dq0C9XiV1UUheV2kPlgnf3fouK76JCXVT010s9fv8173fl/OT4lN3WUZUpPr607DtEdfzrl3PW338oW49flDXAXY1yHy9fC+DeKjhZBQ9WwdkqeLQKnqyCW42b3mrg9FYjJ1mNnGQ1cpLVyElWIydZjZxkNXKSWuTcBLK2wOlItDfy5shHAlVZIDhtAa8tQNoCp3e0vYCXSzgSYG2BqC2QtAXOruTothOn6MqRQNEWqMoC7LQFvLbA2a9ppO3SSIcCSVvg7CSnsL0wkSIdCESnLaD9EcXTK3k/O44xHwkUbYGqLJCctoDXFiBtgaAtwNoCUVsgaQtcuJJTOhIo2gLnV/K+2eUjgXx6JYf6WMBrC5C2wNmVnPaXS5OrRwKsLRC1BZK2QNYWOL2SP/tSe3ckUJUFitMW8NoCpC0QtAVYWyBqCyRtgXyhwNFKLkVb4PxK3l56S3QkUE+v5P1c846A1xYgbYHTMfnJr8zK2gJRWyBpC2RtgaItoH0Ycuedz6sU6p03y3wK+2u1KT55YOJ5N2D37P2Bxp2XCn+fCJddJD97hHNZN596780kK/BkGT5YhmfL8NEyfLIMny3DF8vw1TA8WY6wZDnCkuUIS5YjLFmOsGQ5wpLlCEuWIyxZjrCEEmG/8QSUoLnxdI6D17XfqvfeUbMCHyzDs2X4aBk+WYbPluGLZfhqGJ6dZXjLEZYtR1i2HGHZcoRlyxGWLUdYthxh2XKEZcsRNqJE2I0HJWhuPChxcONBCW0bD0q02nhQAtDGgxJTNh6UMLHxoOz8Gw/KZv6NJ4Htz6nzen/S67jeK/x4K1Hn7/STjl71XlnDOz+jTHBEAY4o9SZ62F663itseCtRgSOqaETFwRF1348etlGu96o53koU4IgYjijCESU4ogxHVOCIKhpRdXBEvffsx9226726nbcSBTgihiOKcEQJjijDERU4oopGdK9nviLSwwb7DcnjIREeUkQ7sbnX5/+tSBkPCe6ozfcu4fstSISHFPCQGA8Jal8il0x6Qwi3xRbXwm2xw7Vwm/SGaOAWO1w3cIsdrhu4xQ7XDZytglvscN3ALXpDNHCrcdOkN0QDtxo5TXpDNHCrkdOkN0QDtxo5TXpDNHCrkVPVG6IJZG0BTW+IJlCVBVS9IZqA1xYgbQFNb4gmwNoCUVsgaQtoekM0gaItUJUFVL0hmoDXFtD0hmgCSVtAsx2iCKh6QzQB7Y9I1RuiCRRtgaosoOoN0QS8tgBpCwRtAdYWiNoCSVtA0xuiCRRtAU1viPZkStMbogl4bQHSFtD0hmgCrC0QtQWStkDWFtD0hmgCVVlA1RuiCXhtAdIWCNoCrC0QtQWStoCmN0QTKNoCmt4Q7e0FTW+IJuC1BUhbQNMbogmwtkDUFkjaAllboGgLaB+G6HpDkI/q3hCiYdYbosFb7Vzd4K12rm7wVjtXN3i2DG+1c3WDt9q5usFb7Vzd4K12rm7wVr0hBN6sN0SDtxxhzXpDNHjLEdasN0SDtxxhzXpDNHjLEdasN0SDB/KGEB4kb4jGY7VzdYO32rm6wVvtXN3g2TK81c7VDd5q5+oGb7VzdYO32rm6wVvtXC3wZr0hGrzlCGvWG6LBW46wZr0hGrzlCGvWG6LBW46wZr0hGrzlCIvkDdF4gLwhGg+QN0TjAfKGaDwo0WrjAfKGaDxA3hCNB8gbovEAeUM0HiBvCOFB8oZoPJ3X++MO+o0IyhuiEUE1rGvvXUF5QzQiKG+IRgTlDdGIoLwhGhGUN0QjgvKGaERQ3hBChOUN0YigvCEaEZQ3RCOC8oZoRAxHBOUN0YigvCEaEZQ3RCOC8oZoRFDeEEKE5Q3RiKC8IRoRlDdEI4LyhmhEDEcE5Q3RiKC8IRoRlDdEI4LyhmhEUN4QH5VHUN4QH0hQ3hAfSFDeEB9IWD3YGxKUN8QHEpQ3xAcS3FEbmDfEBxKUN8QHEpQ3xAcS4yFh7UtE+hW8Nw27FbwCb7a+SODN1hcJvNn6IoFny/Bm64sE3mx9kcCbrS8SeLP1RQJvtoL3Bm+3glfgLUdYuxW8Am85wtqt4BV4yxHWbgWvwFuOsHYreAUeqYL3xgNVwSs8ZuuLBN5sfZHAm60vEni2DG+2vkjgzdYXCbzZ+iKBN1tfJPBm64tu8HYreAXecoS1W8Er8JYjrN0KXoG3HGHtVvAKvOUIa7eCV+AtR1ioCl7hQargFR6kCl7hQargFR6UaLXxIFXwCg9SBa/wIFXwCg9SBa/wIFXw3nigKniFp/N6f1LnKERYFbxChPVaobx3hVXBK0RYFbxChFXBK0RYFbxChFXBK0RYFbxChFXBeyMCq+AVIqwKXiHCquAVIqwKXiFiOCKsCl4hwqrgFSKsCl4hwqrgFSKsCt4bEVgFrxBhVfAKEVYFrxBhVfAKEcMRYVXwChFWBa8QYVXwChFWBa8QYVXwtsojrArehoRVwduQsCp4GxJcpRxaBW9DwqrgbUhwR21oFbwNCauCtyFhVfA2JMZDwtqXgvvjWR9kdhsN0xOYsm/b1fHnpfT7n3PfuItR7mqU2zur4N4qOFkFD1bB2Sp4tAqerIJbjZveauD0ViMnWY2cZDVyktXISVYjJ1mNnGQ1cpJa5NwEsrbA6UgUt/dtOPKRQFUWCE5bwGsLkLbA6R2tbIuGSzgSYG2BqC2QtAXOruTo8rdLoytHAkVboCoLsNMW8NoCZ7+mkbZLIx0KJG2Bs5OcwvaWWop0IBCdtoD2RxRPr2Tev0UxHwkUbYGqLJCctoDXFiBtgaAtwNoCUVsgaQtcuJJTOhIo2gLnV/K+2eUjgXx6Je/b9R0Bry1A2gJnV3LaSxaSq0cCrC0QtQWStkDWFji9kuvWYTl5dyRQlQWK0xbw2gKkLRC0BVhbIGoLJG2BfKHA0UouRVvg/EreXkRJdCRQT6/k/VzzjoDXFiBtgdMx+cmvzMraAlFbIGkLZG2Boi2gfRhy593mqxTY6XtDsDPsDcHOsDcEO8PeEOwMe0OwM+wNwc6wNwQ7w94Q7Ax7Q7Az7A3BzrA3BDvD3hDsDHtDsDPsDcHOsDcEO8PeEOwMe0OwM+wNwc6wNwQ7w94Q7LC8IdhheUOwM+wNwc6wNwQ7w94Q7Ax7Q7Az7A3BzrA3BDvD3hDsDHtDsDPsDcHOsDcEO8PeEAJvOcLa9YYQeMsR1q43BDvD3hACbznC2vWGYGfYG4IdljeE8CB5QwgPkjeE8CB5QwgPSrTaeJC8IdhheUOww/KGYIflDcEOyxuCHZY3BDs0bwh2aN4Q7NC8IdiheUOwQ/OGYIfmDcEOzRuCHZo3BDs0bwh2aN4Q7NC8IdiheUOwQ/OGYIfmDcEOzRuCHZo3BDs0bwh2aN4Q7NC8IdiheUOwQ/OGYIfmDcEOzRuCHZo3BDs0bwh2aN4Q7NC8IdiheUOwQ/OGYIfmDcEOzhuiIWF5QzQkLG+IhoTVg70hYXlDNCQsb4iGBHfUhuYN0ZCwvCEaEpY3RENiPCSwfSnb9Ia4cZtscX3jNtnh+sZt0xtCwE12uBZwkx2uBdxkh2sBZ6vgJjtcC7hJbwgBtxo3bXpDCLjVyGnTG0LArUZOm94QAm41ctr0hhBwq5FT1xtCBLK2gKo3hAhUZQFdbwgR8NoCpC2g6g0hAqwtELUFkraAqjeECBRtgaosoOsNIQJeW0DVG0IEkraAajvEm4CuN4QIaH9Eut4QIlC0BaqygK43hAh4bQHSFgjaAqwtELUFkraAqjeECBRtAVVvCHkypeoNIQJeW4C0BVS9IUSAtQWitkDSFsjaAqreECJQlQV0vSFEwGsLkLZA0BZgbYGoLZC0BVS9IUSgaAuoekPI2wuq3hAi4LUFSFtA1RtCBFhbIGoLJG2BrC1QtAW0D0OUvSFi0veGuGnY9YYQeLOdqwXebOdqgTfbuVrg2TK82c7VAm+2c7XAm+1cLfBmO1cLvFlviBu8XW8IgbccYe16Qwi85Qhr1xtC4C1HWLveEAJvOcLa9YYQeCRviBsPlDeE8JjtXC3wZjtXC7zZztUCz5bhzXauFniznasF3mznaoE327la4M12rr7B2/WGEHjLEdauN4TAW46wdr0hBN5yhLXrDSHwliOsXW8IgbccYaG8IYQHyRtCeJC8IYQHyRtCeFCi1caD5A0hPEjeEMKD5A0hPEjeEMKD5A1x44HyhhCezuv9SQd9IcLyhhAirIZ18t4VljeEEGF5QwgRljeEEGF5QwgRljeEEGF5QwgRljfEjQjMG0KIsLwhhAjLG0KIsLwhhIjhiLC8IYQIyxtCiLC8IYQIyxtCiLC8IW5EYN4QQoTlDSFEWN4QQoTlDSFEDEeE5Q0hRFjeEEKE5Q0hRFjeEEKE5Q3RKo+wvCEaEpY3REPC8oZoSFg92BsSljdEQ8LyhmhIcEdtaN4QDQnLG6IhYXlDNCTGQ8Lal1LQr+C9adit4BV4s/VFAm+2vkjgzdYXCTxbhjdbXyTwZuuLBN5sfZHAm60vEnizFbw3eLsVvAJvOcLareAVeMsR1m4Fr8BbjrB2K3gF3nKEtVvBK/BIFbw3HqgKXuExW18k8GbriwTebH2RwLNleLP1RQJvtr5I4M3WFwm82foigTdbX3SDt1vBK/CWI6zdCl6Btxxh7VbwCrzlCGu3glfgLUdYuxW8Am85wkJV8AoPUgWv8CBV8AoPUgWv8KBEq40HqYJXeJAqeIUHqYJXeJAqeIUHqYL3xgNVwSs8ndf7kzpHIcKq4BUirNcK5b0rrApeIcKq4BUirApeIcKq4BUirApeIcKq4BUirAreGxFYBa8QYVXwChFWBa8QYVXwChHDEWFV8AoRVgWvEGFV8AoRVgWvEGFV8N6IwCp4hQirgleIsCp4hQirgleIGI4Iq4JXiLAqeIUIq4JXiLAqeIUIq4K3VR5hVfA2JKwK3oaEVcHbkOAq5dAqeBsSVgVvQ4I7akOr4G1IWBW8DQmrgrchMR4S1r6U450K3sh5uy2m/Fjjure8bzgFC6di4dwphX4fjwfjITCeAMbDYDwRjCeB8YDtzh5se/Zg+zOB7c8Etj8T2P5MYPszge3PBLY/k+L+vElkfYnzu+h1r4wKT8XiCQ6Mx4PxEBhPAONhMJ4IxpPAeDIYD9j+HMD2Zwbbnxlsf2aw/ZnB9mcG258ZbH9msP2ZFffnTaLoS1R1iej0Jby+BOlLBH0J1peI+hJJX0J/dafzX9onL9eLCPUQOT/lzx/JpdphJNn1EOkx8ZkvEHn4gruIxB4iqYdI7iFSeohcsU4eviUrD6RdDxHfQ4R6iIQeItxDJPYQST1Ecg+R0kPkghX/+K1PeefD9RDxPUSoh0joIcI9RGIPkdRDJPcQuWDFP36TV0RqB5F773lfrRI6/HjwjruoxC4qqYtK7aFywbt7v0XFd1GhLir66yUfv/+a97tyfnJ8ym57G5fpycu4Zd8hquNfv5yz/v5D2Xz8oqwB7mqU+3j5WgD3VsHJKniwCs5WwaNV8GQV3Grc9FYDp7caOclq5CSrkZOsRk6yGjnJauQkq5GT1CLnJpC1BU5Horg9GeXIRwJVWSA4bQGvLUDaAqd3tLItGi7hSIC1BaK2QNIWOLuSo9tOnKIrRwJFW6AqC7DTFvDaAme/ppG2SyMdCiRtgbOTnML2wkSKdCAQnbaA9kcUT6/k/ew4xnwkULQFqrJActoCXluAtAWCtgBrC0RtgaQtcOFKTulIoGgLnF/J+2aXjwTy6ZW8b9d3BLy2AGkLnF3JaX+5NLl6JMDaAlFbIGkLZG2B0yu5xk3AuyOBqixQnLaA1xYgbYGgLcDaAlFbIGkL5AsFjlZyKdoC51fy9tJboiOBenol7+eadwS8tgBpC5yOyU9+ZVbWFojaAklbIGsLFG0B7cOQO+98XqVQ7rxZ9jtbPbptv/Ps/YGGRzGh/92PcMq9N5OswJNl+GAZni3DR8vwyTJ8tgxfLMNXw/BkOcKS5QhLliMsWY6wZDnCkuUIS5YjLFmOsGQ5whJKhP3GE1CC5saDYkL/yuQGFMf6l+BR7O1fgmfL8NEyfLIMny3DF8vw1TA8O8vwliMsW46wbDnCsuUIy5YjLFuOsGw5wrLlCMuWI2xEibAbD0rQ3HhQ4uDGgxLaNh6UaLXxoASgjQclpmw8KGFi40HZ+TcelM38G08C259T5/X+pNdxuVf48VYiLMPmcq+s4Z2fUSY4ogBH1Nse/XF76XKvsOGtRAWOqKIRFQdH1H0/ethGudyr5ngrUYAjYjiiCEeU4IgyHFGBI6poRNXBEfXesx932y736nbeShTgiBiOKMIRJTiiDEdU4IgqGtG9nvmKSA8b7Dckj4dEeEgR7cTmXp//tyJlPCS4ozbfu4TvtyARHlLAQ2I8JKx9qbJNb4gbt8kW1zdukx2ub9w2vSEE3GSHawE32eFawE12uBZwtgpussO1gJv0hhBwq3HTpjeEgFuNnDa9IQTcauS06Q0h4FYjp01vCAG3Gjl1vSFEIGsLqHpDiEBVFtD1hhABry1A2gKq3hAiwNoCUVsgaQuoekOIQNEWqMoCut4QIuC1BVS9IUQgaQuotkO8Ceh6Q4iA9kek6w0hAkVboCoL6HpDiIDXFiBtgaAtwNoCUVsgaQuoekOIQNEWUPWGkCdTqt4QIuC1BUhbQNUbQgRYWyBqCyRtgawtoOoNIQJVWUDXG0IEvLYAaQsEbQHWFojaAklbQNUbQgSKtoCqN4S8vaDqDSECXluAtAVUvSFEgLUForZA0hbI2gJFW0D7METXGyK4oO4NIRpmvSEavNXO1Q3eaufqBm+1c3WDZ8vwVjtXN3irnasbvNXO1Q3eaufqBm/VG0LgzXpDNHjLEdasN0SDtxxhzXpDNHjLEdasN0SDtxxhzXpDNHggbwjhQfKGaDxWO1c3eKudqxu81c7VDZ4tw1vtXN3grXaubvBWO1c3eKudqxu81c7VAm/WG6LBW46wZr0hGrzlCGvWG6LBW46wZr0hGrzlCGvWG6LBW46wSN4QjQfIG6LxAHlDNB4gb4jGgxKtNh4gb4jGA+QN0XiAvCEaD5A3ROMB8oYQHiRviMbTeb0/7qDfiKC8IRoRVMO69t4VlDdEI4LyhmhEUN4QjQjKG6IRQXlDNCIob4hGBOUNIURY3hCNCMobohFBeUM0IihviEbEcERQ3hCNCMobohFBeUM0IihviEYE5Q0hRFjeEI0IyhuiEUF5QzQiKG+IRsRwRFDeEI0IyhuiEUF5QzQiKG+IRgTlDfFReQTlDfGBBOUN8YEE5Q3xgQTVg/0DCcob4gMJyhviAwnuqA3MG+IDCcob4gMJyhviA4nxkLD2Je/0K3hvGnYreAXebH2RwJutLxJ4s/VFAs+W4c3WFwm82foigTdbXyTwZuuLBN5sBe8N3m4Fr8BbjrB2K3gF3nKEtVvBK/CWI6zdCl6Btxxh7VbwCjxSBe+NB6qCV3jM1hcJvNn6IoE3W18k8GwZ3mx9kcCbrS8SeLP1RQJvtr5I4M3WF93g7VbwCrzlCGu3glfgLUdYuxW8Am85wtqt4BV4yxHWbgWvwFuOsFAVvMKDVMErPEgVvMKDVMErPCjRauNBquAVHqQKXuFBquAVHqQKXuFBquC98UBV8ApP5/X+pM5RiLAqeIUI67VCee8Kq4JXiLAqeIUIq4JXiLAqeIUIq4JXiLAqeIUIq4L3RgRWwStEWBW8QoRVwStEWBW8QsRwRFgVvEKEVcErRFgVvEKEVcErRFgVvDcisApeIcKq4BUirApeIcKq4BUihiPCquAVIqwKXiHCquAVIqwKXiHCquBtlUdYFbwNCauCtyFhVfA2JLhKObQK3oaEVcHbkOCO2tAqeBsSVgVvQ8Kq4G1IjIcEti+VP571QWa30TA9gSn7tl0df15KLzznLn8sRrmrUW7vrIJ7q+BkFTxYBWer4NEqeLIKbjVuequB01uNnGQ1cpLVyElWIydZjZxkNXKS1chJapFzE8jaAqcjUdzet+HIRwJVWSA4bQGvLUDaAqd3tLItGi7hSIC1BaK2QNIWOLuSo8vfLo2uHAkUbYGqLMBOW8BrC5z9mkbaLo10KJC0Bc5OcgrbW2op0oFAdNoC2h9RPL2Sef8WxXwkULQFqrJActoCXluAtAWCtgBrC0RtgaQtcOFKTulIoGgLnF/J+2aXjwTy6ZW8b9d3BLy2AGkLnF3JaS9ZSK4eCbC2QNQWSNoCWVvg9EquW4fl5N2RQFUWKE5bwGsLkLZA0BZgbYGoLZC0BfKFAkcruRRtgfMreXsRJdGRQD29kvdzzTsCXluAtAVOx+QnvzIrawtEbYGkLZC1BYq2gPZhyJ13m69SoKLvDUHFsDcEFcPeEFQMe0NQMewNQcWwNwQVw94QVAx7Q1Ax7A1BxbA3BBXD3hBUDHtDUDHsDUHFsDcEFcPeEFQMe0NQMewNQcWwNwQVw94QVAx7Q1DB8oagguUNQcWwNwQVw94QVAx7Q1Ax7A1BxbA3BBXD3hBUDHtDUDHsDUHFsDcEFcPeEFQMe0MIvOUIa9cbQuAtR1i73hBUDHtDCLzlCGvXG4KKYW8IKljeEMKD5A0hPEjeEMKD5A0hPCjRauNB8oagguUNQQXLG4IKljcEFSxvCCpY3hBU0LwhqKB5Q1BB84agguYNQQXNG4IKmjcEFTRvCCpo3hBU0LwhqKB5Q1BB84agguYNQQXNG4IKmjcEFTRvCCpo3hBU0LwhqKB5Q1BB84agguYNQQXNG4IKmjcEFTRvCCpo3hBU0LwhqKB5Q1BB84agguYNQQXNG4IKmjcEFThviIaE5Q3RkLC8IRoSVg/2hoTlDdGQsLwhGhLcURuaN0RDwvKGaEhY3hANifGQsPalEG16Q9y4Tba4vnGb7HB947bpDSHgJjtcC7jJDtcCbrLDtYCzVXCTHa4F3KQ3hIBbjZs2vSEE3GrktOkNIeBWI6dNbwgBtxo5bXpDCLjVyKnrDSECWVtA1RtCBKqygK43hAh4bQHSFlD1hhAB1haI2gJJW0DVG0IEirZAVRbQ9YYQAa8toOoNIQJJW0C1HeJNQNcbQgS0PyJdbwgRKNoCVVlA1xtCBLy2AGkLBG0B1haI2gJJW0DVG0IEiraAqjeEPJlS9YYQAa8tQNoCqt4QIsDaAlFbIGkLZG0BVW8IEajKArreECLgtQVIWyBoC7C2QNQWSNoCqt4QIlC0BVS9IeTtBVVvCBHw2gKkLaDqDSECrC0QtQWStkDWFijaAtqHIcreEMz63hA3DbveEAJvtnO1wJvtXC3wZjtXCzxbhjfbuVrgzXauFniznasF3mznaoE36w1xg7frDSHwliOsXW8IgbccYe16Qwi85Qhr1xtC4C1HWLveEAKP5A1x44HyhhAes52rBd5s52qBN9u5WuDZMrzZztUCb7ZztcCb7Vwt8GY7Vwu82c7VN3i73hACbznC2vWGEHjLEdauN4TAW46wdr0hBN5yhLXrDSHwliMslDeE8CB5QwgPkjeE8CB5QwgPSrTaeJC8IYQHyRtCeJC8IYQHyRtCeJC8IW48UN4QwtN5vT/poC9EWN4QQoTVsE7eu8LyhhAiLG8IIcLyhhAiLG8IIcLyhhAiLG8IIcLyhrgRgXlDCBGWN4QQYXlDCBGWN4QQMRwRljeEEGF5QwgRljeEEGF5QwgRljfEjQjMG0KIsLwhhAjLG0KIsLwhhIjhiLC8IYQIyxtCiLC8IYQIyxtCiLC8IVrlEZY3REPC8oZoSFjeEA0Jqwd7Q8LyhmhIWN4QDQnuqA3NG6IhYXlDNCQsb4iGxHhIWPtS9PoVvDcNuxW8Am+2vkjgzdYXCbzZ+iKBZ8vwZuuLBN5sfZHAm60vEniz9UUCb7aC9wZvt4JX4C1HWLsVvAJvOcLareAVeMsR1m4Fr8BbjrB2K3gFHqmC98YDVcErPGbriwTebH2RwJutLxJ4tgxvtr5I4M3WFwm82foigTdbXyTwZuuLbvB2K3gF3nKEtVvBK/CWI6zdCl6Btxxh7VbwCrzlCGu3glfgLUdYqApe4UGq4BUepApe4UGq4BUelGi18SBV8AoPUgWv8CBV8AoPUgWv8CBV8N54oCp4hafzen9S5yhEWBW8QoT1WqG8d4VVwStEWBW8QoRVwStEWBW8QoRVwStEWBW8QoRVwXsjAqvgFSKsCl4hwqrgFSKsCl4hYjgirApeIcKq4BUirApeIcKq4BUirAreGxFYBa8QYVXwChFWBa8QYVXwChHDEWFV8AoRVgWvEGFV8AoRVgWvEGFV8LbKI6wK3oaEVcHbkLAqeBsSXKUcWgVvQ8Kq4G1IcEdtaBW8DQmrgrchYVXwNiTGQ4Lal9KDGs+83VY/JXL69V9u//L/f/yvn37817/8+W+3G+S//ffP//bLT3/9+du//vI///nxX27X/i8="},{"name":"get_portal_address_public","is_unconstrained":true,"custom_attributes":["aztec(public)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/9VY3W7aMBROGLS0QIDyU0p7kUdIuq7d7ujFbjdpe4AqLcmERJsp0IlN2h5gk/bIaDj40A/vqDXCidojRT527PN9/uKcxLatpRUWly39ErSpRn0GsvS2M99gLC9LnrZBnjbwLBDZIjYok0C/AH3w/k/wj2R5mSTBd3d0Nwxnbnw/dePIvY7v74YTHPgb/GNZ3gTjsTuN3WAyCZPp1W0wu7oeTa8mox/hCvSvLMsw3jWl0lvv9Q4EV1diulrlvVW5uCrYV7aLtlfWet/dh9vLMQpOE9povvuLqyH94Nvtx6838TC8HA6TcLKmJz1IbJtb/5tuvNIG8XpqvA/34/EoGoXJ+9loMl2Lu8PEFVMuMHNBHgWGx1yOLUKcgfS97Sx980rApwzcEW9P+q457EisjV1r3Wyl7oK/B3zK5vn4Gc3TE3H3jT+7s5DeSdRqV9HKgT7IoZKBfjbgUmyqVxhsc1qcRwK7qqFFleFTzVmLKoNtTouLM4Fd09CixvCp5axFjcE2p8Vp+jfgaGjhMHycnLVwGGyD78g7gV3X0KLO8KnnrEWdwTaoRZo7GxpaNBg+jZy1ILxNOTsvkHP1BXJ+DjqXFd8M9nmK3dTQosnwaeasRZPBNqjFjcA+0NDigOFzkLMWhLcpZ+cZcC4rvhnsi0BgtzS0aDF8Wjlr0WKwDa7lNwK7raFFm+HTzlmLNoNtUIv0f7mjoUWH4dPJWQvCE3tz2rcnmfLxvYrCR5it1F3wiUMFfNy7d6U/sMztsfH5dAHr0Lgey+ejrheqH2aLHYm4RxnMScTtm4+b7r/o3LMkY/cZrU6kb/Ak2EdsW16EQ+1F8GPoS/1ID8oHxF3sE+k88OSRcR1lnAN9ejCur4yjOj1roV0o/azWls66Fv933L8nnRnOzfE5LVsPOc5g3HSt98zr54t817XW7bE82QP9sviOiPM++latzqw/T+Mk+BJ+CoOhDRy7Cl8s1bNxquNZ9Q74OmfZGeQwL6Mc5nM5jPgTHuaRX7LEPSQZxiKepD3FxNxyDFrSGukpWh5DfbDlnCNpqOUmcaMnDHP9Fnx9tUHVinzMx0/d5/r2YUxX6TdX6uIbof6DFOH+H1ly6wJzRw/aCko8kXv/AUZNxYhWHgAA","debug_symbols":"7dvdSiNBEIbhe5njsPRfdXV5K8uyRI1LICRi4sISvPedaCZRbMyBvM6MyZGM+SyrCx5soWbb3M6uH//8ni/vVuvm6ue2Waxuppv5atk+bRv3ozx/c30/Xe6e15vpw6a5cpNmtrxtvz5Nmrv5YtZcJXuavItZjvugFTlEi1aiyRfdZ5O3fAj7KJV0Dsn26RyyvEn/mrRd2ye69i51Se9y+NK+vfvMuM2OfceP+/bepy7s1Z3oW9PhlCrRVfr2SN8vtQNYO4K1E1hbwNoZrK1g7QLWNq52cGBt0GUAXQbQZQBdBtBlAF0G0GUAXQbQZQRdRtBlBF1G0GUEXUbQZQRdRtBlBF1G0GUCXSbQZQJdJtBlAl0m0GUCXSbQZQJdJtClgC4FdCmgSwFdCuhSQJcCuhTQpYAuBXSZQZcZdJlBlxl0mUGXGXSZQZcZdJlBlxl0qaBLBV0q6FJBlwq6VNClgi4VdKmgSwVdFtBlAV0W0GUBXRbQZQFdFtBlAV0W0GUBXRro0kCXBro00KWBLg10aaBLA10a6NJAl945sji5WeDI1QJH7ha4RBYntwscuV7gyP0CRy4YOFKoJ4Wiuz/o8g+6/VNf//FJffdj4vTjX+E15i6s5dXalXeVtMTUpSUWf0xXV7okOOnSIZ5KF/HdaYtIbXGtvpH0fY+bz+u4el7HLed1XDur49YX7r7vcf2XHzf643HDiQNo6UqrHdsPGrv2w7jbj+NuP427fRl3+3nc7eu42y/Dbv/wdo2+evFk137ln5XY/ZGwbCeyKuVQNx2zoZuKXabyfirRXaZSmcrArx49TWXgN5qepjLwi1JPU0mXqVSmMvBrXU9TGfhtsaepDPwS2tNULnfbt1NpH/5OH+bT68Vs9+b77rPH5U33Inz7uPl3//JJm/0P"},{"name":"get_token","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(view)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"}],"return_type":{"abi_type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/+2cXU/bMBSGEygQljRtaWEtnwHGdtuurN3uuovdbtJ2M2lX3ZpOaB+dCkzbn0fDwQdOvaPIEcdWLGGp6klqn/fxG8dNgqnv3ZSl65cv4xW0Ty1QZyTfu/crPcZcXZOcPiOnjziXALaCdyidwDE+UPjzFG105Pvr+Xz8Nzn7OUn/JLPLi2Q2TT7PLn9Ozm9bfpNBgDIlXF192e2vouTqcMp6Ij+7fb9+hbiu3C/2LXuLddfuPr5po+g00D7o76PrV13G498/3v36MpukryeTeXp+jt2Eo4H3XXn/F918KwXytdV8by+/fz+bnqXzN3/Ozi8W8q4SeUWXl4i+YI4lguNKtq2gPCMZd+9XstNnBfEEiB3rrcs44dOeirGx5i0WX9lOULyOeAJ+np6hfnZF3kfsx+40hXMSe7WmeBWjOpghNOCfj3QhN2yHhDafF4Op0I40vIgInsiyFxGhzefF8FRoVzW8qBI8VcteVAltPi+eZ1/psYYXMcETW/YiJrQZz5FXQrum4UWN4KlZ9qJGaDN6kc2ddQ0v6gRP3bIXoFeUOXaQOXKQuQw+B0rMoz3ItBsaXjQInoZlLxqENqMXX4T2hoYXGwTPhmUvQK8oc1wC5kCJebSHY6Hd1PCiSfA0LXvRJLQZx/ILod3S8KJF8LQse9EitBm9yK6XNzW82CR4Ni17AXri3hzu2+dGeXrdUOERxVe2ExQDQ4hifO++JeORx3ePjY/PFtJ6zO7HzfFRxwtsPzarPRV5Owb6JPJu8+fN7r92ZK4VmXub8GpXxoyPc3tY25cv0IH9FRTPUF2oB37AfADs4j4Rngfu5rTbVNrFqE4btdtW2sE2HGvhXSpjU2NLZ1yL6zvq2hM/Rx3x8GTHDz+LFNvLyA/Q5n9m18/mvC1vseTNeXh+M/GdYPLZJD4PefKeDoRXbcWrLcWrGNXBDG0D/uV9p7YJbcbrzuxaq6PhRYfgMTHX53kBekWZayVgDpSYR3vQp+ZnyottgsfAd2quF6BXlDlykDl2kDl0kLnmIHO1BMyBEvNoD4b4ujbPix2CZ8eyF/j6uwhz00HmqATMgRLzaL+YUvc2lBe7BM+uZS/y7sfymCMHmcMSMAdKzKM9+Cy09zS82CN49ix7AXpFmZsOMtccZK46yNxxkLnuIPPDeLbDHDrI7OLYaJSAOVBiHu1htoZpX8OLfYJn37IXoFeUuVoC5kCJebQHz4X2gYYXBwTPgWUvQK8oc9NB5qqDzB0HmesOMjcemK0wuzhvtBxkLsNcFygxj/Yw+1tVouFFQvAklr0AvaLMkYPMdQeZXfQ5dpC54yCzi+O58cBshXmvBMxivRisHfvkm+Tp94quj4U4RPE68uxQxiOPd30saB0irSN2P26OT6L0F7aPjGr3s/VsTwz0SeQ94c+brY99KnPB+tgTwqtnMvaZj9NTlNdHOrC/guKP/l1dqAd+wHwA7OIa+1jGmF1tlyjtYlTnGLU7UdrBNhxr4d1bdJ6bGFs64xqvj+15dzywbvXK4x2TJs5fMS+teoslbz7D4/TQAI/4v3W4z7z97YUPF7P5+Gv6Ph1PfMSo/u4Cfsd9uPIWf7kDyjIR5/0mwzF/f43NYfg8grkG+EGvgupMpUH4fyGhUOckeA85xRwAYwPqirEFY+QI7QOP4TNxDv0DWhsBZwNHAAA=","debug_symbols":"5ZzdalNBFEbfJddFZr49v30VEYlapVBSsVWQ4rt7qklUPFgW8hXSXpU0s4czXayb1eHcbd5dvPn84fXl7v31zeb85d3m6vrt9vbyerd8utukF+PHL28+bnf3n29ut59uN+fpbHOxe7f8/Ha2eX95dbE5L/Pb2V/LZov9wjnqcenoK0tLHn2/tuTZjotz1JXVTWXuVze1+sfqV2fLU8//eOqcymFlTk2P+tw5/c+fe85fzx3/fu6cczkszj098Ny9HE/Za6SV586W5/65t4x7h3HvYty7Gvduxr27ce9h3Hv69lYy7m30UkYvZfRSRi9l9FJGL2X0UkYvZfQyjF6G0cswehlGL8PoZRi9DKOXYfQyjF6G0cti9LIYvSxGL4vRy2L0shi9LEYvi9HLYvSyGL2sRi+r0ctq9LIavaxGL6vRy2r0shq9rEYvq9HLZvSyGb1sRi+b0ctm9LIZvWxGL5vRy2b0shm97EYvu9HLbvSyG73sRi+70ctu9LIbvexGL7vRy2H0chi9HEYvh9HLYfRyGL0cRi+H0cth9HIYvZxGL6fRy2n0chq9nEYvp9HLafRyGr2cRi+n0cucknNz582C5LxakJx3C1Jxbu68XZCc1wuS835Bcl4wSE5Ds9NQ690f6+Uf6+0fcP1nP1DpQKMDnQ4MOjDhALj8sh/IdEB0IOgAJS1KWpS0KGlR0qKkg5IOSjoo6aCkg5IOSjoo6aCkg5IOSrpQ0oWSLpR0oaQLJV0o6UJJF0q6UNKFkq6UdKWkKyVdKelKSVdKulLSlZKulHSlpBsl3SjpRkk3SrpR0o2SbpR0o6QbJd0o6U5Jd0q6U9Kdku6UdKekOyXdKelOSXdKelDSg5IelPSgpAclPSjpQUkPSnpQ0oOSnpT0pKQnJT0p6UlJT0p6UtKTkp6U9ISklRIdyHRAdCDoQKEDlQ40OtDpwKADlHSmpDMlnSnpTEnTRibayEQbmWgjE21koo1MtJGJNjLRRibayEQbmWgjE21koo1MtJGJNjLRRibayEQbmWgjE21koo1MtJGJNjLRRibayEQbmWgjE21koo1MtJGJNjLRRibayEQbmWgjE21koo1MtJGJNjLRRibayEQbmWgjE21koo1MtJGJNjLRRibayEQbmWgjE21koo1MtJGJNjLRRibayEQbmWgjE21koo1MtJGJNjLRRibayEQbmWgjE21koo1MtJGJNjLRRibayEQbmWgjE21koo1MtJGJNjLRRibayEQbmWgjE21koo0saCML2siCNrKgjSxoIwvayII2sqCNLGgjC9rIgjayoI0saCML2siCNrKgjSxoIwvayII2sqCNLGgjC9rIgjayoI0saCML2siCNrKgjSxoIwvayII2sqCNLGgjC9rIgjayoI0saCML2siCNrKgjSxoIwvayII2sqCNLGgjC9rIgjayWG9kdY6xn2kpjd/H1l6R2Q/vg8xZ+bg4a+3tkXV5xv3qGuO31avvmqzLv/MOq5e+/cDqUfPhGvaodeWNmrFe+J7uceezOu56XX26x83P67h6XseNRz9u5F/H1QMHyHkeHiQr9ePqJSUeDlBO/QD11A/QTv0A/dQPME79APN0D7B8+rL9dLl9c3Vx//76+y8/794eXme/fLz9+vHnN8va7w=="},{"name":"compute_note_hash_and_optionally_a_nullifier","is_unconstrained":true,"custom_attributes":[],"abi":{"parameters":[{"name":"contract_address","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"nonce","type":{"kind":"field"},"visibility":"private"},{"name":"storage_slot","type":{"kind":"field"},"visibility":"private"},{"name":"note_type_id","type":{"kind":"field"},"visibility":"private"},{"name":"compute_nullifier","type":{"kind":"boolean"},"visibility":"private"},{"name":"serialized_note","type":{"kind":"array","length":0,"type":{"kind":"field"}},"visibility":"private"}],"return_type":{"abi_type":{"kind":"array","length":4,"type":{"kind":"field"}},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/+2b3U7bQBCF18GhBoOb2HGckEAIBaTehRSScMfLtM/d60p9haqss6Mclmm0UcdLVool5LG9O+ebsz+EyERqfSSvP5GJ2+Z8rN4f1ObFnGf/dzwI5po1yRkFwtkKhPMoEM5YkDNiOPU5NrFed3rNfVLr9fjuIXbWA30Ez9W2RLZqYgJ8eC1V6Wr2fAzJEVwZ8Ng8o7PGSc0zBEtNkXUbuEeFtuAe6RzBPdrBSCcxpgjX+5RskOXyvs4+XcOJyUXcKcT4bAzWxQ3V2Jav8bGRMXn1rqExqVcx+d42uRO4pjE4NbHgb44H1I7Mz6k1F2KIR9CW2pEfLWDVx7narJfTLf1iq18GbY6hn7230DWNtfaqa2J9btOeAPkb8HCm86byed+MTWx5l0JNGXgioz1f6fxn6u0RWdfXEGfAcy7Os1578nWux+4zsMvkfXrUXnUsr84srzJogwydBvyLQJdy03WH0ZbzYrHS2l0HL7oMT9ezF11GW9CLZ62dO3iRMzy5Zy9yRlvOi+U3rV04eFEwPIVnLwpGW86Lef0ZoOfgRY/h6Xn2osdoC66Rel6UDl6UDE/p2YuS0Rb04ofW7jt40Wd4+p696DPagl5819qVgxcVw1N59qJitAX3zvrzxcDBiwHDM/DsxYDRFvRirrWHDl4MGZ6hZy+GjLbgGqm1Lxy8uGB4Ljx7QXq7MvcCZK4CZC72gDmxYhntRb1/jhy8GDE8I89e4HcuuzCXe8CcWLGM9uJJa48dvBgzPGPPXpDersx5gMxFgMz9AJnLAJmrAJn3YT4nViyjvaz30EsHLy4ZnkvPXpDersx5gMyjAJmLPWBOrFhGe1l/N3fl4MUVw3Pl2QvS25V5ECBzdw+YEyuW0V4utPbEwYsJwzPx7AXp7co8DJC5CpB5FCBzESBzP0DmMkDmwxr0w5zvATO+e/S7UZ75c2rxkGfKYlQWYwpxBozU9kXJva+SWbWT1lTcj/X42POFrqeNas9XOu+XBmrSeW/l89Z/I9yZXPQO3y3j1b2JI+FxuoO8EejQ/RjiX9CW2pEftB8Qu36X68bE91v6Tax+GbS5gX63Vj+6prHW3v00cVNzy2Ved9RmLX8Fngb2wUd8J1eBV8pipGMCPNfyPA8N1TnDd/j+KNm1N7W8OrG8yqAN7tEftW8emA/M/2LGzxMncA956F7LqgX/v2EKOf4CARQXTpY1AAA=","debug_symbols":"ndpRattAGIXRveg5FN/foxkpWymlOIlTDMEJiVMoJnuv3ZIF5LxpJN237+kw5+lhf/f+6+fh+Pj8Nt1+P09Pz/e70+H5eDmdp823Wv69fXvZHa8v3k6719N0u+3jZtofHy5Poz5upsfD0366bevHj5vrZv36ZruBTWBTsNnCpsFmhk2HzYANdLCFDhp00KCDBh006KBBBw06aNBBgw4adNCggxk6mKGDGTqYoYMZOpihgxk6mKGDGTqYoYMOHXTooEMHHTro0EGHDjp00KGDDh106GBABwM6GNDBgA4GdDCggwEdDOhgQAcDOliggwU6WKCDBTpYoIMFOliggwU6WKCDBTpYoYMVOlihgxU6WKGDFTpYoYMVOlihgxU6yGYjo8ioZLSVUZPRLKMuoyGjRUZSRKSISBGRIiJFRIqIFBEpIlJEpIhIESVFlBRRUkRJESVFlBRRUkRJEYKNEW2McGPEGyPgGBHHCDlGzDGCjhF1jLBjxB0j8BiRxwg9Ruwxgo8RfYzwY8QfIwAZEcgIQUYMMoKQEYWMMGTEISMQGZHICEVGLDKCkRGNjHBkxCMjIBkRyQhJRkwygpIRlYywZMQlIzAZkckITUZsMoKTEZ2M8GTEJyNAGRHKCFFGjDKClBGljDBlxCkjUBmRyghVRqwygpURrYxwZcQrI2AZEcsIWUbMssQsS8yyxCxLzLLELEvMssQsS8yyxCxLzLLELEvMssQsS8yyxCxLzLLELEvMssQsS8yyxCxLzLLELEvMssQsS8yyxCxLzLLogqSYZYlZlphliVmWmGWJWZaYZX3VLC+H37vXw+7uaX+9Cnv99n68/7wZezme/rz8/3L59y8="},{"name":"constructor","is_unconstrained":true,"custom_attributes":["aztec(public)","aztec(initializer)"],"abi":{"parameters":[{"name":"inputs","type":{"kind":"struct","path":"aztec::context::inputs::public_context_inputs::PublicContextInputs","fields":[{"name":"args_hash","type":{"kind":"field"}},{"name":"is_static_call","type":{"kind":"boolean"}}]},"visibility":"private"},{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"},{"name":"portal_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"5Z3dbhtHEoXfRdfGYrr+utqvsggWSuIsBBhyECsLLIy8+9KrGZKCx+oInFOerrkKFLdr6tD6OEXqY+nL3a8ffv7z3/96ePzt0+e79//8cvfx0y/3Tw+fHk9ffbmb/tH+/z8//37/+PXrz0/3fzzdvZ/e3X14/PX037/e3f328PHD3Xtpf/307nS8TG88X954nt54nt94Xt54Xt943t54vv7t8+++OVaq1flkqd7Oh72uHJbiy2Epzc6HC+vKaSNp82kj0xennxv3Wxr3spwsLvJ644WEl8Pkl8arrxx2LfNZb3R99LnpNmDTNI3YdBmxaRqxaY5rmsul6XpT0zJi0zpi0zZi03UHTT934rvppO2lE55200nZTSe0m072cD947mQPT/LPncQ9c/Oky2Eu/vqTINVlIufp0gTXuWkbsem6z6ZpGbdIrl7M1PnFDPuQXbcRu5ZpyK7LkF3TkF3zkF3LPrvW5SzVstL1Tu+Mna53emvsdL3Te2On653eGztd7/Te+HrXutN7Y6frnd4bO13v9N7Y6Trw3kjnHy4wf/uaSmU3nQQ+r7ZzJyKdt22L2vIjlGLl0sbp5zBz3z5o322XfZ9+Ara8pVjoBTkrZ88vYr3wt5TZlD5hSZ+Q0ifk9AklfUJNn9DSJ9zn/LFlwn1OKlsmTD/T1PQzTU0/09T0M01NP9NUSZ8w/UxT0880Nf1MU9PPNDX9TOPpZxpPP9N4+pnG0880LukTpp9pPP1M4+lnGk8/03j6maaln2la+pmmpZ9pWvqZpkn6hOlnmpZ+pmnpZ5qWfqZp6WeaMo1/u1Ch+azKasTx7xfdiOM/2aj6EtHqWsTxn226Ecd/uulFLOO/hupGHP9FVDfi+K+iuhHHvy9asfmsMa1FHP++2I04/gupbsTxX0l1I44/3XQjjj/ddCOOP930ItL400034vjTTTfi+NNNN2L+6SZwkdUPi5h/uqGdTjfffVdtrTAvLzUK69UnR5dP7RXa6XyzbcidTjjbhtzpjLNpSN7plLNtyJ3OOduG3Omks23Inc46bwkp07kLuT59CSlHCLnTeWfbkAkmnn7IBBNPP2SCiacfMsHE0w0pCSYeqedVN+K+FjLBxNMPmWDi6YfMMPF0Q8oRQmaYeLohM0w83ZAJJh4lWQrr1bavq5AJJp5+yAQTTzekJph4+iETTDz9kAkmnn7IBBNPP6QkCNmWn/cUm9payAQTTz9kgomnHzLDxNMNmWHi6YbMMPH0Qu51s+i2IUebeOa2R5th5rZHm0rmtmXMtkebHOa2R5sF5rZHu7s/t51gP1jvs2AJFoR1Iyb4LFgvYoLPgnUiJtgR1o2Y4LNgvYgJPgvWi5j/M9IJ9oR1I45vS3cj5p9uEqwKU1+a0KZrERNMN72ICaabTsQE28K6ERNMN/US0dYiJphuehETTDe9iJI/YoLpphcxwXTTi5h/j0+CrWHdiOn3+NCUfo8PTen3+NCUfo8PZdhv14so+SMmmG56ERNMN72I6acbyr+lkPJvKaT8Wwop/5ZCyr+lkBJsKexGlPwR8083CbYUdiPmn24SbCnsRsw/3STYUtiNmH+6SbClsBsx/3STYEthN2L+6WavWwq3jJh/utnrhsItI+afbva6nXDLiPmnm71uJtwyYv7pZq9bCbeMmH+62W51jfLrEast8m+tF+GQ69KI76WRtpNGtlvTcmsjN92S2nT+zm6krzciwktZEbn6kDOv7hdXXvq20/f5i9Nz57fdaWo7d361fXa1c/LK82HyVl8/7OeFUt4uTwzEtrTNcW3Lcpja1UO4erhJW7aYNNXrXYq0NC6jNq6jNm6jNl5HbdxHbbwN2viN2zt+YONl1MZp1MZHvXPeuJfjBzY+6p3TRr1z2qh3Thv1zmk33TmbLeVpulrctOxtojpBqxdodYJWZ2h1gVZXaHWDVq/Q6g6tDmXVoaw6lFWHsupQVh3KqkNZdSirDmXVoaw6lNUGZbVBWW1QVhuU1QZltUFZbVBWG5TVBmW1IVnlaYJWL9DqBK3O0OoCra7Q6gatXqHVHVodymqBslqgrBYoqwXKaoGyWqCsFiirBcpqgbJaoKwSlFWCskpQVgnKKkFZJSirBGWVoKwSlFWCsspQVhnKKkNZZSirDGWVoawylFWGsspQVhnKqkBZFSirAmVVoKwKlFWBsipQVgXKqkBZFSirCmVVoawqlFWFsqpQVhXKqkJZVSirCmVVoawalFWDsmpQVg3KqkFZNSirBmXVoKwalFWot8RQb4mh3hJDvSWGeksM9ZYY6i0x1FtiqLfEUG+Jod4SQ70lhnpLDPWWGOotMdRbYqi3xFBviaHeEkO9JYZ6Swz1lhjqLTHUW2Kot8RQb4mh3hJDvSWGeksM9ZYY6i0J1FsSqLckUG9JoN6STAKtrtDqBq1eodUdWh3KKtRbEqi3JFBvSaDekkC9JYF6SwL1lgTqLQnUWxKotyRQb0mg3pJAvSWBeksC9ZYE6i0J1FsSqLckUG9JoN6SQL0lgXpLAvWWBOotCdRbEqi3JFBvSaDekkC9JYF6SwL1lgTqLQnUWxKotyRQb0mg3pJAvSWBeksC9ZYE6i0J1FuSm7wlmmo5V2+d/RrFyrLurhhfKlOVpRfaUS+3PA9QofOjXno7P0/jgc2HT/fyy+HvLDs8vdc4n7bTi94Xp+fO5abOJ/7bnet5paMKrT2Getu/53TpRFe+cw1avUKrO7R6Q1a/yc3qVy/Q6gStztDqAq0OZdWgrBqUVYOyalBWK5TVCmW1QlmtUFYrlNUKZbVCWa1QViuU1Qpl1aGsOpRVh7LqUFYdyqpDWXUoqw5l1aGsOpTVBmW1QVltUFYblNUGZbVBWW1QVhuU1QZltSFZ1WmCVi/Q6gStztDqAq2u0OoGrV6h1R1aHcpqgbJaoKwWKKsFymqBslqgrBYoqwXKaoGyWqCsEpRVgrJKUFYJyipBWSUoqwRllaCsEpRVgrLKUFYZyipDWWUoqwxllaGsMpRVhrLKUFYZyqpAWRUoqwJlVaCsCpRVgbIqUFYFyqpAWRUoqwplVaGsKpRVhbKqUFah3pJCvSWFeksK9ZYU6i0p1FtSqLekUG9Jod6SQr0lhXpLCvWWFOotKdRbUqi3pFBvSaHekkK9JYV6Swr1lhTqLSnUW1Kot6RQb0mh3pJCvSWFeksK9ZYU6i0p1FtSqLekUG9Jod6SQr0lhXpLCvWWFOotKdRbUqi3pFBvSaHekkK9JYV6Swr1lhTqLRnUWzKot2RQb8mg3pJNAq2u0OoGrV6h1R1aHcoq1FsyqLdkUG/JoN6SQb0lg3pLBvWWDOotGdRbMqi3ZFBvyaDekkG9JYN6Swb1lgzqLRnUWzKot2RQb8mg3pJBvSWDeksG9ZYM6i0Z1FsyqLdkUG/JoN6SQb0lg3pLBvWWDOotGdRbMqi3ZFBvyaDekkG9JYN6Swb1lgzqLRnUWzKot2RQb8mg3pJBvSWDeksG9ZYM6i0Z1FsyqLdkUG/JoN6SQb0lg3pLBvWWDOotGdRbMqi3ZFBvyaDekkG9JYN6Swb1lgzqLRnUWzKot2RQb8mg3pJBvSWDeksG9ZYM6i3ZurdUCp23mhYtr1+jcFnWjha2y77UU42V03p663k+rafvqcvp1SWlKn4+raV32k9vHcyn/ZTsxek5Lh8rrhwrrh4rrh0rbj1WXD9W3HaouOv+ZN645VhxjzVVte9MVbbs0S9UOoNqIfNz3HK1u/7rX/w2AMvy4Ch76cWlaXnclbh32rW0Ja6qrsWVY8XVY8W1Y8Wtx4rrx4rbwuNyucSlToDSzg9OadcBnJ8D1GkaPUAZPQCNHoBHDyCjB9DRA2wwE1xaKqdbwosA80VqxEU84iIt4CJlirhIibgIRVyEIy4iERfRiItEEF8iiC8RxJcI4imCeIogniKIpwjiKYJ4iiCeIoinCOIpgniKIJ4jiOcI4jmCeI4gniOI5wjiOYJ4jiCeI4jnCOIlgniJIF4iiJcI4iWCeIkgXiKIlwjiJYJ4iSBeI4jXCOI1gniNIF4jiNcI4jWCeI0gXiOI1wjiLYJ4iyDeIoi3COItgniLIN4iiLcI4i2CeIsgvkYQXyOIrxHE1wjiawTxNYL4GkF8jSC+RhBfI4j3COI9gniPIN4jiPcI4j2CeI8g3iOI9wjiPYL4FkF8iyC+RRDfIohvEcS3COJbBPEtgvgWQXwLIN6nKeIiJeIiFHERjriIRFxEIy5iERepERfxiItEEB/h3HmEc+cRzp1HOHce4dx5hHPnEc6dRzh3HuHceYRz5xHOnUc4dx7h3HmEc+cRzp1HOHce4dx5hHPnEc6dRzh3HuHceYRz5xHOnUc4dx7h3HmEc+cRzp1HOHce4dx5hHPnEc6dRzh3HuHceYRz5xHOnUc4dx7h3HmEc+cRzp1HOHce4dx5hHPnEc6dRzh3HuHceYRz5xHOnUc4dx7h3HmEc+cRzp1HOHce4dx5hHPnEc6dRzh3HuHceYRz5xHOnUc4dx7h3HmEc+cRzp1HOHce4dx5hHPnEc6dRzh3HuHceYRz51s4dzotG6WKWnfNyo/cOuhb2H8jxaVjxeVjxZVjxdVjxbVjxa3HiuvHitsOFbcda6rawrDWKsthI9t3XDpWXD5WXDlWXD1WXDtW3HqsuH6suO1IcdsWnx0ZKe6hpqo23fIbILXw0gtffu+J15WjUrzOZ6U06/RtJMsYfnoAda3vW363pMp5dX+ben1P5dw39fqu6kvf1ejlLwX46fTVf+7/eLj/+eOHz6e/8/UP/3z85enh0+P85dN/f3/+k9PZ/wE="}],"outputs":{"structs":{"functions":[{"kind":"struct","path":"TokenBridge::_call_mint_on_token_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::_call_mint_on_token_parameters","fields":[{"name":"amount","type":{"kind":"field"}},{"name":"secret_hash","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::claim_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::claim_private_parameters","fields":[{"name":"secret_hash_for_redeeming_minted_notes","type":{"kind":"field"}},{"name":"amount","type":{"kind":"field"}},{"name":"secret_for_L1_to_L2_message_consumption","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::get_token_abi","fields":[{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::get_portal_address_abi","fields":[{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::_assert_token_is_same_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::_assert_token_is_same_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]},{"kind":"struct","path":"TokenBridge::claim_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::claim_public_parameters","fields":[{"name":"to","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"secret","type":{"kind":"field"}},{"name":"message_leaf_index","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::exit_to_l1_private_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::exit_to_l1_private_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"nonce","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::get_portal_address_public_abi","fields":[{"name":"return_type","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::exit_to_l1_public_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::exit_to_l1_public_parameters","fields":[{"name":"recipient","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"amount","type":{"kind":"field"}},{"name":"caller_on_l1","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"nonce","type":{"kind":"field"}}]}}]},{"kind":"struct","path":"TokenBridge::constructor_abi","fields":[{"name":"parameters","type":{"kind":"struct","path":"TokenBridge::constructor_parameters","fields":[{"name":"token","type":{"kind":"struct","path":"aztec::protocol_types::address::aztec_address::AztecAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}},{"name":"portal_address","type":{"kind":"struct","path":"aztec::protocol_types::address::eth_address::EthAddress","fields":[{"name":"inner","type":{"kind":"field"}}]}}]}}]}]},"globals":{"storage":[{"kind":"struct","fields":[{"name":"admin","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"minters","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}},{"name":"balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000003"}}]}},{"name":"total_supply","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000004"}}]}},{"name":"pending_shields","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000005"}}]}},{"name":"public_balances","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000006"}}]}},{"name":"symbol","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000007"}}]}},{"name":"name","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000008"}}]}},{"name":"decimals","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000009"}}]}}]},{"kind":"struct","fields":[{"name":"token","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000001"}}]}},{"name":"portal_address","value":{"kind":"struct","fields":[{"name":"slot","value":{"kind":"integer","sign":false,"value":"0000000000000000000000000000000000000000000000000000000000000002"}}]}}]}]}},"file_map":{"21":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\nglobal TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    let x_bytes = x.to_le_bytes(32);\n\n    let mut low: Field = 0;\n    let mut high: Field = 0;\n\n    let mut offset = 1;\n    for i in 0..16 {\n        low += (x_bytes[i] as Field) * offset;\n        high += (x_bytes[i + 16] as Field) * offset;\n        offset *= 256;\n    }\n\n    (low, high)\n}\n\nunconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes = x.to_le_radix(256, num_bytes);\n    let y_bytes = y.to_le_radix(256, num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    let borrow = lte_16_hint(alo, blo);\n\n    let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n    let rhi = ahi - bhi - (borrow as Field);\n\n    rlo.assert_max_bit_size(128);\n    rhi.assert_max_bit_size(128);\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Take hints of the decomposition\n        let (xlo, xhi) = decompose_hint(x);\n\n        // Range check the limbs\n        xlo.assert_max_bit_size(128);\n        xhi.assert_max_bit_size(128);\n\n        // Check that the decomposition is correct\n        assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n        // Assert that the decomposition of P is greater than the decomposition of x\n        assert_gt_limbs((PLO, PHI), (xlo, xhi));\n        (xlo, xhi)\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else  {\n        // Take a hint of the comparison and verify it\n        if lt_32_hint(a, b) {\n            assert_gt(b, a);\n            false\n        } else {\n            assert_gt(a, b);\n            true\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{decompose_hint, decompose, compute_lt, assert_gt, gt, lt, TWO_POW_128, compute_lte, PLO, PHI};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"22":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x ∈ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field/mod.nr"},"24":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::embedded_curve_ops::{EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul};\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    let value = pedersen_commitment_with_separator(input, 0);\n    if (value.x == 0) & (value.y == 0) {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    } else {\n        EmbeddedCurvePoint { x: value.x, y: value.y, is_infinite: false }\n    }\n}\n\nfn pedersen_commitment_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        points[i] = EmbeddedCurveScalar::from_field(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    let values = multi_scalar_mul(generators, points);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: values[2] as bool }\n}\n\npub fn pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: false }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[field(bn254)]\nfn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    crate::assert_constant(starting_index);\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(domain_separator_bytes: [u8; M], starting_index: u32) -> [EmbeddedCurvePoint; N] {}\n\nfn pedersen_hash_with_separator_noir<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let v1 = pedersen_commitment_with_separator(input, separator);\n    let length_generator : [EmbeddedCurvePoint; 1] = derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    multi_scalar_mul(\n        [length_generator[0], v1],\n        [EmbeddedCurveScalar { lo: N as Field, hi: 0 }, EmbeddedCurveScalar { lo: 1, hi: 0 }]\n    )[0]\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {}\n\n#[foreign(pedersen_commitment)]\nfn __pedersen_commitment_with_separator<let N: u32>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n#[test]\nfn assert_pedersen_noir() {\n    // TODO: make this a fuzzer test once fuzzer supports curve-specific blackbox functions.\n    let input = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n    assert_eq(pedersen_hash_with_separator(input, 4), pedersen_hash_with_separator_noir(input, 4));\n    assert_eq(pedersen_commitment_with_separator(input, 4), pedersen_commitment_with_separator_noir(input, 4));\n}\n","path":"std/hash/mod.nr"},"31":{"source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n","path":"std/merkle.nr"},"37":{"source":"use crate::hash::{Hash, Hasher};\nuse crate::cmp::{Ordering, Ord, Eq};\nuse crate::default::Default;\n\nstruct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::unsafe::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some { self._value } else { default }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some { self } else { other }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<U, Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some { self } else { default() }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some { Option::none() } else { self }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T> where T: Eq {\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T> where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T> where T: Ord {\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else {\n            if other._is_some {\n                Ordering::less()\n            } else {\n                Ordering::equal()\n            }\n        }\n    }\n}\n","path":"std/option.nr"},"43":{"source":"impl<T> [T] {\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the \n    /// original unmodified slice. \n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements \n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and \n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    // Append each element of the `other` slice to the end of `self`.\n    // This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::unsafe::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n","path":"std/slice.nr"},"49":{"source":"// docs:start:token_bridge_imports\n\n// Minimal implementation of the token bridge that can move funds between L1 <> L2.\n// The bridge has a corresponding Portal contract on L1 that it is attached to\n// And corresponds to a Token on L2 that uses the `AuthWit` accounts pattern.\n// Bridge has to be set as a minter on the token before it can be used\n\ncontract TokenBridge {\n    use dep::aztec::prelude::{FunctionSelector, AztecAddress, EthAddress, PublicMutable, SharedImmutable};\n\n    use dep::token_portal_content_hash_lib::{get_mint_public_content_hash, get_mint_private_content_hash, get_withdraw_content_hash};\n\n    use dep::token::Token;\n    // docs:end:token_bridge_imports\n\n    // docs:start:token_bridge_storage_and_constructor\n    // Storage structure, containing all storage, and specifying what slots they use.\n    #[aztec(storage)]\n    struct Storage {\n        token: PublicMutable<AztecAddress>,\n        portal_address: SharedImmutable<EthAddress>,\n    }\n\n    // Constructs the contract.\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(token: AztecAddress, portal_address: EthAddress) {\n        storage.token.write(token);\n        storage.portal_address.initialize(portal_address);\n    }\n    // docs:end:token_bridge_storage_and_constructor\n\n    #[aztec(private)]\n    fn get_portal_address() -> EthAddress {\n        storage.portal_address.read_private()\n    }\n\n    #[aztec(public)]\n    fn get_portal_address_public() -> EthAddress {\n        storage.portal_address.read_public()\n    }\n\n    // docs:start:claim_public\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount publicly\n    #[aztec(public)]\n    fn claim_public(to: AztecAddress, amount: Field, secret: Field, message_leaf_index: Field) {\n        let content_hash = get_mint_public_content_hash(to, amount);\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret,\n            storage.portal_address.read_public(),\n            message_leaf_index\n        );\n\n        // Mint tokens\n        Token::at(storage.token.read()).mint_public(to, amount).call(&mut context);\n    }\n    // docs:end:claim_public\n\n    // docs:start:exit_to_l1_public\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message publicly\n    // Requires `msg.sender` to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[aztec(public)]\n    fn exit_to_l1_public(\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read_public(), content);\n\n        // Burn tokens\n        Token::at(storage.token.read()).burn_public(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    // docs:end:exit_to_l1_public\n    // docs:start:claim_private\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount in private assets\n    // User needs to call token.redeem_shield() to get the private assets\n    #[aztec(private)]\n    fn claim_private(\n        secret_hash_for_redeeming_minted_notes: Field, // secret hash used to redeem minted notes at a later time. This enables anyone to call this function and mint tokens to a user on their behalf\n        amount: Field,\n        secret_for_L1_to_L2_message_consumption: Field // secret used to consume the L1 to L2 message\n    ) {\n        // Consume L1 to L2 message and emit nullifier\n        let content_hash = get_mint_private_content_hash(secret_hash_for_redeeming_minted_notes, amount);\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret_for_L1_to_L2_message_consumption,\n            storage.portal_address.read_private()\n        );\n\n        // Mint tokens on L2\n        // `mint_private` on token is public. So we call an internal public function\n        // which then calls the public method on the token contract.\n        // Since the secret_hash is passed, no secret is leaked.\n        TokenBridge::at(context.this_address())._call_mint_on_token(amount, secret_hash_for_redeeming_minted_notes).enqueue(&mut context);\n    }\n    // docs:end:claim_private\n\n    // docs:start:exit_to_l1_private\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message privately\n    // Requires `msg.sender` (caller of the method) to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[aztec(private)]\n    fn exit_to_l1_private(\n        token: AztecAddress,\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: Field,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        nonce: Field // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(storage.portal_address.read_private(), content);\n\n        // docs:start:call_assert_token_is_same\n        // Assert that user provided token address is same as seen in storage.\n        TokenBridge::at(context.this_address())._assert_token_is_same(token).enqueue(&mut context);\n        // docs:end:call_assert_token_is_same\n\n        // Burn tokens\n        Token::at(token).burn(context.msg_sender(), amount, nonce).call(&mut context);\n    }\n    /// docs:end:exit_to_l1_private\n\n    // docs:start:get_token\n    #[aztec(public)]\n    #[aztec(view)]\n    fn get_token() -> AztecAddress {\n        storage.token.read()\n    }\n    // docs:end:get_token\n\n    // docs:start:call_mint_on_token\n    // This is a public call as we need to read from public storage.\n    // Also, note that user hashes their secret in private and only sends the hash in public\n    // meaning only user can `redeem_shield` at a later time with their secret.\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _call_mint_on_token(amount: Field, secret_hash: Field) {\n        Token::at(storage.token.read()).mint_private(amount, secret_hash).call(&mut context);\n    }\n    // docs:end:call_mint_on_token\n\n    // docs:start:assert_token_is_same\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _assert_token_is_same(token: AztecAddress) {\n        assert(storage.token.read().eq(token), \"Token address is not the same as seen in storage\");\n    }\n    // docs:end:assert_token_is_same\n}\n","path":"/home/muzzamil/Projects/holonym-foundation/aztech/token-bridge-holonym/packages/aztec-contracts/token_bridge/src/main.nr"},"50":{"source":"use crate::{\n    hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness\n};\n\nuse std::merkle::compute_merkle_root;\nuse dep::protocol_types::{constants::L1_TO_L2_MSG_TREE_HEIGHT, address::{AztecAddress, EthAddress}, utils::arr_copy_slice};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    storage_contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_message_hash(\n        portal_contract_address,\n        chain_id,\n        storage_contract_address,\n        version,\n        content,\n        secret_hash\n    );\n\n    let returned_message = get_l1_to_l2_membership_witness(storage_contract_address, message_hash, secret);\n    let leaf_index = returned_message[0];\n    let sibling_path = arr_copy_slice(returned_message, [0; L1_TO_L2_MSG_TREE_HEIGHT], 1);\n\n    // Check that the message is in the tree\n    // This is implicitly checking that the values of the message are correct\n    let root = compute_merkle_root(message_hash, leaf_index, sibling_path);\n    assert(root == l1_to_l2_root, \"Message not in state\");\n\n    compute_message_nullifier(message_hash, secret, leaf_index)\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/aztec-nr/aztec/src/messaging.nr"},"60":{"source":"use std::merkle::compute_merkle_root;\nuse dep::protocol_types::header::Header;\n\nuse crate::{\n    context::PrivateContext, oracle::get_nullifier_membership_witness::get_nullifier_membership_witness,\n    note::{utils::compute_siloed_nullifier, note_interface::NoteInterface}\n};\n\ntrait ProveNullifierInclusion {\n    fn prove_nullifier_inclusion(header: Header, nullifier: Field);\n}\n\nimpl ProveNullifierInclusion for Header {\n    fn prove_nullifier_inclusion(self, nullifier: Field) {\n        // 1) Get the membership witness of the nullifier\n        let witness = get_nullifier_membership_witness(self.global_variables.block_number as u32, nullifier);\n\n        // 2) Check that the witness we obtained matches the nullifier\n        assert(witness.leaf_preimage.nullifier == nullifier, \"Nullifier does not match value in witness\");\n\n        // 3) Compute the nullifier tree leaf\n        let nullifier_leaf = witness.leaf_preimage.hash();\n\n        // 4) Prove that the nullifier is in the nullifier tree\n        assert(\n            self.state.partial.nullifier_tree.root\n            == compute_merkle_root(nullifier_leaf, witness.index, witness.path), \"Proving nullifier inclusion failed\"\n        );\n        // --> Now we have traversed the trees all the way up to archive root and verified that the nullifier\n        //     was included in the nullifier tree.\n    }\n}\n\ntrait ProveNoteIsNullified {\n    fn prove_note_is_nullified<Note, N, M>(header: Header, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M>;\n}\n\nimpl ProveNoteIsNullified for Header {\n    // docs:start:prove_note_is_nullified\n    fn prove_note_is_nullified<Note, N, M>(self, note: Note, context: &mut PrivateContext) where Note: NoteInterface<N, M> {\n        let nullifier = compute_siloed_nullifier(note, context);\n\n        self.prove_nullifier_inclusion(nullifier);\n    }\n    // docs:end:prove_note_is_nullified\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/aztec-nr/aztec/src/history/nullifier_inclusion.nr"},"62":{"source":"use dep::protocol_types::{\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::pedersen_hash, address::AztecAddress,\n    header::Header, utils::field::full_field_less_than\n};\nuse std::merkle::compute_merkle_root;\n\nuse crate::{context::PrivateContext, oracle::get_public_data_witness::get_public_data_witness};\n\ntrait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(header: Header, storage_slot: Field, contract_address: AztecAddress) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for Header { \n    fn public_storage_historical_read(self, storage_slot: Field, contract_address: AztecAddress) -> Field {\n        // 1) Compute the leaf slot by siloing the storage slot with the contract address\n        let public_value_leaf_slot = pedersen_hash(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX\n        );\n\n        // 2) Get the membership witness of the slot\n        let witness = get_public_data_witness(\n            self.global_variables.block_number as u32,\n            public_value_leaf_slot\n        );\n\n        // 3) Extract the value from the witness leaf and check that the storage slot is correct\n        let preimage = witness.leaf_preimage;\n\n        // Here we have two cases. Code based on same checks in `validate_public_data_reads` in `base_rollup_inputs`\n        // 1. The value is the same as the one in the witness\n        // 2. The value was never initialized and is zero\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_value_leaf_slot);\n        let is_next_greater_than = full_field_less_than(public_value_leaf_slot, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(preimage.slot, public_value_leaf_slot, \"Public data slot doesn't match witness\");\n            preimage.value\n        };\n\n        // 4) Prove that the leaf exists in the public data tree. Note that `hash` returns not just the hash of the value\n        // but also the metadata (slot, next index and next slot).\n        assert(\n            self.state.partial.public_data_tree.root\n            == compute_merkle_root(preimage.hash(), witness.index, witness.path), \"Proving public value inclusion failed\"\n        );\n\n        value\n    }\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/aztec-nr/aztec/src/history/public_storage.nr"},"65":{"source":"use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n    GENERATOR_INDEX__SECRET_HASH, GENERATOR_INDEX__MESSAGE_NULLIFIER, ARGS_HASH_CHUNK_COUNT,\n    GENERATOR_INDEX__FUNCTION_ARGS, ARGS_HASH_CHUNK_LENGTH\n},\n    traits::Hash, hash::{pedersen_hash, compute_siloed_nullifier, sha256_to_field}\n};\nuse crate::oracle::logs_traits::{LensForEncryptedLog, ToBytesForUnencryptedLog};\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    pedersen_hash([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_unencrypted_log_hash<T, N, M>(\n    contract_address: AztecAddress,\n    event_selector: Field,\n    log: T\n) -> Field where T: ToBytesForUnencryptedLog<N, M> {\n    let message_bytes: [u8; N] = log.to_be_bytes_arr();\n    // can't use N - not in scope error\n    let n = message_bytes.len();\n    let mut hash_bytes = [0; M];\n    // Address is converted to 32 bytes in ts\n    let address_bytes = contract_address.to_be_bytes_arr();\n    for i in 0..32 {\n        hash_bytes[i] = address_bytes[i];\n    }\n    let event_bytes = event_selector.to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[32 + i] = event_bytes[i];\n    }\n    let len_bytes = (n as Field).to_be_bytes(4);\n    for i in 0..4 {\n        hash_bytes[36 + i] = len_bytes[i];\n    }\n    for i in 0..n {\n        hash_bytes[40 + i] = message_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\npub fn compute_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field\n) -> Field {\n    let mut hash_bytes = [0 as u8; 192];\n    let sender_bytes = sender.to_field().to_be_bytes(32);\n    let chain_id_bytes = chain_id.to_be_bytes(32);\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let version_bytes = version.to_be_bytes(32);\n    let content_bytes = content.to_be_bytes(32);\n    let secret_hash_bytes = secret_hash.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret and index of the message hash\n// in the L1 to L2 message tree\npub fn compute_message_nullifier(message_hash: Field, secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash(\n        [message_hash, secret, leaf_index],\n        GENERATOR_INDEX__MESSAGE_NULLIFIER\n    )\n}\n\nstruct ArgsHasher {\n    fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<N>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\npub fn hash_args_array<N>(args: [Field; N]) -> Field {\n    hash_args(args.as_slice())\n}\n\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        assert(args.len() < ARGS_HASH_CHUNK_COUNT * ARGS_HASH_CHUNK_LENGTH);\n        let mut chunks_hashes = [0; ARGS_HASH_CHUNK_COUNT];\n        let mut current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n\n        let mut current_chunk_index = 0;\n        let mut index_inside_current_chunk = 0;\n        for i in 0..args.len() {\n            current_chunk_values[index_inside_current_chunk] = args[i];\n            index_inside_current_chunk+=1;\n            if index_inside_current_chunk == ARGS_HASH_CHUNK_LENGTH {\n                chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n                current_chunk_values = [0; ARGS_HASH_CHUNK_LENGTH];\n                current_chunk_index+=1;\n                index_inside_current_chunk = 0;\n            }\n        }\n        if index_inside_current_chunk > 0 {\n            chunks_hashes[current_chunk_index] = pedersen_hash(current_chunk_values, GENERATOR_INDEX__FUNCTION_ARGS);\n        }\n        pedersen_hash(chunks_hashes, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n#[test]\nfn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..800 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    assert(hash == 0x05a1023fef839ac88731f49ae983e172c1b600a3c8f3393ad0ac25d819ac0f0f);\n}\n\n#[test]\nfn compute_unenc_log_hash_array() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let event_selector = 5;\n    let log = [\n        0x20660de09f35f876e3e69d227b2a35166ad05f09d82d06366ec9b6f65a51fec2,\n        0x1b52bfe3b8689761916f76dc3d38aa8810860db325cd39ca611eed980091f01c,\n        0x2e559c4045c378a56ad13b9edb1e8de4e7ad3b3aa35cc7ba9ec77f7a68fa43a4,\n        0x25d0f689c4a4178a29d59306f2675824d19be6d25e44fa03b03f49c263053dd2,\n        0x2d513a722d6f352dc0961f156afdc5e31495b9f0e35cb069261a8e55e2df67fd\n    ];\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x00846d6969c8c2f61d39cd2762efcb0abb14f88d59c2675910251ef2bcffe9a7);\n}\n\n#[test]\nfn compute_unenc_log_hash_addr() {\n    let contract_address = AztecAddress::from_field(0x233a3e0df23b2b15b324194cb4a151f26c0b7333250781d34cc269d85dc334c6);\n    let event_selector = 5;\n    let log = AztecAddress::from_field(0x26aa302d4715fd8a687453cb26d616b0768027bd54bcae56b09d908ecd9f8303);\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x00880a801230ea08c98a802a11b4786cba474513875f0fc69a615e81c5f9f21c);\n}\n\n#[test]\nfn compute_unenc_log_hash_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let event_selector = 5;\n    let log = \"dummy\";\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x00a78b5347813624ecfd26e5b8bc6146f418b0cfcc8296b5112d09b8ebba9496);\n}\n\n#[test]\nfn compute_unenc_log_hash_longer_str() {\n    let contract_address = AztecAddress::from_field(0x1b401e1146c5c507962287065c81f0ef7590adae3802c533d7549d6bf0a41bd8);\n    let event_selector = 5;\n    let log = \"Hello this is a string\";\n    let hash = compute_unencrypted_log_hash(contract_address, event_selector, log);\n    assert(hash == 0x001f3390ea242afee7ce46dafdbdc4bd4f1cf20cd63850d12d60ff9956712c4f);\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/aztec-nr/aztec/src/hash.nr"},"67":{"source":"#[oracle(packArgumentsArray)]\nunconstrained fn pack_arguments_array_oracle<N>(_args: [Field; N]) -> Field {}\n\n#[oracle(packArguments)]\nunconstrained fn pack_arguments_oracle(_args: [Field]) -> Field {}\n\n/// - Pack arguments (array version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments_array<N>(args: [Field; N]) -> Field {\n    pack_arguments_array_oracle(args)\n}\n\n/// - Pack arguments (slice version) will notify the simulator that these arguments will be used later at\n///   some point in the call. \n/// - When the external call is made later, the simulator will know what the values unpack to.\n/// - This oracle will not be required in public vm functions, as the vm will keep track of arguments \n///   itself.\nunconstrained pub fn pack_arguments(args: [Field]) -> Field {\n    pack_arguments_oracle(args)\n}\n\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/aztec-nr/aztec/src/oracle/arguments.nr"},"73":{"source":"use dep::protocol_types::{\n    abis::nullifier_leaf_preimage::{NullifierLeafPreimage, NULLIFIER_LEAF_PREIMAGE_LENGTH},\n    constants::NULLIFIER_TREE_HEIGHT, hash::pedersen_hash, utils::arr_copy_slice\n};\n\n// INDEX_LENGTH + NULLIFIER_LEAF_PREIMAGE_LENGTH + NULLIFIER_TREE_HEIGHT\nglobal NULLIFIER_MEMBERSHIP_WITNESS: Field = 24;\n\nstruct NullifierMembershipWitness {\n    index: Field,\n    leaf_preimage: NullifierLeafPreimage,\n    path: [Field; NULLIFIER_TREE_HEIGHT],\n}\n\nimpl NullifierMembershipWitness {\n    pub fn deserialize(fields: [Field; NULLIFIER_MEMBERSHIP_WITNESS]) -> Self {\n        let leaf_preimage_fields = arr_copy_slice(fields, [0; NULLIFIER_LEAF_PREIMAGE_LENGTH], 1);\n        Self {\n            index: fields[0],\n            leaf_preimage: NullifierLeafPreimage::deserialize(leaf_preimage_fields),\n            path: arr_copy_slice(\n                fields,\n                [0; NULLIFIER_TREE_HEIGHT],\n                1 + NULLIFIER_LEAF_PREIMAGE_LENGTH\n            )\n        }\n    }\n}\n\n#[oracle(getLowNullifierMembershipWitness)]\nunconstrained fn get_low_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_low_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_low_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n\n#[oracle(getNullifierMembershipWitness)]\nunconstrained fn get_nullifier_membership_witness_oracle(\n    _block_number: u32,\n    _nullifier: Field\n) -> [Field; NULLIFIER_MEMBERSHIP_WITNESS] {}\n\n// Nullifier here refers to the nullifier we are looking to get non-inclusion proof for (by proving that a lower\n// nullifier's next_value is bigger than the nullifier)\nunconstrained pub fn get_nullifier_membership_witness(block_number: u32, nullifier: Field) -> NullifierMembershipWitness {\n    let fields = get_nullifier_membership_witness_oracle(block_number, nullifier);\n    NullifierMembershipWitness::deserialize(fields)\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/aztec-nr/aztec/src/oracle/get_nullifier_membership_witness.nr"},"74":{"source":"use dep::protocol_types::{\n    abis::{\n    function_selector::FunctionSelector, public_call_stack_item::PublicCallStackItem,\n    function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs,\n    call_context::CallContext, read_request::ReadRequest, note_hash::NoteHash, nullifier::Nullifier,\n    log_hash::LogHash, global_variables::GlobalVariables, gas::Gas\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    messaging::l2_to_l1_message::L2ToL1Message, header::Header, address::AztecAddress,\n    utils::reader::Reader,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH\n}\n};\n\n#[oracle(enqueuePublicFunctionCall)]\nunconstrained fn enqueue_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn enqueue_public_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    enqueue_public_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\n#[oracle(setPublicTeardownFunctionCall)]\nunconstrained fn set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {}\n\nunconstrained pub fn set_public_teardown_function_call_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH] {\n    set_public_teardown_function_call_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    )\n}\n\npub fn parse_public_call_stack_item_from_oracle(fields: [Field; ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_LENGTH]) -> PublicCallStackItem {\n    let mut reader = Reader::new(fields);\n\n    // Note: Not using PublicCirclePublicInputs::deserialize here, because everything below args_hash is 0 and\n    // there is no more data in fields because there is only ENQUEUE_PUBLIC_FUNCTION_CALL_RETURN_SIZE fields!\n    // WARNING: if updating, see comment in public_call_stack_item.ts's PublicCallStackItem.hash()\n    let item = PublicCallStackItem {\n        contract_address: AztecAddress::from_field(reader.read()),\n        function_data: FunctionData { selector: FunctionSelector::from_field(reader.read()), is_private: false },\n        public_inputs: PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            new_note_hashes: [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n            new_nullifiers: [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n            new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0\n        },\n        is_execution_request: true\n    };\n    reader.finish();\n\n    item\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr"},"76":{"source":"#[oracle(packReturns)]\nunconstrained fn pack_returns_oracle<N>(_returns: [Field]) -> Field {}\n\nunconstrained pub fn pack_returns(returns: [Field]) {\n    let _unused = pack_returns_oracle(returns);\n}\n\n#[oracle(unpackReturns)]\nunconstrained fn unpack_returns_oracle<N>(_return_hash: Field) -> [Field; N] {}\n\nunconstrained pub fn unpack_returns<N>(return_hash: Field) -> [Field; N] {\n    unpack_returns_oracle(return_hash)\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/aztec-nr/aztec/src/oracle/returns.nr"},"78":{"source":"use dep::protocol_types::{\n    address::AztecAddress, contract_instance::ContractInstance, utils::arr_copy_slice,\n    constants::CONTRACT_INSTANCE_LENGTH, utils::reader::Reader\n};\n\n#[oracle(getContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {}\n\n// Returns a ContractInstance plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstance)]\nunconstrained fn get_contract_instance_oracle_avm(_address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {}\n\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n    get_contract_instance_oracle(address)\n}\n\nunconstrained pub fn get_contract_instance_internal_avm(address: AztecAddress) -> [Field; CONTRACT_INSTANCE_LENGTH + 1] {\n    get_contract_instance_oracle_avm(address)\n}\n\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    let instance = ContractInstance::deserialize(get_contract_instance_internal(address));\n    assert(instance.to_address().eq(address));\n    instance\n}\n\npub fn get_contract_instance_avm(address: AztecAddress) -> Option<ContractInstance> {\n    let mut reader = Reader::new(get_contract_instance_internal_avm(address));\n    let found = reader.read();\n    if found == 0 {\n        Option::none()\n    } else {\n        Option::some(reader.read_struct(ContractInstance::deserialize))\n    }\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr"},"79":{"source":"use dep::protocol_types::{\n    constants::PUBLIC_DATA_TREE_HEIGHT, hash::pedersen_hash,\n    public_data_tree_leaf_preimage::PublicDataTreeLeafPreimage, traits::{Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nglobal LEAF_PREIMAGE_LENGTH: u32 = 4;\nglobal PUBLIC_DATA_WITNESS: Field = 45;\n\nstruct PublicDataWitness {\n    index: Field,\n    leaf_preimage: PublicDataTreeLeafPreimage,\n    path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(getPublicDataTreeWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _leaf_slot: Field\n) -> [Field; PUBLIC_DATA_WITNESS] {}\n\nunconstrained pub fn get_public_data_witness(block_number: u32, leaf_slot: Field) -> PublicDataWitness {\n    let fields = get_public_data_witness_oracle(block_number, leaf_slot);\n    PublicDataWitness {\n        index: fields[0],\n        leaf_preimage: PublicDataTreeLeafPreimage { slot: fields[1], value: fields[2], next_index: fields[3] as u32, next_slot: fields[4] },\n        path: arr_copy_slice(fields, [0; PUBLIC_DATA_TREE_HEIGHT], 1 + LEAF_PREIMAGE_LENGTH)\n    }\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr"},"81":{"source":"use dep::protocol_types::{address::AztecAddress};\n\nglobal L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH: u64 = 17;\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(getL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {}\n\nunconstrained pub fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field\n) -> [Field; L1_TO_L2_MESSAGE_ORACLE_CALL_LENGTH] {\n    get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret)\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr"},"86":{"source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_call_stack_item::PrivateCallStackItem},\n    address::AztecAddress, constants::PRIVATE_CALL_STACK_ITEM_LENGTH\n};\n\n#[oracle(callPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n    _is_delegate_call: bool\n) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {}\n\nunconstrained pub fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n    is_delegate_call: bool\n) -> PrivateCallStackItem {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n        is_delegate_call\n    );\n\n    PrivateCallStackItem::deserialize(fields)\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr"},"87":{"source":"use dep::protocol_types::{\n    address::AztecAddress, hash::{compute_siloed_nullifier, pedersen_hash},\n    constants::GENERATOR_INDEX__CONSTRUCTOR, abis::function_selector::FunctionSelector\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext}, oracle::get_contract_instance::get_contract_instance,\n    oracle::get_contract_instance::get_contract_instance_avm\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_new_nullifier(init_nullifier, 0);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_new_nullifier(init_nullifier, 0);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_contract_initialization_nullifier(context.this_address());\n    let header = context.get_header();\n    header.prove_nullifier_inclusion(init_nullifier);\n}\n\nfn compute_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    compute_siloed_nullifier(\n        address,\n        compute_unsiloed_contract_initialization_nullifier(address)\n    )\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()), \"Initializer address is not the contract deployer\"\n    );\n}\n\npub fn compute_initialization_hash(init_selector: FunctionSelector, init_args_hash: Field) -> Field {\n    pedersen_hash(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR\n    )\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/aztec-nr/aztec/src/initializer.nr"},"110":{"source":"use crate::{\n    context::{PrivateContext, PublicContext, UnconstrainedContext}, oracle::storage::storage_read,\n    state_vars::storage::Storage\n};\nuse dep::protocol_types::{constants::INITIALIZATION_SLOT_SEPARATOR, traits::{Deserialize, Serialize}};\n\n// Just like PublicImmutable but with the ability to read from private functions.\nstruct SharedImmutable<T, Context>{\n    context: Context,\n    storage_slot: Field,\n}\n\nimpl<T, Context> Storage<T> for SharedImmutable<T, Context> {}\n\nimpl<T, Context> SharedImmutable<T, Context> {\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Self { context, storage_slot }\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PublicContext> {\n    // Intended to be only called once. \n    pub fn initialize<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        // We check that the struct is not yet initialized by checking if the initialization slot is 0\n        let initialization_slot = INITIALIZATION_SLOT_SEPARATOR + self.storage_slot;\n        let init_field: Field = self.context.storage_read(initialization_slot);\n        assert(init_field == 0, \"SharedImmutable already initialized\");\n\n        // We populate the initialization slot with a non-zero value to indicate that the struct is initialized\n        self.context.storage_write(initialization_slot, 0xdead);\n        self.context.storage_write(self.storage_slot, value);\n    }\n\n    pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T> SharedImmutable<T, UnconstrainedContext> {\n    unconstrained pub fn read_public<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n\nimpl<T> SharedImmutable<T, &mut PrivateContext> {\n    pub fn read_private<T_SERIALIZED_LEN>(self) -> T  where T: Deserialize<T_SERIALIZED_LEN> {\n        let header = self.context.get_header();\n        let mut fields = [0; T_SERIALIZED_LEN];\n\n        for i in 0..fields.len() {\n            fields[i] =\n                header.public_storage_historical_read(\n                    self.storage_slot + i as Field,\n                    (*self.context).this_address()\n                );\n        }\n        T::deserialize(fields)\n    }\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/aztec-nr/aztec/src/state_vars/shared_immutable.nr"},"125":{"source":"use crate::context::{PublicContext, UnconstrainedContext};\nuse crate::oracle::storage::storage_read;\nuse dep::protocol_types::traits::{Deserialize, Serialize};\nuse crate::state_vars::storage::Storage;\n\n// docs:start:public_mutable_struct\nstruct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context> Storage<T> for PublicMutable<T, Context> {}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    // docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    // docs:start:public_mutable_struct_read\n    pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    // docs:start:public_mutable_struct_write\n    pub fn write<T_SERIALIZED_LEN>(self, value: T) where T: Serialize<T_SERIALIZED_LEN> {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UnconstrainedContext> {\n    unconstrained pub fn read<T_SERIALIZED_LEN>(self) -> T where T: Deserialize<T_SERIALIZED_LEN> {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr"},"129":{"source":"use dep::protocol_types::{\n    abis::{function_selector::FunctionSelector, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress, traits::Deserialize\n};\n\nuse crate::context::{\n    private_context::PrivateContext, public_context::PublicContext, gas::GasOpts,\n    public_context::FunctionReturns, inputs::{PrivateContextInputs, PublicContextInputs}\n};\n\nuse crate::oracle::arguments;\n\ntrait CallInterface<N, T, P, Env> {\n    fn get_args(self) -> [Field];\n    fn get_original(self) -> fn[Env](T) -> P;\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateCallInterface<N, T, Env> {\n  fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nstruct PrivateCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateCallInterface<N, T, Env> {\n    pub fn call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        let returns = context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        );\n        let unpacked: T = returns.unpack_into();\n        unpacked\n    }\n\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateVoidCallInterface<N, Env> {\n  fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nstruct PrivateVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateVoidCallInterface<N, Env> {\n    pub fn call(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n            false\n        ).assert_empty();\n    }\n\n    pub fn view(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n\n    pub fn delegate_call(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, false, true).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticCallInterface<N, T, Env> {\n  fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nstruct PrivateStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, T, Env> PrivateStaticCallInterface<N, T, Env> {\n    pub fn view<M>(self, context: &mut PrivateContext) -> T where T: Deserialize<M> {\n        let returns = context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false);\n        returns.unpack_into()\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PrivateContextInputs, PrivateCircuitPublicInputs, Env> for PrivateStaticVoidCallInterface<N, Env> {\n  fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_original(self) -> fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs {\n        self.original\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nstruct PrivateStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args_hash: Field,\n    args: [Field],\n    original: fn[Env](PrivateContextInputs) -> PrivateCircuitPublicInputs,\n    is_static: bool\n}\n\nimpl<N, Env> PrivateStaticVoidCallInterface<N, Env> {\n    pub fn view(self, context: &mut PrivateContext) {\n        context.call_private_function_with_packed_args(self.target_contract, self.selector, self.args_hash, true, false).assert_empty();\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicCallInterface<N, T, Env> {\n  fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nstruct PublicCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<N, T, Env> PublicCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.deserialize_into()\n    }\n\n    pub fn delegate_call<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.deserialize_into()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicVoidCallInterface<N, Env> {\n  fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nstruct PublicVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool\n}\n\nimpl<N, Env> PublicVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn call(self, context: &mut PublicContext) {\n        let returns = context.call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn delegate_call(self, context: &mut PublicContext) {\n        let returns = context.delegate_call_public_function(self.target_contract, self.selector, self.args);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n\n    pub fn delegate_enqueue(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ false,\n            /*delegate=*/ true\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, T, Env> for PublicStaticCallInterface<N, T, Env> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> T {\n        self.original\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nstruct PublicStaticCallInterface<N, T, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> T,\n    is_static: bool\n}\n\nimpl<N, T, Env> PublicStaticCallInterface<N, T, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view<M>(self, context: &mut PublicContext) -> T where T: Deserialize<M> {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        let unpacked: T = returns.deserialize_into();\n        unpacked\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n\nimpl<N, T, P, Env> CallInterface<N, PublicContextInputs, (), Env> for PublicStaticVoidCallInterface<N, Env> {\n  fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_original(self) -> fn[Env](PublicContextInputs) -> () {\n        self.original\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<N> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\nstruct PublicStaticVoidCallInterface<N, Env> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<N>,\n    args: [Field],\n    gas_opts: GasOpts,\n    original: fn[Env](PublicContextInputs) -> (),\n    is_static: bool\n}\n\nimpl<N, Env> PublicStaticVoidCallInterface<N, Env> {\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    pub fn view(self, context: &mut PublicContext) {\n        let returns = context.static_call_public_function(self.target_contract, self.selector, self.args, self.gas_opts);\n        returns.assert_empty()\n    }\n\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        // This packing is only here because PrivateContext's call_public* functions do not accept a slice for the args.\n        let args_hash = arguments::pack_arguments(self.args);\n        context.call_public_function_with_packed_args(\n            self.target_contract,\n            self.selector,\n            args_hash,\n            /*static=*/ true,\n            /*delegate=*/ false\n        )\n    }\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr"},"133":{"source":"use crate::{\n    context::{inputs::PrivateContextInputs, packed_returns::PackedReturns},\n    messaging::process_l1_to_l2_message, hash::{hash_args_array, ArgsHasher},\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX, NUM_KEY_TYPES, sk_generators},\n    oracle::{\n    key_validation_request::get_key_validation_request, arguments, returns::pack_returns,\n    call_private_function::call_private_function_internal, header::get_header_at,\n    logs::{emit_encrypted_note_log, emit_encrypted_event_log},\n    enqueue_public_function_call::{\n    enqueue_public_function_call_internal, set_public_teardown_function_call_internal,\n    parse_public_call_stack_item_from_oracle\n}\n}\n};\nuse dep::protocol_types::{\n    abis::{\n    caller_context::CallerContext, function_selector::FunctionSelector,\n    max_block_number::MaxBlockNumber,\n    validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    private_call_request::PrivateCallRequest, private_circuit_public_inputs::PrivateCircuitPublicInputs,\n    public_call_stack_item::PublicCallStackItem, read_request::ReadRequest, note_hash::NoteHash,\n    nullifier::Nullifier, log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_ENCRYPTED_LOGS_PER_CALL, MAX_UNENCRYPTED_LOGS_PER_CALL,\n    MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, messaging::l2_to_l1_message::L2ToL1Message, utils::reader::Reader, traits::Empty\n};\n\n// When finished, one can call .finish() to convert back to the abi\nstruct PrivateContext {\n    // docs:start:private-context\n    inputs: PrivateContextInputs,\n    side_effect_counter: u32,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    args_hash: Field,\n    return_hash: Field,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    new_note_hashes: BoundedVec<NoteHash, MAX_NEW_NOTE_HASHES_PER_CALL>,\n    new_nullifiers: BoundedVec<Nullifier, MAX_NEW_NULLIFIERS_PER_CALL>,\n\n    private_call_requests : BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    public_call_stack_hashes : BoundedVec<Field, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL>,\n    public_teardown_function_hash: Field,\n    new_l2_to_l1_msgs : BoundedVec<L2ToL1Message, MAX_NEW_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    note_encrypted_logs_hashes: BoundedVec<NoteLogHash, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL>,\n    encrypted_logs_hashes: BoundedVec<EncryptedLogHash, MAX_ENCRYPTED_LOGS_PER_CALL>,\n    unencrypted_logs_hashes: BoundedVec<LogHash, MAX_UNENCRYPTED_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n\n    fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.storage_contract_address\n    }\n\n    fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        self.new_note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    // TODO(#7112): This function is called with non-zero note hash only in 1 of 25 cases in aztec-packages repo\n    // - consider creating a separate function with 1 arg for the zero note hash case.\n    fn push_new_nullifier(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        self.new_nullifiers.push(Nullifier { value: nullifier, note_hash: nullified_note_hash, counter: self.next_counter() });\n    }\n\n    // Returns the header of a block whose state is used during private execution (not the block the transaction is\n    // included in).\n    fn get_header(self) -> Header {\n        self.historical_header\n    }\n\n    // Returns the header of an arbitrary block whose block number is less than or equal to the block number\n    // of historical header.\n    pub fn get_header_at(self, block_number: u32) -> Header {\n        get_header_at(block_number, self)\n    }\n\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        pack_returns(returns_hasher.fields);\n        self.return_hash = returns_hasher.hash();\n    }\n\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            max_block_number: self.max_block_number,\n            note_hash_read_requests: self.note_hash_read_requests.storage,\n            nullifier_read_requests: self.nullifier_read_requests.storage,\n            key_validation_requests_and_generators: self.key_validation_requests_and_generators.storage,\n            new_note_hashes: self.new_note_hashes.storage,\n            new_nullifiers: self.new_nullifiers.storage,\n            private_call_requests: self.private_call_requests.storage,\n            public_call_stack_hashes: self.public_call_stack_hashes.storage,\n            public_teardown_function_hash: self.public_teardown_function_hash,\n            new_l2_to_l1_msgs: self.new_l2_to_l1_msgs.storage,\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            note_encrypted_logs_hashes: self.note_encrypted_logs_hashes.storage,\n            encrypted_logs_hashes: self.encrypted_logs_hashes.storage,\n            unencrypted_logs_hashes: self.unencrypted_logs_hashes.storage,\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context\n        }\n    }\n\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\"Setting {0} as fee payer\", [self.this_address().to_field()]);\n        self.is_fee_payer = true;\n    }\n\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n    }\n\n    // docs:start:max-block-number\n    pub fn set_tx_max_block_number(&mut self, max_block_number: u32) {\n        // docs:end:max-block-number\n        self.max_block_number = MaxBlockNumber::min_with_u32(self.max_block_number, max_block_number);\n    }\n\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index].unwrap_or(KeyValidationRequest::empty());\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one \n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale. We fetch new values from oracle and instruct\n            // protocol circuits to validate them by storing the validation request in context.\n            let request = get_key_validation_request(pk_m_hash, key_index);\n            let request_and_generator = KeyValidationRequestAndGenerator { request, sk_app_generator: sk_generators[key_index] };\n            // We constrain that the pk_m_hash matches the one in the request (otherwise we could get an arbitrary\n            // valid key request and not the one corresponding to pk_m_hash).\n            assert(request.pk_m.hash() == pk_m_hash);\n            self.key_validation_requests_and_generators.push(request_and_generator);\n            self.last_key_validation_requests[key_index] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    // docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content, counter: self.next_counter() };\n        self.new_l2_to_l1_msgs.push(message);\n    }\n\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(&mut self, content: Field, secret: Field, sender: EthAddress) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    // NB: A randomness value of 0 signals that the kernels should not mask the contract address\n    // used in siloing later on e.g. 'handshaking' contract w/ known address.\n    pub fn emit_raw_event_log_with_masked_address<M>(&mut self, randomness: Field, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let contract_address = self.this_address();\n        let len = log.len() as Field + 4;\n        let side_effect = EncryptedLogHash { value: log_hash, counter, length: len, randomness };\n        self.encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_event_log(contract_address, randomness, log, counter);\n    }\n\n    pub fn emit_raw_note_log<M>(&mut self, note_hash_counter: u32, log: [u8; M], log_hash: Field) {\n        let counter = self.next_counter();\n        let len = log.len() as Field + 4;\n        let side_effect = NoteLogHash { value: log_hash, counter, length: len, note_hash_counter };\n        self.note_encrypted_logs_hashes.push(side_effect);\n\n        emit_encrypted_note_log(note_hash_counter, log, counter);\n    }\n\n    pub fn call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_private_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) -> PackedReturns {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_private_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_private_function_no_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_private_function_no_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) -> PackedReturns {\n        self.call_private_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_private_function_with_packed_args<RETURNS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) -> PackedReturns {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n        let item = call_private_function_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            start_side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, start_side_effect_counter);\n        assert_eq(item.public_inputs.start_side_effect_counter, start_side_effect_counter);\n        let end_side_effect_counter = item.public_inputs.end_side_effect_counter;\n        self.side_effect_counter = end_side_effect_counter + 1;\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n\n        let mut caller_context = CallerContext::empty();\n        caller_context.is_static_call = self.inputs.call_context.is_static_call;\n        if is_delegate_call {\n            caller_context.msg_sender = self.inputs.call_context.msg_sender;\n            caller_context.storage_contract_address = self.inputs.call_context.storage_contract_address;\n        }\n        self.private_call_requests.push(\n            PrivateCallRequest { hash: item.hash(), caller_context, start_side_effect_counter, end_side_effect_counter }\n        );\n\n        PackedReturns::new(item.public_inputs.returns_hash)\n    }\n\n    pub fn call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn static_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, true, false)\n    }\n\n    pub fn delegate_call_public_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.call_public_function_with_packed_args(contract_address, function_selector, args_hash, false, true)\n    }\n\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, false)\n    }\n\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, true, false)\n    }\n\n    pub fn delegate_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector\n    ) {\n        self.call_public_function_with_packed_args(contract_address, function_selector, 0, false, true)\n    }\n\n    pub fn call_public_function_with_packed_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = enqueue_public_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_call_stack_hashes.push(item.hash());\n    }\n\n    pub fn set_public_teardown_function<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ARGS_COUNT]\n    ) {\n        let args_hash = hash_args_array(args);\n        assert(args_hash == arguments::pack_arguments_array(args));\n        self.set_public_teardown_function_with_packed_args(contract_address, function_selector, args_hash, false, false)\n    }\n\n    pub fn set_public_teardown_function_with_packed_args<ARGS_COUNT>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let fields = set_public_teardown_function_call_internal(\n            contract_address,\n            function_selector,\n            args_hash,\n            self.side_effect_counter,\n            is_static_call,\n            is_delegate_call\n        );\n\n        let item = parse_public_call_stack_item_from_oracle(fields);\n        self.validate_call_stack_item_from_oracle(\n            item,\n            contract_address,\n            function_selector,\n            args_hash,\n            is_static_call,\n            is_delegate_call\n        );\n\n        self.side_effect_counter = self.side_effect_counter + 1;\n        self.public_teardown_function_hash = item.hash();\n    }\n\n    fn validate_call_stack_item_from_oracle(\n        self,\n        item: PublicCallStackItem,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n        is_delegate_call: bool\n    ) {\n        assert(contract_address.eq(item.contract_address));\n        assert(function_selector.eq(item.function_data.selector));\n\n        assert_eq(item.public_inputs.call_context.side_effect_counter, self.side_effect_counter);\n\n        assert(args_hash == item.public_inputs.args_hash);\n\n        // Assert that the call context of the enqueued call generated by the oracle matches our request.\n        assert(item.public_inputs.call_context.is_delegate_call == is_delegate_call);\n        assert(item.public_inputs.call_context.is_static_call == is_static_call);\n\n        if (is_delegate_call) {\n            // For delegate calls, we also constrain the execution context address for the nested call to be equal to our address.\n            assert(\n                item.public_inputs.call_context.storage_contract_address.eq(self.inputs.call_context.storage_contract_address)\n            );\n            assert(item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.msg_sender));\n        } else {\n            // For non-delegate calls, we also constrain the execution context address for the nested call to be equal to the address we called.\n            assert(item.public_inputs.call_context.storage_contract_address.eq(contract_address));\n            assert(\n                item.public_inputs.call_context.msg_sender.eq(self.inputs.call_context.storage_contract_address)\n            );\n        }\n    }\n\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            new_note_hashes: BoundedVec::new(),\n            new_nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_stack_hashes: BoundedVec::new(),\n            public_teardown_function_hash: 0,\n            new_l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: Header::empty(),\n            note_encrypted_logs_hashes: BoundedVec::new(),\n            encrypted_logs_hashes: BoundedVec::new(),\n            unencrypted_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES]\n        }\n    }\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/aztec-nr/aztec/src/context/private_context.nr"},"135":{"source":"use crate::hash::{compute_secret_hash, compute_message_hash, compute_message_nullifier};\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::traits::{Serialize, Deserialize, Empty};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse crate::context::inputs::public_context_inputs::PublicContextInputs;\nuse crate::context::gas::GasOpts;\n\nstruct PublicContext {\n    inputs: PublicContextInputs,\n}\n\nimpl PublicContext {\n    pub fn new(inputs: PublicContextInputs) -> Self {\n        PublicContext { inputs }\n    }\n\n    pub fn emit_unencrypted_log<T, N>(&mut self, log: T) where T: Serialize<N> {\n        emit_unencrypted_log(Serialize::serialize(log).as_slice());\n    }\n\n    pub fn note_hash_exists(self, note_hash: Field, leaf_index: Field) -> bool {\n        note_hash_exists(note_hash, leaf_index) == 1\n    }\n\n    pub fn l1_to_l2_msg_exists(self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        l1_to_l2_msg_exists(msg_hash, msg_leaf_index) == 1\n    }\n\n    fn nullifier_exists(self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        nullifier_exists(unsiloed_nullifier, address.to_field()) == 1\n    }\n\n    fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/ self.this_address(),\n            self.version(),\n            content,\n            secret_hash\n        );\n        let nullifier = compute_message_nullifier(message_hash, secret, leaf_index);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()), \"L1-to-L2 message is already nullified\"\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index), \"Tried to consume nonexistent L1-to-L2 message\"\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_new_nullifier(nullifier, 0);\n    }\n\n    fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        send_l2_to_l1_msg(recipient, content);\n    }\n\n    fn call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let results = call(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n        let data_to_return: [Field; RETURNS_COUNT] = results.0;\n        let success: u8 = results.1;\n        assert(success == 1, \"Nested call failed!\");\n\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn static_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        let (data_to_return, success): ([Field; RETURNS_COUNT], u8) = call_static(\n            gas_for_call(gas_opts),\n            contract_address,\n            args,\n            function_selector.to_field()\n        );\n\n        assert(success == 1, \"Nested static call failed!\");\n        FunctionReturns::new(data_to_return)\n    }\n\n    fn delegate_call_public_function<RETURNS_COUNT>(\n        self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field]\n    ) -> FunctionReturns<RETURNS_COUNT> {\n        assert(false, \"'delegate_call_public_function' not implemented!\");\n        FunctionReturns::new([0; RETURNS_COUNT])\n    }\n\n    fn push_new_note_hash(&mut self, note_hash: Field) {\n        emit_note_hash(note_hash);\n    }\n    fn push_new_nullifier(&mut self, nullifier: Field, _nullified_commitment: Field) {\n        // Cannot nullify pending commitments in AVM, so `nullified_commitment` is not used\n        emit_nullifier(nullifier);\n    }\n\n    fn this_address(self) -> AztecAddress {\n        address()\n    }\n    pub fn storage_address(self) -> AztecAddress {\n        storage_address()\n    }\n    fn msg_sender(self) -> AztecAddress {\n        sender()\n    }\n    fn selector(self) -> FunctionSelector {\n        FunctionSelector::from_u32(function_selector())\n    }\n    fn get_args_hash(self) -> Field {\n        self.inputs.args_hash\n    }\n    fn transaction_fee(self) -> Field {\n        transaction_fee()\n    }\n\n    fn chain_id(self) -> Field {\n        chain_id()\n    }\n    fn version(self) -> Field {\n        version()\n    }\n    fn block_number(self) -> Field {\n        block_number()\n    }\n    fn timestamp(self) -> u64 {\n        timestamp()\n    }\n    pub fn fee_per_l2_gas(self) -> Field {\n        fee_per_l2_gas()\n    }\n    pub fn fee_per_da_gas(self) -> Field {\n        fee_per_da_gas()\n    }\n\n    fn l2_gas_left(self) -> Field {\n        l2_gas_left()\n    }\n    fn da_gas_left(self) -> Field {\n        da_gas_left()\n    }\n\n    fn raw_storage_read<N>(_self: Self, storage_slot: Field) -> [Field; N] {\n        storage_read(storage_slot)\n    }\n\n    fn storage_read<T, N>(self, storage_slot: Field) -> T where T: Deserialize<N> {\n        T::deserialize(self.raw_storage_read(storage_slot))\n    }\n\n    fn raw_storage_write<N>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        storage_write(storage_slot, values);\n    }\n\n    fn storage_write<T, N>(self, storage_slot: Field, value: T) where T: Serialize<N> {\n        self.raw_storage_write(storage_slot, value.serialize());\n    }\n}\n\n// Helper functions\nfn gas_for_call(user_gas: GasOpts) -> [Field; 2] {\n    // It's ok to use the max possible gas here, because the gas will be\n    // capped by the gas left in the (STATIC)CALL instruction.\n    let MAX_POSSIBLE_FIELD: Field = 0 - 1;\n    [\n        user_gas.l2_gas.unwrap_or(MAX_POSSIBLE_FIELD),\n        user_gas.da_gas.unwrap_or(MAX_POSSIBLE_FIELD)\n    ]\n}\n\n// Unconstrained opcode wrappers (do not use directly).\n// TODO(https://github.com/AztecProtocol/aztec-packages/issues/6420): reconsider.\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn storage_address() -> AztecAddress {\n    storage_address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn portal() -> EthAddress {\n    portal_opcode()\n}\nunconstrained fn function_selector() -> u32 {\n    function_selector_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> Field {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn fee_per_l2_gas() -> Field {\n    fee_per_l2_gas_opcode()\n}\nunconstrained fn fee_per_da_gas() -> Field {\n    fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> Field {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> Field {\n    da_gas_left_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: Field) -> u8 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u8 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_unencrypted_log(message: [Field]) {\n    emit_unencrypted_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: Field) -> u8 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\nunconstrained fn call<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_opcode(gas, address, args, function_selector)\n}\nunconstrained fn call_static<RET_SIZE>(\n    gas: [Field; 2],\n    address: AztecAddress,\n    args: [Field],\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {\n    call_static_opcode(gas, address, args, function_selector)\n}\n\nunconstrained fn storage_read<N>(storage_slot: Field) -> [Field; N] {\n    storage_read_opcode(storage_slot, N)\n}\n\nunconstrained fn storage_write<N>(storage_slot: Field, values: [Field; N]) {\n    storage_write_opcode(storage_slot, values);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(PublicContextInputs::empty())\n    }\n}\n\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeStorageAddress)]\nunconstrained fn storage_address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodePortal)]\nunconstrained fn portal_opcode() -> EthAddress {}\n\n#[oracle(avmOpcodeFunctionSelector)]\nunconstrained fn function_selector_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> Field {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeFeePerL2Gas)]\nunconstrained fn fee_per_l2_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeFeePerDaGas)]\nunconstrained fn fee_per_da_gas_opcode() -> Field {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> Field {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u8 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_unencrypted_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: Field) -> u8 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode<RET_SIZE>(\n    gas: [Field; 2], // gas allocation: [l2_gas, da_gas]\n    address: AztecAddress,\n    args: [Field],\n    // TODO(5110): consider passing in calldata directly\n    function_selector: Field\n) -> ([Field; RET_SIZE], u8) {}\n//    ^ return data      ^ success\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode<N>(storage_slot: Field, length: Field) -> [Field; N] {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode<N>(storage_slot: Field, values: [Field; N]) {}\n\nstruct FunctionReturns<N> {\n    values: [Field; N]\n}\n\nimpl<N> FunctionReturns<N> {\n    pub fn new(values: [Field; N]) -> FunctionReturns<N> {\n        FunctionReturns { values }\n    }\n\n    pub fn assert_empty(returns: FunctionReturns<0>) {\n        assert(returns.values.len() == 0);\n    }\n\n    pub fn raw(self) -> [Field; N] {\n        self.values\n    }\n\n    pub fn deserialize_into<T>(self) -> T where T: Deserialize<N> {\n        Deserialize::deserialize(self.raw())\n    }\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/aztec-nr/aztec/src/context/public_context.nr"},"139":{"source":"use crate::{hash::hash_args_array, oracle::returns::unpack_returns};\nuse dep::protocol_types::traits::Deserialize;\n\nstruct PackedReturns {\n  packed_returns: Field,\n}\n\nimpl PackedReturns {\n    pub fn new(packed_returns: Field) -> Self {\n        PackedReturns { packed_returns }\n    }\n\n    pub fn assert_empty(self) {\n        assert_eq(self.packed_returns, 0);\n    }\n\n    pub fn raw(self) -> Field {\n        self.packed_returns\n    }\n\n    pub fn unpack<N>(self) -> [Field; N] {\n        let unpacked: [Field; N] = unpack_returns(self.packed_returns);\n        assert_eq(self.packed_returns, hash_args_array(unpacked));\n        unpacked\n    }\n\n    pub fn unpack_into<T, N>(self) -> T where T: Deserialize<N> {\n        let unpacked: [Field; N] = self.unpack();\n        Deserialize::deserialize(unpacked)\n    }\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/aztec-nr/aztec/src/context/packed_returns.nr"},"165":{"source":"use crate::{\n    abis::{\n    append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    global_variables::{GlobalVariables, GLOBAL_VARIABLES_LENGTH}\n},\n    constants::{GENERATOR_INDEX__BLOCK_HASH, HEADER_LENGTH, STATE_REFERENCE_LENGTH, CONTENT_COMMITMENT_LENGTH},\n    hash::pedersen_hash, state_reference::StateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice, content_commitment::ContentCommitment\n};\n\n// docs:start:header\nstruct Header {\n    last_archive: AppendOnlyTreeSnapshot,\n    content_commitment: ContentCommitment,\n    state: StateReference,\n    global_variables: GlobalVariables,\n    total_fees: Field\n}\n// docs:end:header\n\nimpl Eq for Header {\n    fn eq(self, other: Self) -> bool {\n        self.last_archive.eq(other.last_archive) &\n        self.content_commitment.eq(other.content_commitment) &\n        self.state.eq(other.state) &\n        self.global_variables.eq(other.global_variables) &\n        self.total_fees.eq(other.total_fees)\n    }\n}\n\nimpl Serialize<HEADER_LENGTH> for Header {\n    fn serialize(self) -> [Field; HEADER_LENGTH] {\n        let mut fields: BoundedVec<Field, HEADER_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.last_archive.serialize());\n        fields.extend_from_array(self.content_commitment.serialize());\n        fields.extend_from_array(self.state.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.total_fees);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<HEADER_LENGTH> for Header {\n    fn deserialize(serialized: [Field; HEADER_LENGTH]) -> Self {\n        let mut offset = 0;\n\n        let last_archive_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let content_commitment_fields = arr_copy_slice(serialized, [0; CONTENT_COMMITMENT_LENGTH], offset);\n        offset = offset + CONTENT_COMMITMENT_LENGTH;\n\n        let state_fields = arr_copy_slice(serialized, [0; STATE_REFERENCE_LENGTH], offset);\n        offset = offset + STATE_REFERENCE_LENGTH;\n\n        let global_variables_fields = arr_copy_slice(serialized, [0; GLOBAL_VARIABLES_LENGTH], offset);\n        offset = offset + GLOBAL_VARIABLES_LENGTH;\n\n        let total_fees = serialized[offset];\n\n        Header {\n            last_archive: AppendOnlyTreeSnapshot::deserialize(last_archive_fields),\n            content_commitment: ContentCommitment::deserialize(content_commitment_fields),\n            state: StateReference::deserialize(state_fields),\n            global_variables: GlobalVariables::deserialize(global_variables_fields),\n            total_fees\n        }\n    }\n}\n\nimpl Empty for Header {\n    fn empty() -> Self {\n        Self {\n            last_archive: AppendOnlyTreeSnapshot::zero(),\n            content_commitment: ContentCommitment::empty(),\n            state: StateReference::empty(),\n            global_variables: GlobalVariables::empty(),\n            total_fees: 0\n        }\n    }\n}\n\nimpl Hash for Header {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__BLOCK_HASH)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let header = Header::empty();\n    let serialized = header.serialize();\n    let deserialized = Header::deserialize(serialized);\n    assert(header.eq(deserialized));\n}\n\n#[test]\nfn hash_smoke() {\n    let header = Header::empty();\n    let _hashed = header.hash();\n}\n\n#[test]\nfn empty_hash_is_zero() {\n    let header = Header::empty();\n    let hash = header.hash();\n\n    // Value from new_contract_data.test.ts \"computes empty hash\" test\n    let test_data_empty_hash = 0x124e8c40a6eca2e3ad10c04050b01a3fad00df3cea47b13592c7571b6914c7a7;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/header.nr"},"175":{"source":"struct Reader<N> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<N> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() as bool\n    }\n\n    pub fn read_array<K>(&mut self, mut result: [Field; K]) -> [Field; K] {\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    // TODO(#4394)\n    pub fn read_struct<T, K>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array([0; K]));\n        result\n    }\n\n    pub fn read_struct_array<T, K, C>(&mut self, deserialise: fn([Field; K]) -> T, mut result: [T; C]) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert(self.offset == self.data.len(), \"Reader did not read all data\");\n    }\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr"},"177":{"source":"pub fn field_from_bytes<N>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes = field.to_be_bytes(31);\n    for i in 0..31 {\n        assert_eq(inputs[i], return_bytes[i]);\n    }\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28, 151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2 = field.to_be_bytes(31);\n\n    for i in 0..31 {\n        assert_eq(return_bytes2[i], return_bytes[i]);\n    }\n    assert_eq(field2, field);\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr"},"178":{"source":"// general util packages/modules are usually bad practice\n// because there is no criteria for what we should not put in here.\n// Reducing the size of this package would be welcome.\n\nmod arrays;\nmod field;\nmod reader;\nmod uint256;\n\n// if predicate == true then return lhs, else return rhs\npub fn conditional_assign(predicate: bool, lhs: Field, rhs: Field) -> Field {\n    if predicate { lhs } else { rhs }\n}\n\npub fn arr_copy_slice<T, N, M>(src: [T; N], mut dst: [T; M], offset: u32) -> [T; M] {\n    let iterator_len = if N > M { M } else { N };\n    for i in 0..iterator_len {\n        dst[i] = src[i + offset];\n    }\n    dst\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/utils/mod.nr"},"182":{"source":"use crate::{\n    abis::{\n    contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n    function_selector::FunctionSelector, log_hash::{LogHash, ScopedLogHash, ScopedEncryptedLogHash},\n    note_hash::ScopedNoteHash, nullifier::ScopedNullifier\n},\n    address::{AztecAddress, EthAddress},\n    constants::{\n    FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__SILOED_NOTE_HASH, GENERATOR_INDEX__OUTER_NULLIFIER,\n    GENERATOR_INDEX__VK, GENERATOR_INDEX__NOTE_HASH_NONCE, GENERATOR_INDEX__UNIQUE_NOTE_HASH,\n    MAX_ENCRYPTED_LOGS_PER_TX, MAX_NOTE_ENCRYPTED_LOGS_PER_TX\n},\n    merkle_tree::root::root_from_sibling_path, messaging::l2_to_l1_message::ScopedL2ToL1Message,\n    recursion::verification_key::VerificationKey, traits::is_empty,\n    utils::field::field_from_bytes_32_trunc\n};\nuse std::hash::{pedersen_hash_with_separator, sha256};\n\npub fn sha256_to_field<N>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT]\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(function_leaf, function_leaf_index, function_leaf_sibling_path)\n}\n\nfn compute_note_hash_nonce(tx_hash: Field, note_index_in_tx: u32) -> Field {\n    // Hashing tx hash with note index in tx is guaranteed to be unique\n    pedersen_hash(\n        [\n        tx_hash,\n        note_index_in_tx as Field\n    ],\n        GENERATOR_INDEX__NOTE_HASH_NONCE\n    )\n}\n\npub fn compute_unique_note_hash(nonce: Field, inner_note_hash: Field) -> Field {\n    let inputs = [nonce, inner_note_hash];\n    pedersen_hash(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, unique_note_hash: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        unique_note_hash\n    ],\n        GENERATOR_INDEX__SILOED_NOTE_HASH\n    )\n}\n\npub fn silo_note_hash(note_hash: ScopedNoteHash, tx_hash: Field, note_index_in_tx: u32) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        let nonce = compute_note_hash_nonce(tx_hash, note_index_in_tx);\n        let unique_note_hash = compute_unique_note_hash(nonce, note_hash.value());\n        compute_siloed_note_hash(note_hash.contract_address, unique_note_hash)\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    pedersen_hash(\n        [\n        app.to_field(),\n        nullifier\n    ],\n        GENERATOR_INDEX__OUTER_NULLIFIER\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    if nullifier.contract_address.is_zero() {\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_encrypted_log_hash(address: AztecAddress, randomness: Field, log_hash: Field) -> Field {\n    // TODO: Using 0 GENERATOR_INDEX here as interim before we move to posiedon\n    // NB: A unique separator will be needed for masked_contract_address\n    let mut masked_contract_address = pedersen_hash([address.to_field(), randomness], 0);\n    if randomness == 0 {\n        // In some cases, we actually want to reveal the contract address we are siloing with:\n        // e.g. 'handshaking' contract w/ known address\n        // An app providing randomness = 0 signals to not mask the address.\n        masked_contract_address = address.to_field();\n    }\n    accumulate_sha256([masked_contract_address, log_hash])\n}\n\npub fn silo_encrypted_log_hash(log_hash: ScopedEncryptedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_encrypted_log_hash(\n            log_hash.contract_address,\n            log_hash.log_hash.randomness,\n            log_hash.log_hash.value\n        )\n    }\n}\n\npub fn compute_siloed_unencrypted_log_hash(address: AztecAddress, log_hash: Field) -> Field {\n    accumulate_sha256([address.to_field(), log_hash])\n}\n\npub fn silo_unencrypted_log_hash(log_hash: ScopedLogHash) -> Field {\n    if log_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_unencrypted_log_hash(log_hash.contract_address, log_hash.value())\n    }\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    pedersen_hash([left, right], 0)\n}\n\npub fn stdlib_recursion_verification_key_compress_native_vk(_vk: VerificationKey) -> Field {\n    // Original cpp code\n    // stdlib::recursion::verification_key<CT::bn254>::compress_native(private_call.vk, GeneratorIndex::VK);\n    // The above cpp method is only ever called on verification key, so it has been special cased here\n    let _hash_index = GENERATOR_INDEX__VK;\n    0\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field\n) -> Field {\n    let mut bytes: BoundedVec<u8, 160> = BoundedVec::new();\n\n    let inputs = [contract_address.to_field(), rollup_version_id, recipient.to_field(), chain_id, content];\n    for i in 0..inputs.len() {\n        // TODO are bytes be in fr.to_buffer() ?\n        let item_bytes = inputs[i].to_be_bytes(32);\n        for j in 0..32 {\n            bytes.push(item_bytes[j]);\n        }\n    }\n\n    sha256_to_field(bytes.storage)\n}\n\npub fn silo_l2_to_l1_message(msg: ScopedL2ToL1Message, rollup_version_id: Field, chain_id: Field) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.message.recipient,\n            msg.message.content,\n            rollup_version_id,\n            chain_id\n        )\n    }\n}\n\n// Computes sha256 hash of 2 input hashes.\n//\n// NB: This method now takes in two 31 byte fields - it assumes that any input\n// is the result of a sha_to_field hash and => is truncated\n//\n// TODO(Jan and David): This is used for the encrypted_log hashes.\n// Can we check to see if we can just use hash_to_field or pedersen_compress here?\n//\npub fn accumulate_sha256(input: [Field; 2]) -> Field {\n    // This is a note about the cpp code, since it takes an array of Fields\n    // instead of a U128.\n    // 4 Field elements when converted to bytes will usually \n    // occupy 4 * 32 = 128 bytes.\n    // However, this function is making the assumption that each Field \n    // only occupies 128 bits.\n    //\n    // TODO(David): This does not seem to be getting guaranteed anywhere in the code?\n\n    // Concatentate two fields into 32x2 = 64 bytes\n    // accumulate_sha256 assumes that the inputs are pre-truncated 31 byte numbers\n    let mut hash_input_flattened = [0; 64];\n    for offset in 0..input.len() {\n        let input_as_bytes = input[offset].to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n\n    sha256_to_field(hash_input_flattened)\n}\n\n// Computes the final logs hash for a tx.\n// NB: this assumes MAX_ENCRYPTED_LOGS_PER_TX == MAX_UNENCRYPTED_LOGS_PER_TX\n// to avoid doubling code, since we can't define the byte len to be 32*N directly. \npub fn compute_tx_logs_hash(logs: [LogHash; MAX_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn compute_tx_note_logs_hash(logs: [LogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_TX]) -> Field {\n    // Convert each field element into a byte array and append the bytes to `hash_input_flattened`\n    let mut hash_input_flattened = [0; MAX_NOTE_ENCRYPTED_LOGS_PER_TX * 32];\n    for offset in 0..MAX_NOTE_ENCRYPTED_LOGS_PER_TX {\n        let input_as_bytes = logs[offset].value.to_be_bytes(32);\n        for byte_index in 0..32 {\n            hash_input_flattened[offset * 32 + byte_index] = input_as_bytes[byte_index];\n        }\n    }\n    // Ideally we would push to a slice then hash, but there is no sha_slice\n    // Hardcode to 256 bytes for now\n    let mut hash = sha256_to_field(hash_input_flattened);\n    // Not having a 0 value hash for empty logs causes issues with empty txs\n    // used for padding. Returning early is currently unsupported.\n    // We always provide sorted logs here, so 0 being empty means all are empty.\n    if is_empty(logs[0]) {\n        hash = 0;\n    }\n    hash\n}\n\npub fn pedersen_hash<N>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<N>(inputs: [Field; N]) -> Field {\n    std::hash::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,\n        20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39,\n        40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n        60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n        80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,\n        100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n        120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139,\n        140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0xb393978842a0fa3d3e1470196f098f473f9678e72463cb65ec4ab5581856c2);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(AztecAddress::from_field(1), EthAddress::from_field(3), 5, 2, 4);\n    assert(hash_result == 0x3f88c1044a05e5340ed20466276500f6d45ca5603913b9091e957161734e16);\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr"},"183":{"source":"use crate::traits::{Serialize, Deserialize};\n\nglobal BOOL_SERIALIZED_LEN: Field = 1;\nglobal U8_SERIALIZED_LEN: Field = 1;\nglobal U32_SERIALIZED_LEN: Field = 1;\nglobal U64_SERIALIZED_LEN: Field = 1;\nglobal U128_SERIALIZED_LEN: Field = 1;\nglobal FIELD_SERIALIZED_LEN: Field = 1;\n\nimpl Serialize<BOOL_SERIALIZED_LEN> for bool {\n    fn serialize(self) -> [Field; BOOL_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<BOOL_SERIALIZED_LEN> for bool {\n    fn deserialize(fields: [Field; BOOL_SERIALIZED_LEN]) -> bool {\n        fields[0] as bool\n    }\n}\n\nimpl Serialize<U8_SERIALIZED_LEN> for u8 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U8_SERIALIZED_LEN> for u8 {\n    fn deserialize(fields: [Field; U8_SERIALIZED_LEN]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize<U32_SERIALIZED_LEN> for u32 {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U32_SERIALIZED_LEN> for u32 {\n    fn deserialize(fields: [Field; U32_SERIALIZED_LEN]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize<U64_SERIALIZED_LEN> for u64 {\n    fn serialize(self) -> [Field; U64_SERIALIZED_LEN] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize<U64_SERIALIZED_LEN> for u64 {\n    fn deserialize(fields: [Field; U64_SERIALIZED_LEN]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize<U128_SERIALIZED_LEN> for U128 {\n    fn serialize(self) -> [Field; 1] {\n        [self.to_integer()]\n    }\n\n}\n\nimpl Deserialize<U128_SERIALIZED_LEN> for U128 {\n    fn deserialize(fields: [Field; U128_SERIALIZED_LEN]) -> Self {\n        U128::from_integer(fields[0])\n    }\n}\n\nimpl Serialize<FIELD_SERIALIZED_LEN> for Field {\n    fn serialize(self) -> [Field; U32_SERIALIZED_LEN] {\n        [self]\n    }\n}\n\nimpl Deserialize<FIELD_SERIALIZED_LEN> for Field {\n    fn deserialize(fields: [Field; FIELD_SERIALIZED_LEN]) -> Self {\n        fields[0]\n    }\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr"},"184":{"source":"use crate::{\n    address::{AztecAddress, EthAddress},\n    constants::{L2_TO_L1_MESSAGE_LENGTH, SCOPED_L2_TO_L1_MESSAGE_LENGTH},\n    abis::side_effect::{Ordered, Scoped}, traits::{Deserialize, Empty, Serialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\n// Note: Not to be confused with L2ToL1Msg in Solidity\nstruct L2ToL1Message {\n    recipient: EthAddress,\n    content: Field,\n    counter: u32,\n}\n\nimpl Ordered for L2ToL1Message {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Empty for L2ToL1Message {\n    fn empty() -> Self {\n        Self {\n            recipient: EthAddress::empty(),\n            content: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Eq for L2ToL1Message {\n    fn eq(self, other: Self) -> bool {\n        (self.recipient == other.recipient) & (self.content == other.content) & (self.counter == other.counter)\n    }\n}\n\nimpl Serialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn serialize(self) -> [Field; L2_TO_L1_MESSAGE_LENGTH] {\n        [self.recipient.to_field(), self.content, self.counter as Field]\n    }\n}\n\nimpl Deserialize<L2_TO_L1_MESSAGE_LENGTH> for L2ToL1Message {\n    fn deserialize(values: [Field; L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        Self {\n            recipient: EthAddress::from_field(values[0]),\n            content: values[1],\n            counter: values[2] as u32,\n        }\n    }\n}\n\nimpl L2ToL1Message {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedL2ToL1Message {\n        ScopedL2ToL1Message { message: self, contract_address }\n    }\n}\n\nstruct ScopedL2ToL1Message {\n    message: L2ToL1Message,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<L2ToL1Message> for ScopedL2ToL1Message {\n    fn inner(self) -> L2ToL1Message {\n        self.message\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedL2ToL1Message {\n    fn counter(self) -> u32 {\n        self.message.counter\n    }\n}\n\nimpl Eq for ScopedL2ToL1Message {\n    fn eq(self, other: ScopedL2ToL1Message) -> bool {\n        (self.message == other.message)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedL2ToL1Message {\n    fn empty() -> Self {\n        ScopedL2ToL1Message {\n            message: L2ToL1Message::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn serialize(self) -> [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH] {\n        array_concat(self.message.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_L2_TO_L1_MESSAGE_LENGTH> for ScopedL2ToL1Message {\n    fn deserialize(values: [Field; SCOPED_L2_TO_L1_MESSAGE_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            message: reader.read_struct(L2ToL1Message::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\n#[test]\nfn serialization_of_empty_l2() {\n    let item = L2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = L2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped_l2() {\n    let item = ScopedL2ToL1Message::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedL2ToL1Message::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/messaging/l2_to_l1_message.nr"},"186":{"source":"use crate::{\n    constants::CONTENT_COMMITMENT_LENGTH, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct ContentCommitment {\n  num_txs: Field,\n  txs_effects_hash: Field,\n  in_hash: Field,\n  out_hash: Field,\n}\n\nimpl Serialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn serialize(self) -> [Field; CONTENT_COMMITMENT_LENGTH] {\n    let mut fields: BoundedVec<Field, CONTENT_COMMITMENT_LENGTH> = BoundedVec::new();\n\n    fields.push(self.num_txs);\n    fields.push(self.txs_effects_hash);\n    fields.push(self.in_hash);\n    fields.push(self.out_hash);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CONTENT_COMMITMENT_LENGTH> for ContentCommitment {\n  fn deserialize(serialized: [Field; CONTENT_COMMITMENT_LENGTH]) -> Self {\n    let num_txs = serialized[0];\n\n    let txs_effects_hash = serialized[1];\n\n    let in_hash = serialized[2];\n\n    let out_hash = serialized[3];\n\n    Self {\n      num_txs,\n      txs_effects_hash,\n      in_hash,\n      out_hash,\n    }\n  }\n}\n\nimpl Empty for ContentCommitment {\n  fn empty() -> Self {\n    Self {\n      num_txs: 0,\n      txs_effects_hash: 0,\n      in_hash: 0,\n      out_hash: 0,\n    }\n  }\n}\n\nimpl Eq for ContentCommitment {\n  fn eq(self, other: Self) -> bool {\n    (self.num_txs == other.num_txs)\n      & (self.txs_effects_hash == other.txs_effects_hash)\n      & (self.in_hash == other.in_hash)\n      & (self.out_hash == other.out_hash)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let empty = ContentCommitment::empty();\n    let serialized = empty.serialize();\n    let deserialized = ContentCommitment::deserialize(serialized);\n\n    assert(empty.eq(deserialized));\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/content_commitment.nr"},"187":{"source":"use crate::{\n    address::{\n    aztec_address::AztecAddress, eth_address::EthAddress, partial_address::PartialAddress,\n    public_keys_hash::PublicKeysHash\n},\n    contract_class_id::ContractClassId,\n    constants::{GENERATOR_INDEX__CONTRACT_DEPLOYMENT_DATA, CONTRACT_INSTANCE_LENGTH},\n    traits::{Deserialize, Hash, Serialize}\n};\n\nstruct ContractInstance {\n    salt : Field,\n    deployer: AztecAddress,\n    contract_class_id : ContractClassId,\n    initialization_hash : Field,\n    public_keys_hash : PublicKeysHash,\n}\n\nimpl Eq for ContractInstance {\n    fn eq(self, other: Self) -> bool {\n        self.public_keys_hash.eq(other.public_keys_hash) &\n        self.initialization_hash.eq(other.initialization_hash) &\n        self.contract_class_id.eq(other.contract_class_id) &\n        self.salt.eq(other.salt)\n    }\n}\n\nimpl Serialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn serialize(self) -> [Field; CONTRACT_INSTANCE_LENGTH] {\n        [\n            self.salt,\n            self.deployer.to_field(),\n            self.contract_class_id.to_field(),\n            self.initialization_hash,\n            self.public_keys_hash.to_field()\n        ]\n    }\n}\n\nimpl Deserialize<CONTRACT_INSTANCE_LENGTH> for ContractInstance {\n    fn deserialize(serialized: [Field; CONTRACT_INSTANCE_LENGTH]) -> Self {\n        Self {\n            salt: serialized[0],\n            deployer: AztecAddress::from_field(serialized[1]),\n            contract_class_id: ContractClassId::from_field(serialized[2]),\n            initialization_hash: serialized[3],\n            public_keys_hash: PublicKeysHash::from_field(serialized[4]),\n        }\n    }\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys_hash,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer\n            )\n        )\n    }\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr"},"191":{"source":"use crate::{\n    abis::side_effect::{Ordered, OrderedValue, Scoped}, address::AztecAddress,\n    constants::{\n    LOG_HASH_LENGTH, NOTE_LOG_HASH_LENGTH, ENCRYPTED_LOG_HASH_LENGTH, SCOPED_LOG_HASH_LENGTH,\n    SCOPED_ENCRYPTED_LOG_HASH_LENGTH\n},\n    traits::{Empty, Serialize, Deserialize}, utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct LogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n}\n\nimpl Ordered for LogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for LogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for LogHash {\n    fn eq(self, other: LogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n    }\n}\n\nimpl Empty for LogHash {\n    fn empty() -> Self {\n        LogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n        }\n    }\n}\n\nimpl Serialize<LOG_HASH_LENGTH> for LogHash {\n    fn serialize(self) -> [Field; LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length]\n    }\n}\n\nimpl Deserialize<LOG_HASH_LENGTH> for LogHash {\n    fn deserialize(values: [Field; LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n        }\n    }\n}\n\nimpl LogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedLogHash {\n        ScopedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedLogHash {\n    log_hash: LogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<LogHash> for ScopedLogHash {\n    fn inner(self) -> LogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedLogHash {\n    fn eq(self, other: ScopedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedLogHash {\n    fn empty() -> Self {\n        ScopedLogHash {\n            log_hash: LogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn serialize(self) -> [Field; SCOPED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_LOG_HASH_LENGTH> for ScopedLogHash {\n    fn deserialize(values: [Field; SCOPED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(LogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the counter when exposing to public.\n        // The log hash must already be siloed when we call this.\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nstruct EncryptedLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    randomness: Field,\n}\n\nimpl Ordered for EncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for EncryptedLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for EncryptedLogHash {\n    fn eq(self, other: EncryptedLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.randomness == other.randomness) \n    }\n}\n\nimpl Empty for EncryptedLogHash {\n    fn empty() -> Self {\n        EncryptedLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            randomness: 0,\n        }\n    }\n}\n\nimpl Serialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn serialize(self) -> [Field; ENCRYPTED_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.randomness]\n    }\n}\n\nimpl Deserialize<ENCRYPTED_LOG_HASH_LENGTH> for EncryptedLogHash {\n    fn deserialize(values: [Field; ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            randomness: values[3],\n        }\n    }\n}\n\nimpl EncryptedLogHash {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedEncryptedLogHash {\n        ScopedEncryptedLogHash { log_hash: self, contract_address }\n    }\n}\n\nstruct ScopedEncryptedLogHash {\n    log_hash: EncryptedLogHash,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<EncryptedLogHash> for ScopedEncryptedLogHash {\n    fn inner(self) -> EncryptedLogHash {\n        self.log_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl ScopedEncryptedLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the secret randomness and counter when exposing to public\n        // Expose as a LogHash rather than EncryptedLogHash to avoid bringing an unnec. 0 value around\n        // The log hash will already be silo'd when we call this\n        LogHash { value: self.log_hash.value, counter: 0, length: self.log_hash.length }\n    }\n}\n\nimpl Ordered for ScopedEncryptedLogHash {\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedEncryptedLogHash {\n    fn value(self) -> Field {\n        self.log_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.log_hash.counter\n    }\n}\n\nimpl Eq for ScopedEncryptedLogHash {\n    fn eq(self, other: ScopedEncryptedLogHash) -> bool {\n        (self.log_hash == other.log_hash)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedEncryptedLogHash {\n    fn empty() -> Self {\n        ScopedEncryptedLogHash {\n            log_hash: EncryptedLogHash::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn serialize(self) -> [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH] {\n       array_concat(self.log_hash.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_ENCRYPTED_LOG_HASH_LENGTH> for ScopedEncryptedLogHash {\n    fn deserialize(values: [Field; SCOPED_ENCRYPTED_LOG_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            log_hash: reader.read_struct(EncryptedLogHash::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nstruct NoteLogHash {\n    value: Field,\n    counter: u32,\n    length: Field,\n    note_hash_counter: u32,\n}\n\nimpl NoteLogHash {\n    pub fn expose_to_public(self) -> LogHash {\n        // Hide the actual counter and note hash counter when exposing it to the public kernel.\n        // The counter is usually note_hash.counter + 1, so it can be revealing.\n        // Expose as a LogHash rather than NoteLogHash to avoid bringing an unnec. 0 value around\n        LogHash { value: self.value, counter: 0, length: self.length }\n    }\n}\n\nimpl Ordered for NoteLogHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for NoteLogHash {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteLogHash {\n    fn eq(self, other: NoteLogHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.length == other.length) \n            & (self.note_hash_counter == other.note_hash_counter) \n    }\n}\n\nimpl Empty for NoteLogHash {\n    fn empty() -> Self {\n        NoteLogHash {\n            value: 0,\n            counter: 0,\n            length: 0,\n            note_hash_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn serialize(self) -> [Field; NOTE_LOG_HASH_LENGTH] {\n        [self.value, self.counter as Field, self.length, self.note_hash_counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_LOG_HASH_LENGTH> for NoteLogHash {\n    fn deserialize(values: [Field; NOTE_LOG_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            length: values[2],\n            note_hash_counter: values[3] as u32,\n        }\n    }\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/log_hash.nr"},"193":{"source":"use crate::{\n    abis::{function_data::FunctionData, private_circuit_public_inputs::PrivateCircuitPublicInputs},\n    address::AztecAddress,\n    constants::{GENERATOR_INDEX__CALL_STACK_ITEM, PRIVATE_CALL_STACK_ITEM_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader\n};\n\nstruct PrivateCallStackItem {\n    // This is the _actual_ contract address relating to where this function's code resides in the\n    // contract tree. Regardless of whether this is a call or delegatecall, this\n    // `contract_address` _does not change_. Amongst other things, it's used as a lookup for\n    // getting the correct code from the tree. There is a separate `storage_contract_address`\n    // within a CallStackItem which varies depending on whether this is a call or delegatecall.\n    contract_address: AztecAddress,\n    function_data: FunctionData,\n    public_inputs: PrivateCircuitPublicInputs,\n}\n\nimpl Eq for PrivateCallStackItem {\n    fn eq(self, other: Self) -> bool {\n        self.contract_address.eq(other.contract_address) &\n        self.function_data.eq(other.function_data) &\n        self.public_inputs.eq(other.public_inputs)\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn serialize(self) -> [Field; PRIVATE_CALL_STACK_ITEM_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_STACK_ITEM_LENGTH> = BoundedVec::new();\n\n        fields.push(self.contract_address.to_field());\n        fields.extend_from_array(self.function_data.serialize());\n        fields.extend_from_array(self.public_inputs.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CALL_STACK_ITEM_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_STACK_ITEM_LENGTH> for PrivateCallStackItem {\n    fn deserialize(serialized: [Field; PRIVATE_CALL_STACK_ITEM_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let item = Self {\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n            function_data: reader.read_struct(FunctionData::deserialize),\n            public_inputs: reader.read_struct(PrivateCircuitPublicInputs::deserialize),\n        };\n\n        reader.finish();\n        item\n    }\n}\n\nimpl Hash for PrivateCallStackItem {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl Empty for PrivateCallStackItem {\n    fn empty() -> Self {\n        PrivateCallStackItem {\n            contract_address: AztecAddress::empty(),\n            function_data: FunctionData::empty(),\n            public_inputs: PrivateCircuitPublicInputs::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = PrivateCallStackItem::empty();\n    let serialized = item.serialize();\n    let deserialized = PrivateCallStackItem::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let mut item = PrivateCallStackItem::empty();\n    item.function_data.is_private = true;\n    let hash = item.hash();\n\n    // Value from private_call_stack_item.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x157022d579f892f06461fb895cdf5550b24329e15e7a41df14f9dad582fa1bc5;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_stack_item.nr"},"194":{"source":"use crate::{\n    address::{AztecAddress, EthAddress}, abis::gas_fees::GasFees,\n    constants::{GENERATOR_INDEX__GLOBAL_VARIABLES, GLOBAL_VARIABLES_LENGTH},\n    traits::{Deserialize, Empty, Hash, Serialize}, utils::reader::Reader\n};\n\n// docs:start:global-variables\nstruct GlobalVariables {\n    chain_id : Field,\n    version : Field,\n    block_number : Field,\n    timestamp : u64,\n    coinbase : EthAddress,\n    fee_recipient : AztecAddress,\n    gas_fees : GasFees\n}\n// docs:end:global-variables\n\nimpl GlobalVariables {\n    fn is_empty(self) -> bool {\n        (self.chain_id == 0)\n            & (self.version == 0)\n            & (self.block_number == 0)\n            & (self.timestamp == 0)\n            & (self.coinbase.is_zero())\n            & (self.fee_recipient.is_zero())\n            & (self.gas_fees.is_empty())\n    }\n}\n\nimpl Serialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn serialize(self) -> [Field; GLOBAL_VARIABLES_LENGTH] {\n        let mut serialized: BoundedVec<Field, GLOBAL_VARIABLES_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.chain_id);\n        serialized.push(self.version);\n        serialized.push(self.block_number);\n        serialized.push(self.timestamp as Field);\n        serialized.push(self.coinbase.to_field());\n        serialized.push(self.fee_recipient.to_field());\n        serialized.extend_from_array(self.gas_fees.serialize());\n\n        serialized.storage\n    }\n}\n\nimpl Deserialize<GLOBAL_VARIABLES_LENGTH> for GlobalVariables {\n    fn deserialize(serialized: [Field; GLOBAL_VARIABLES_LENGTH]) -> GlobalVariables {\n        let mut reader = Reader::new(serialized);\n        GlobalVariables {\n            chain_id: reader.read(),\n            version: reader.read(),\n            block_number: reader.read(),\n            timestamp: reader.read() as u64,\n            coinbase: EthAddress::from_field(reader.read()),\n            fee_recipient: AztecAddress::from_field(reader.read()),\n            gas_fees: reader.read_struct(GasFees::deserialize)\n        }\n    }\n}\n\nimpl Eq for GlobalVariables {\n    fn eq(self, other : GlobalVariables) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.block_number == other.block_number) &\n        (self.timestamp == other.timestamp) &\n        (self.coinbase == other.coinbase) &\n        (self.fee_recipient == other.fee_recipient) &\n        (self.gas_fees == other.gas_fees) \n    }\n}\n\nimpl Empty for GlobalVariables {\n    fn empty() -> Self {\n        Self {\n            chain_id: 0,\n            version: 0,\n            block_number: 0,\n            timestamp: 0,\n            coinbase: EthAddress::empty(),\n            fee_recipient: AztecAddress::empty(),\n            gas_fees: GasFees::empty()\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let vars = GlobalVariables::empty();\n    let _serialized = vars.serialize();\n    let _deserialized = GlobalVariables::deserialize(_serialized);\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/global_variables.nr"},"196":{"source":"global NULLIFIER_LEAF_PREIMAGE_LENGTH: u32 = 3;\n\nuse crate::{\n    abis::{read_request::ScopedReadRequest, side_effect::Readable}, hash::compute_siloed_nullifier,\n    merkle_tree::leaf_preimage::{LeafPreimage, IndexedTreeLeafPreimage}, traits::{Empty, Hash}\n};\n\nstruct NullifierLeafPreimage {\n    nullifier : Field,\n    next_nullifier :Field,\n    next_index : u32,\n}\n\nimpl Empty for NullifierLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            nullifier : 0,\n            next_nullifier : 0,\n            next_index : 0,\n        }\n    }\n}\n\nimpl Hash for NullifierLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash(self.serialize())\n        }\n    }\n}\n\nimpl LeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage for NullifierLeafPreimage {\n    fn get_key(self) -> Field {\n        self.nullifier\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_nullifier\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl Readable for NullifierLeafPreimage {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        let siloed_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.nullifier, siloed_value, \"Value of the nullifier leaf does not match read request\");\n    }\n}\n\nimpl NullifierLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.nullifier == 0) & (self.next_nullifier == 0) & (self.next_index == 0)\n    }\n\n    pub fn serialize(self) -> [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH] {\n        [self.nullifier, self.next_nullifier, self.next_index as Field]\n    }\n\n    pub fn deserialize(fields: [Field; NULLIFIER_LEAF_PREIMAGE_LENGTH]) -> Self {\n        Self { nullifier: fields[0], next_nullifier: fields[1], next_index: fields[2] as u32 }\n    }\n}\n\nimpl Eq for NullifierLeafPreimage {\n  fn eq(self, other: Self) -> bool {\n    (self.nullifier == other.nullifier) &\n    (self.next_nullifier == other.next_nullifier) &\n    (self.next_index == other.next_index)\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NullifierLeafPreimage::empty();\n    let serialized = item.serialize();\n    let deserialized = NullifierLeafPreimage::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier_leaf_preimage.nr"},"197":{"source":"use crate::abis::{function_data::FunctionData, public_circuit_public_inputs::PublicCircuitPublicInputs};\nuse crate::address::AztecAddress;\nuse crate::constants::GENERATOR_INDEX__CALL_STACK_ITEM;\nuse crate::traits::Hash;\n\nstruct PublicCallStackItem {\n    contract_address: AztecAddress,\n    public_inputs: PublicCircuitPublicInputs,\n    function_data: FunctionData,\n    // True if this call stack item represents a request to execute a function rather than a\n    // fulfilled execution. Used when enqueuing calls from private to public functions.\n    is_execution_request: bool,\n}\n\nimpl Hash for PublicCallStackItem {\n    fn hash(self) -> Field {\n        let item = if self.is_execution_request {\n            self.as_execution_request()\n        } else {\n            self\n        };\n\n        std::hash::pedersen_hash_with_separator([\n            item.contract_address.to_field(),\n            item.function_data.hash(),\n            item.public_inputs.hash(),\n        ], GENERATOR_INDEX__CALL_STACK_ITEM)\n    }\n}\n\nimpl PublicCallStackItem {\n    fn as_execution_request(self) -> Self {\n        // WARNING: if updating, see comment in public_call_stack_item.ts's `PublicCallStackItem.hash()`\n        let public_inputs = self.public_inputs;\n        let mut request_public_inputs = PublicCircuitPublicInputs::empty();\n        request_public_inputs.call_context = public_inputs.call_context;\n        request_public_inputs.args_hash = public_inputs.args_hash;\n\n        let call_stack_item = PublicCallStackItem {\n            contract_address: self.contract_address,\n            function_data: self.function_data,\n            is_execution_request: true,\n            public_inputs: request_public_inputs\n        };\n        call_stack_item\n    }\n}\n\nmod tests {\n    use crate::{\n        abis::{\n        function_data::FunctionData, function_selector::FunctionSelector, note_hash::NoteHash,\n        public_circuit_public_inputs::PublicCircuitPublicInputs,\n        public_call_stack_item::PublicCallStackItem\n    },\n        address::AztecAddress, constants::GENERATOR_INDEX__CALL_STACK_ITEM, traits::Hash\n    };\n\n    #[test]\n    fn compute_call_stack_item_request_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_private: false };\n\n        let mut public_inputs = PublicCircuitPublicInputs::empty();\n        public_inputs.new_note_hashes[0] = NoteHash {\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: true, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item request hash\" test\n        let test_data_call_stack_item_request_hash = 0x022a2b82af83606ae5a8d4955ef6215e54025193356318aefbde3b5026952953;\n        assert_eq(call_stack_item.hash(), test_data_call_stack_item_request_hash);\n    }\n\n    #[test]\n    fn compute_call_stack_item_hash() {\n        let contract_address = AztecAddress::from_field(1);\n        let function_data = FunctionData { selector: FunctionSelector::from_u32(2), is_private: false };\n\n        let mut public_inputs = PublicCircuitPublicInputs::empty();\n        public_inputs.new_note_hashes[0] = NoteHash {\n            value: 1,\n            counter: 0,\n        };\n\n        let call_stack_item = PublicCallStackItem { contract_address, public_inputs, is_execution_request: false, function_data };\n\n        // Value from public_call_stack_item.test.ts \"Computes a callstack item hash\" test\n        let test_data_call_stack_item_hash = 0x23a1d22e7bf37df7d68e8fcbfb7e016c060194b7915e3771e2dcd72cea26e427;\n        assert_eq(call_stack_item.hash(), test_data_call_stack_item_hash);\n    }\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_call_stack_item.nr"},"199":{"source":"use crate::{\n    abis::{side_effect::{Ordered, OrderedValue, Readable, Scoped}, read_request::ScopedReadRequest},\n    address::AztecAddress, constants::{NULLIFIER_LENGTH, SCOPED_NULLIFIER_LENGTH},\n    hash::compute_siloed_nullifier, traits::{Empty, Hash, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct Nullifier {\n    value: Field,\n    counter: u32,\n    note_hash: Field,\n}\n\nimpl Ordered for Nullifier {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl OrderedValue<Field> for Nullifier {\n    fn value(self) -> Field {\n        self.value\n    }\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for Nullifier {\n    fn eq(self, other: Nullifier) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter)\n            & (self.note_hash == other.note_hash) \n    }\n}\n\nimpl Empty for Nullifier {\n    fn empty() -> Self {\n        Nullifier {\n            value: 0,\n            counter: 0,\n            note_hash: 0,\n        }\n    }\n}\n\nimpl Serialize<NULLIFIER_LENGTH> for Nullifier {\n    fn serialize(self) -> [Field; NULLIFIER_LENGTH] {\n        [self.value, self.counter as Field, self.note_hash]\n    }\n}\n\nimpl Deserialize<NULLIFIER_LENGTH> for Nullifier {\n    fn deserialize(values: [Field; NULLIFIER_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n            note_hash: values[2],\n        }\n    }\n}\n\nimpl Readable for Nullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        // Public kernels output Nullifier instead of ScopedNullifier.\n        // The nullifier value has been siloed.\n        let siloed_request_value = compute_siloed_nullifier(read_request.contract_address, read_request.value());\n        assert_eq(self.value, siloed_request_value, \"Value of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl Nullifier {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedNullifier {\n        ScopedNullifier { nullifier: self, contract_address }\n    }\n}\n\nstruct ScopedNullifier {\n    nullifier: Nullifier,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<Nullifier> for ScopedNullifier {\n    fn inner(self) -> Nullifier {\n        self.nullifier\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNullifier {\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNullifier {\n    fn value(self) -> Field {\n        self.nullifier.value\n    }\n    fn counter(self) -> u32 {\n        self.nullifier.counter\n    }\n}\n\nimpl Eq for ScopedNullifier {\n    fn eq(self, other: ScopedNullifier) -> bool {\n        (self.nullifier == other.nullifier)\n            & (self.contract_address == other.contract_address) \n    }\n}\n\nimpl Empty for ScopedNullifier {\n    fn empty() -> Self {\n        ScopedNullifier {\n            nullifier: Nullifier::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn serialize(self) -> [Field; SCOPED_NULLIFIER_LENGTH] {\n        array_concat(self.nullifier.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NULLIFIER_LENGTH> for ScopedNullifier {\n    fn deserialize(values: [Field; SCOPED_NULLIFIER_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            nullifier: reader.read_struct(Nullifier::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNullifier {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.nullifier.value, read_request.value(), \"Value of the nullifier does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the nullifier does not match read request\");\n        assert(\n            read_request.counter() > self.nullifier.counter, \"Read request counter must be greater than the counter of the nullifier\"\n        );\n    }\n}\n\nimpl ScopedNullifier {\n    pub fn nullified_note_hash(self) -> Field {\n        self.nullifier.note_hash\n    }\n\n    pub fn expose_to_public(self) -> Nullifier {\n        // Hide the actual counter and note hash when exposing it to the public kernel.\n        Nullifier { value: self.nullifier.value, counter: 0, note_hash: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Nullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = Nullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNullifier::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNullifier::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/nullifier.nr"},"203":{"source":"use crate::{\n    abis::side_effect::{Ordered, Scoped}, traits::{Empty, Serialize, Deserialize},\n    address::AztecAddress, constants::{READ_REQUEST_LENGTH, SCOPED_READ_REQUEST_LEN},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct ReadRequest {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for ReadRequest {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for ReadRequest {\n    fn eq(self, read_request: ReadRequest) -> bool {\n        (self.value == read_request.value)\n        & (self.counter == read_request.counter)\n    }\n}\n\nimpl Empty for ReadRequest {\n    fn empty() -> Self {\n        ReadRequest {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn serialize(self) -> [Field; READ_REQUEST_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<READ_REQUEST_LENGTH> for ReadRequest {\n    fn deserialize(values: [Field; READ_REQUEST_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl ReadRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedReadRequest {\n        ScopedReadRequest { read_request: self, contract_address }\n    }\n}\n\nstruct ScopedReadRequest {\n    read_request: ReadRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<ReadRequest> for ScopedReadRequest {\n    fn inner(self) -> ReadRequest {\n        self.read_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Eq for ScopedReadRequest {\n    fn eq(self, other: ScopedReadRequest) -> bool {\n        (self.read_request == other.read_request)\n        & (self.contract_address.eq(other.contract_address))\n    }\n}\n\nimpl Empty for ScopedReadRequest {\n    fn empty() -> Self {\n        ScopedReadRequest {\n            read_request: ReadRequest::empty(),\n            contract_address: AztecAddress::empty(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn serialize(self) -> [Field; SCOPED_READ_REQUEST_LEN] {\n        array_concat(self.read_request.serialize(), [self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_READ_REQUEST_LEN> for ScopedReadRequest {\n    fn deserialize(values: [Field; SCOPED_READ_REQUEST_LEN]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            read_request: reader.read_struct(ReadRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl ScopedReadRequest {\n    pub fn value(self) -> Field {\n        self.read_request.value\n    }\n    pub fn counter(self) -> u32 {\n        self.read_request.counter\n    }\n}\n\n#[test]\nfn serialization_of_empty_read() {\n    let item = ReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedReadRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedReadRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/read_request.nr"},"204":{"source":"use crate::{constants::MAX_BLOCK_NUMBER_LENGTH, traits::{Deserialize, Serialize, Empty}};\n\nstruct MaxBlockNumber {\n    _opt: Option<u32>\n}\n\nimpl Empty for MaxBlockNumber {\n    fn empty() -> Self {\n        Self { _opt: Option::none() }\n    }\n}\n\nimpl Eq for MaxBlockNumber {\n    fn eq(self, other: Self) -> bool {\n        self._opt == other._opt\n    }\n}\n\nimpl Serialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn serialize(self) -> [Field; MAX_BLOCK_NUMBER_LENGTH] {\n        [self._opt._is_some as Field, self._opt._value as Field]\n    }\n}\n\nimpl Deserialize<MAX_BLOCK_NUMBER_LENGTH> for MaxBlockNumber {\n    fn deserialize(serialized: [Field; MAX_BLOCK_NUMBER_LENGTH]) -> MaxBlockNumber {\n        MaxBlockNumber {\n            _opt: Option {\n                _is_some: serialized[0] as bool,\n                _value: serialized[1] as u32,\n            }\n        }\n    }\n}\n\nimpl MaxBlockNumber {\n    pub fn new(max_block_number: u32) -> Self {\n        Self { _opt: Option::some(max_block_number) }\n    }\n\n    pub fn is_none(self) -> bool {\n        self._opt.is_none()\n    }\n\n    pub fn is_some(self) -> bool {\n        self._opt.is_some()\n    }\n\n    pub fn unwrap(self) -> u32 {\n        self._opt.unwrap()\n    }\n\n    pub fn unwrap_unchecked(self) -> u32 {\n        self._opt.unwrap_unchecked()\n    }\n\n    pub fn min(lhs: MaxBlockNumber, rhs: MaxBlockNumber) -> MaxBlockNumber {\n        if rhs.is_none() {\n            lhs // lhs might also be none, but in that case both would be\n        } else {\n            MaxBlockNumber::min_with_u32(lhs, rhs.unwrap_unchecked())\n        }\n    }\n\n    pub fn min_with_u32(lhs: MaxBlockNumber, rhs: u32) -> MaxBlockNumber {\n        if lhs._opt.is_none() {\n            MaxBlockNumber::new(rhs)\n        } else {\n            let lhs_value = lhs._opt.unwrap_unchecked();\n\n            MaxBlockNumber::new(if lhs_value < rhs { lhs_value } else { rhs })\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = MaxBlockNumber::empty();\n    let serialized = item.serialize();\n    let deserialized = MaxBlockNumber::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn zeroed_is_none() {\n    // Large parts of the kernel rely on zeroed to initialize structs. This conveniently matches what `default` does,\n    // and though we should eventually move everything to use `default`, it's good to check for now that both are\n    // equivalent.\n    let a = MaxBlockNumber::empty();\n    assert(a.is_none());\n}\n\n#[test]\nfn serde_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert(b.is_none());\n}\n\n#[test]\nfn serde_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::deserialize(a.serialize());\n    assert_eq(b.unwrap(), 13);\n}\n\n#[test(should_fail)]\nfn default_unwrap_panics() {\n    let a = MaxBlockNumber::empty();\n    let _ = a.unwrap();\n}\n\n#[test]\nfn min_default_default() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::empty();\n\n    assert(MaxBlockNumber::min(a, b).is_none());\n}\n\n#[test]\nfn min_default_some() {\n    let a = MaxBlockNumber::empty();\n    let b = MaxBlockNumber::new(13);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_some_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = MaxBlockNumber::new(42);\n\n    assert_eq(MaxBlockNumber::min(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min(b, a).unwrap(), 13);\n}\n\n#[test]\nfn min_with_u32_default() {\n    let a = MaxBlockNumber::empty();\n    let b = 42;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 42);\n}\n\n#[test]\nfn min_with_u32_some() {\n    let a = MaxBlockNumber::new(13);\n    let b = 42;\n    let c = 8;\n\n    assert_eq(MaxBlockNumber::min_with_u32(a, b).unwrap(), 13);\n    assert_eq(MaxBlockNumber::min_with_u32(a, c).unwrap(), 8);\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/max_block_number.nr"},"205":{"source":"use crate::{\n    abis::{\n    call_context::CallContext, max_block_number::MaxBlockNumber, gas_settings::GasSettings,\n    validation_requests::KeyValidationRequestAndGenerator, note_hash::NoteHash, nullifier::Nullifier,\n    private_call_request::PrivateCallRequest, read_request::ReadRequest,\n    log_hash::{LogHash, NoteLogHash, EncryptedLogHash}\n},\n    constants::{\n    MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_READ_REQUESTS_PER_CALL,\n    MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NEW_NULLIFIERS_PER_CALL,\n    MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL,\n    MAX_NEW_L2_TO_L1_MSGS_PER_CALL, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH,\n    GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS, MAX_ENCRYPTED_LOGS_PER_CALL,\n    MAX_UNENCRYPTED_LOGS_PER_CALL, MAX_NOTE_ENCRYPTED_LOGS_PER_CALL\n},\n    header::Header, hash::pedersen_hash, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    transaction::tx_context::TxContext, utils::arrays::validate_array\n};\n\nstruct PrivateCircuitPublicInputsArrayLengths {\n    note_hash_read_requests: u32,\n    nullifier_read_requests: u32,\n    key_validation_requests_and_generators: u32,\n    new_note_hashes: u32,\n    new_nullifiers: u32,\n    new_l2_to_l1_msgs: u32,\n    private_call_requests: u32,\n    public_call_stack_hashes: u32,\n    note_encrypted_logs_hashes: u32,\n    encrypted_logs_hashes: u32,\n    unencrypted_logs_hashes: u32,\n}\n\nimpl PrivateCircuitPublicInputsArrayLengths {\n    pub fn new(public_inputs: PrivateCircuitPublicInputs) -> Self {\n        PrivateCircuitPublicInputsArrayLengths {\n            note_hash_read_requests: validate_array(public_inputs.note_hash_read_requests),\n            nullifier_read_requests: validate_array(public_inputs.nullifier_read_requests),\n            key_validation_requests_and_generators: validate_array(public_inputs.key_validation_requests_and_generators),\n            new_note_hashes: validate_array(public_inputs.new_note_hashes),\n            new_nullifiers: validate_array(public_inputs.new_nullifiers),\n            new_l2_to_l1_msgs: validate_array(public_inputs.new_l2_to_l1_msgs),\n            private_call_requests: validate_array(public_inputs.private_call_requests),\n            public_call_stack_hashes: validate_array(public_inputs.public_call_stack_hashes),\n            note_encrypted_logs_hashes: validate_array(public_inputs.note_encrypted_logs_hashes),\n            encrypted_logs_hashes: validate_array(public_inputs.encrypted_logs_hashes),\n            unencrypted_logs_hashes: validate_array(public_inputs.unencrypted_logs_hashes)\n        }\n    }\n}\n\nstruct PrivateCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    min_revertible_side_effect_counter: u32,\n    is_fee_payer: bool,\n\n    max_block_number: MaxBlockNumber,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    key_validation_requests_and_generators: [KeyValidationRequestAndGenerator; MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n\n    new_note_hashes: [NoteHash; MAX_NEW_NOTE_HASHES_PER_CALL],\n    new_nullifiers: [Nullifier; MAX_NEW_NULLIFIERS_PER_CALL],\n    private_call_requests: [PrivateCallRequest; MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    public_teardown_function_hash: Field,\n    new_l2_to_l1_msgs: [L2ToL1Message; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter : u32,\n    end_side_effect_counter : u32,\n    note_encrypted_logs_hashes: [NoteLogHash; MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n    encrypted_logs_hashes: [EncryptedLogHash; MAX_ENCRYPTED_LOGS_PER_CALL],\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    historical_header: Header,\n\n    // Note: The chain_id and version here are not redundant to the values in self.historical_header.global_variables because\n    // they can be different in case of a protocol upgrade. In such a situation we could be using header from a block\n    // before the upgrade took place but be using the updated protocol to execute and prove the transaction.\n    tx_context: TxContext,\n}\n\nimpl Eq for PrivateCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.call_context.eq(other.call_context) &\n        self.args_hash.eq(other.args_hash) &\n        (self.returns_hash == other.returns_hash) &\n        (self.min_revertible_side_effect_counter == other.min_revertible_side_effect_counter) &\n        (self.is_fee_payer == other.is_fee_payer) &\n        (self.max_block_number == other.max_block_number) &\n        (self.note_hash_read_requests == other.note_hash_read_requests) &\n        (self.nullifier_read_requests == other.nullifier_read_requests) &\n        (self.key_validation_requests_and_generators == other.key_validation_requests_and_generators) &\n        (self.new_note_hashes == other.new_note_hashes) &\n        (self.new_nullifiers == other.new_nullifiers) &\n        (self.private_call_requests == other.private_call_requests) &\n        (self.public_call_stack_hashes == other.public_call_stack_hashes) &\n        (self.new_l2_to_l1_msgs == other.new_l2_to_l1_msgs) &\n        (self.start_side_effect_counter == other.start_side_effect_counter) &\n        (self.end_side_effect_counter == other.end_side_effect_counter) &\n        (self.note_encrypted_logs_hashes == other.note_encrypted_logs_hashes) &\n        (self.encrypted_logs_hashes == other.encrypted_logs_hashes) &\n        (self.unencrypted_logs_hashes == other.unencrypted_logs_hashes) &\n        self.historical_header.eq(other.historical_header) &\n        self.tx_context.eq(other.tx_context)\n    }\n}\n\nimpl Serialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn serialize(self) -> [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n\n        fields.push(self.min_revertible_side_effect_counter as Field);\n        fields.push(if self.is_fee_payer { 1 } else { 0 } as Field);\n\n        fields.extend_from_array(self.max_block_number.serialize());\n\n        for i in 0..self.note_hash_read_requests.len() {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..self.nullifier_read_requests.len() {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..self.key_validation_requests_and_generators.len() {\n            fields.extend_from_array(self.key_validation_requests_and_generators[i].serialize());\n        }\n        for i in 0..self.new_note_hashes.len() {\n            fields.extend_from_array(self.new_note_hashes[i].serialize());\n        }\n        for i in 0..self.new_nullifiers.len() {\n            fields.extend_from_array(self.new_nullifiers[i].serialize());\n        }\n        for i in 0..self.private_call_requests.len() {\n            fields.extend_from_array(self.private_call_requests[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n        fields.push(self.public_teardown_function_hash);\n        for i in 0..self.new_l2_to_l1_msgs.len() {\n            fields.extend_from_array(self.new_l2_to_l1_msgs[i].serialize());\n        }\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n        for i in 0..self.note_encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.note_encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.encrypted_logs_hashes.len() {\n            fields.extend_from_array(self.encrypted_logs_hashes[i].serialize());\n        }\n        for i in 0..self.unencrypted_logs_hashes.len() {\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.tx_context.serialize());\n\n        assert_eq(fields.len(), PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PrivateCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PRIVATE_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = Self {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            min_revertible_side_effect_counter: reader.read() as u32,\n            is_fee_payer: reader.read() == 1,\n            max_block_number: reader.read_struct(MaxBlockNumber::deserialize),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            key_validation_requests_and_generators: reader.read_struct_array(KeyValidationRequestAndGenerator::deserialize, [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL]),\n            new_note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL]),\n            new_nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n            private_call_requests: reader.read_struct_array(PrivateCallRequest::deserialize, [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            public_teardown_function_hash: reader.read(),\n            new_l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            note_encrypted_logs_hashes: reader.read_struct_array(NoteLogHash::deserialize, [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL]),\n            encrypted_logs_hashes: reader.read_struct_array(EncryptedLogHash::deserialize, [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL]),\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            tx_context: reader.read_struct(TxContext::deserialize),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PrivateCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PRIVATE_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PrivateCircuitPublicInputs {\n    fn empty() -> Self {\n        PrivateCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            max_block_number: MaxBlockNumber::empty(),\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            key_validation_requests_and_generators: [KeyValidationRequestAndGenerator::empty(); MAX_KEY_VALIDATION_REQUESTS_PER_CALL],\n            new_note_hashes: [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n            new_nullifiers: [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n            private_call_requests: [PrivateCallRequest::empty(); MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            public_teardown_function_hash: 0,\n            new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter : 0 as u32,\n            end_side_effect_counter : 0 as u32,\n            note_encrypted_logs_hashes: [NoteLogHash::empty(); MAX_NOTE_ENCRYPTED_LOGS_PER_CALL],\n            encrypted_logs_hashes: [EncryptedLogHash::empty(); MAX_ENCRYPTED_LOGS_PER_CALL],\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            tx_context: TxContext::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PrivateCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PrivateCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PrivateCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n    // Value from private_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x1eb5048b5bdcea5ba66519ecd1cbdb9e18fd957d52830b2bcb309f4ce9bcfbd3;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_circuit_public_inputs.nr"},"206":{"source":"use crate::{\n    abis::{\n    call_context::CallContext, note_hash::NoteHash, nullifier::Nullifier, read_request::ReadRequest,\n    gas::Gas, global_variables::GlobalVariables, log_hash::LogHash\n},\n    address::AztecAddress,\n    constants::{\n    MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL, MAX_NEW_L2_TO_L1_MSGS_PER_CALL,\n    MAX_NEW_NULLIFIERS_PER_CALL, MAX_NEW_NOTE_HASHES_PER_CALL, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL,\n    MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL,\n    MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL, MAX_PUBLIC_DATA_READS_PER_CALL,\n    MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL, GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS,\n    PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH, MAX_UNENCRYPTED_LOGS_PER_CALL\n},\n    contrakt::{storage_read::StorageRead, storage_update_request::StorageUpdateRequest},\n    hash::pedersen_hash, header::Header, messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Hash, Serialize, Deserialize, Empty}, utils::reader::Reader\n};\n\nstruct PublicCircuitPublicInputs {\n    call_context: CallContext,\n\n    args_hash: Field,\n    returns_hash: Field,\n\n    note_hash_read_requests: [ReadRequest; MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n    nullifier_read_requests: [ReadRequest; MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n    nullifier_non_existent_read_requests: [ReadRequest; MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n    l1_to_l2_msg_read_requests: [ReadRequest; MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n    contract_storage_update_requests: [StorageUpdateRequest; MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n    contract_storage_reads: [StorageRead; MAX_PUBLIC_DATA_READS_PER_CALL],\n\n    // todo: add sideeffect ranges for the input to these hashes\n    public_call_stack_hashes: [Field; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n    new_note_hashes: [NoteHash; MAX_NEW_NOTE_HASHES_PER_CALL],\n    new_nullifiers: [Nullifier; MAX_NEW_NULLIFIERS_PER_CALL],\n    new_l2_to_l1_msgs: [L2ToL1Message; MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n\n    unencrypted_logs_hashes: [LogHash; MAX_UNENCRYPTED_LOGS_PER_CALL],\n\n    // Header of a block whose state is used during public execution. Set by sequencer to be a header of a block\n    // previous to the one in which the tx is included.\n    historical_header: Header,\n\n    // Global variables injected into this circuit\n    global_variables: GlobalVariables,\n\n    prover_address: AztecAddress,\n\n    revert_code: u8,\n    \n    start_gas_left: Gas,\n    end_gas_left: Gas,\n    transaction_fee: Field,\n}\n\nimpl Eq for PublicCircuitPublicInputs {\n    fn eq(self, other: Self) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Serialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn serialize(self) -> [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH] {\n        let mut fields: BoundedVec<Field, PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> = BoundedVec::new();\n        fields.extend_from_array(self.call_context.serialize());\n        fields.push(self.args_hash);\n        fields.push(self.returns_hash);\n        for i in 0..MAX_NOTE_HASH_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.note_hash_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.nullifier_read_requests[i].serialize());\n        }\n        for i in 0..MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.nullifier_non_existent_read_requests[i].serialize());\n        }\n        for i in 0..MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.l1_to_l2_msg_read_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_update_requests[i].serialize());\n        }\n        for i in 0..MAX_PUBLIC_DATA_READS_PER_CALL {\n            fields.extend_from_array(self.contract_storage_reads[i].serialize());\n        }\n        fields.extend_from_array(self.public_call_stack_hashes);\n\n        for i in 0..MAX_NEW_NOTE_HASHES_PER_CALL {\n            fields.extend_from_array(self.new_note_hashes[i].serialize());\n        }\n        for i in 0..MAX_NEW_NULLIFIERS_PER_CALL {\n            fields.extend_from_array(self.new_nullifiers[i].serialize());\n        }\n        for i in 0..MAX_NEW_L2_TO_L1_MSGS_PER_CALL {\n            fields.extend_from_array(self.new_l2_to_l1_msgs[i].serialize());\n        }\n\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        for i in 0..MAX_UNENCRYPTED_LOGS_PER_CALL{\n            fields.extend_from_array(self.unencrypted_logs_hashes[i].serialize());\n        }\n        fields.extend_from_array(self.historical_header.serialize());\n        fields.extend_from_array(self.global_variables.serialize());\n        fields.push(self.prover_address.to_field());\n        fields.push(self.revert_code as Field);\n        fields.extend_from_array(self.start_gas_left.serialize());\n        fields.extend_from_array(self.end_gas_left.serialize());\n        fields.push(self.transaction_fee);\n        fields.storage\n    }\n}\n\nimpl Deserialize<PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH> for PublicCircuitPublicInputs {\n    fn deserialize(serialized: [Field; PUBLIC_CIRCUIT_PUBLIC_INPUTS_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n        let inputs = PublicCircuitPublicInputs {\n            call_context: reader.read_struct(CallContext::deserialize),\n            args_hash: reader.read(),\n            returns_hash: reader.read(),\n            note_hash_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL]),\n            nullifier_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL]),\n            nullifier_non_existent_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL]),\n            l1_to_l2_msg_read_requests: reader.read_struct_array(ReadRequest::deserialize, [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL]),\n            contract_storage_update_requests: reader.read_struct_array(StorageUpdateRequest::deserialize, [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL]),\n            contract_storage_reads: reader.read_struct_array(StorageRead::deserialize, [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL]),\n            public_call_stack_hashes: reader.read_array([0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL]),\n            new_note_hashes: reader.read_struct_array(NoteHash::deserialize, [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL]),\n            new_nullifiers: reader.read_struct_array(Nullifier::deserialize, [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL]),\n            new_l2_to_l1_msgs: reader.read_struct_array(L2ToL1Message::deserialize, [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL]),\n            start_side_effect_counter: reader.read() as u32,\n            end_side_effect_counter: reader.read() as u32,\n            unencrypted_logs_hashes: reader.read_struct_array(LogHash::deserialize, [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL]),\n            historical_header: reader.read_struct(Header::deserialize),\n            global_variables: reader.read_struct(GlobalVariables::deserialize),\n            prover_address: reader.read_struct(AztecAddress::deserialize),\n            revert_code: reader.read() as u8,\n            start_gas_left: reader.read_struct(Gas::deserialize),\n            end_gas_left: reader.read_struct(Gas::deserialize),\n            transaction_fee: reader.read(),\n        };\n\n        reader.finish();\n        inputs\n    }\n}\n\nimpl Hash for PublicCircuitPublicInputs {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__PUBLIC_CIRCUIT_PUBLIC_INPUTS)\n    }\n}\n\nimpl Empty for PublicCircuitPublicInputs {\n    fn empty() -> Self {\n        PublicCircuitPublicInputs {\n            call_context: CallContext::empty(),\n            args_hash: 0,\n            returns_hash: 0,\n            note_hash_read_requests: [ReadRequest::empty(); MAX_NOTE_HASH_READ_REQUESTS_PER_CALL],\n            nullifier_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_READ_REQUESTS_PER_CALL],\n            nullifier_non_existent_read_requests: [ReadRequest::empty(); MAX_NULLIFIER_NON_EXISTENT_READ_REQUESTS_PER_CALL],\n            l1_to_l2_msg_read_requests: [ReadRequest::empty(); MAX_L1_TO_L2_MSG_READ_REQUESTS_PER_CALL],\n            contract_storage_update_requests: [StorageUpdateRequest::empty(); MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_CALL],\n            contract_storage_reads: [StorageRead::empty(); MAX_PUBLIC_DATA_READS_PER_CALL],\n            public_call_stack_hashes: [0; MAX_PUBLIC_CALL_STACK_LENGTH_PER_CALL],\n            new_note_hashes: [NoteHash::empty(); MAX_NEW_NOTE_HASHES_PER_CALL],\n            new_nullifiers: [Nullifier::empty(); MAX_NEW_NULLIFIERS_PER_CALL],\n            new_l2_to_l1_msgs: [L2ToL1Message::empty(); MAX_NEW_L2_TO_L1_MSGS_PER_CALL],\n            start_side_effect_counter: 0 as u32,\n            end_side_effect_counter: 0 as u32,\n            unencrypted_logs_hashes: [LogHash::empty(); MAX_UNENCRYPTED_LOGS_PER_CALL],\n            historical_header: Header::empty(),\n            global_variables: GlobalVariables::empty(),\n            prover_address: AztecAddress::zero(),\n            revert_code: 0 as u8,\n            start_gas_left: Gas::empty(),\n            end_gas_left: Gas::empty(),\n            transaction_fee: 0,\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let pcpi = PublicCircuitPublicInputs::empty();\n    let serialized = pcpi.serialize();\n    let deserialized = PublicCircuitPublicInputs::deserialize(serialized);\n    assert(pcpi.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let inputs = PublicCircuitPublicInputs::empty();\n    let hash = inputs.hash();\n\n    // Value from public_circuit_public_inputs.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x2e08158f3f0d9a94e3f17338aadc3733a15bf5d163f94cef1afd8a47b446d789;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/public_circuit_public_inputs.nr"},"208":{"source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{CALL_CONTEXT_LENGTH, GENERATOR_INDEX__CALL_CONTEXT}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    abis::{gas_settings::GasSettings, gas::Gas}, utils::reader::Reader\n};\n\n// docs:start:call-context\nstruct CallContext {\n    msg_sender : AztecAddress,\n    storage_contract_address : AztecAddress,\n    function_selector : FunctionSelector,\n\n    is_delegate_call : bool,\n    is_static_call : bool,\n\n    side_effect_counter : u32,\n}\n// docs:end:call-context\n\nimpl CallContext {\n    fn assert_is_zero(self) {\n        let serialized: [Field; CALL_CONTEXT_LENGTH] = self.serialize();\n\n        for i in 0..CALL_CONTEXT_LENGTH {\n            assert(serialized[i] == 0);\n        }\n    }\n}\n\nimpl Eq for CallContext {\n    fn eq(self, other: CallContext) -> bool {\n        self.serialize() == other.serialize()\n    }\n}\n\nimpl Hash for CallContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__CALL_CONTEXT)\n    }\n}\n\nimpl Serialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn serialize(self) -> [Field; CALL_CONTEXT_LENGTH] {\n        let mut serialized: BoundedVec<Field, CALL_CONTEXT_LENGTH> = BoundedVec::new();\n\n        serialized.push(self.msg_sender.to_field());\n        serialized.push(self.storage_contract_address.to_field());\n        serialized.push(self.function_selector.to_field());\n        serialized.push(self.is_delegate_call as Field);\n        serialized.push(self.is_static_call as Field);\n        serialized.push(self.side_effect_counter as Field);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<CALL_CONTEXT_LENGTH> for CallContext {\n    fn deserialize(serialized: [Field; CALL_CONTEXT_LENGTH]) -> CallContext {\n        let mut reader = Reader::new(serialized);\n        CallContext {\n            msg_sender: AztecAddress::from_field(reader.read()),\n            storage_contract_address: AztecAddress::from_field(reader.read()),\n            function_selector: FunctionSelector::from_field(reader.read()),\n            is_delegate_call: reader.read() as bool,\n            is_static_call: reader.read() as bool,\n            side_effect_counter: reader.read() as u32,\n        }\n    }\n}\n\nimpl Empty for CallContext {\n    fn empty() -> Self {\n        CallContext {\n            msg_sender: AztecAddress::empty(),\n            storage_contract_address: AztecAddress::empty(),\n            function_selector: FunctionSelector::empty(),\n            is_delegate_call: false,\n            is_static_call: false,\n            side_effect_counter: 0,\n        }\n    }\n}\n\n#[test]\nfn serialize_deserialize_of_empty() {\n    let context = CallContext::empty();\n    let serialized = context.serialize();\n    let deserialized = CallContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn assert_is_zero() {\n    let context = CallContext::empty();\n    context.assert_is_zero();\n}\n\n#[test(should_fail)]\nfn not_zero_assert_is_zero() {\n    let mut context = CallContext::empty();\n    context.is_delegate_call = true;\n    context.assert_is_zero();\n}\n\n#[test]\nfn test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = true;\n\n    let address: AztecAddress = AztecAddress::from_field(69420);\n    context1.msg_sender = address;\n    context2.msg_sender = address;\n\n    assert(context1.eq(context2));\n}\n\n#[test(should_fail)]\nfn not_eq_test_eq() {\n    let mut context1 = CallContext::empty();\n    let mut context2 = CallContext::empty();\n\n    context1.is_delegate_call = true;\n    context2.is_delegate_call = false;\n\n    let address1: AztecAddress = AztecAddress::from_field(69420);\n    let address2: AztecAddress = AztecAddress::from_field(42069);\n\n    context1.msg_sender = address1;\n    context2.msg_sender = address2;\n\n    assert(context1.eq(context2));\n}\n\n#[test]\nfn hash_smoke() {\n    let context = CallContext::empty();\n    let _hashed = context.hash();\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/call_context.nr"},"215":{"source":"use crate::{\n    abis::function_selector::FunctionSelector,\n    constants::{GENERATOR_INDEX__FUNCTION_DATA, FUNCTION_DATA_LENGTH}, hash::pedersen_hash,\n    traits::{Serialize, Hash, Deserialize, Empty}\n};\n\nstruct FunctionData {\n    selector : FunctionSelector,\n    is_private : bool,\n}\n\nimpl Eq for FunctionData {\n    fn eq(self, other: Self) -> bool {\n        self.selector.eq(other.selector) &\n        (self.is_private == other.is_private)\n    }\n}\n\nimpl Serialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    // A field is ~256 bits\n    // TODO(https://github.com/AztecProtocol/aztec-packages/issues/3057): Since, function data can fit into a Field,\n    // This method will simply return a bit packed Field instead of hashing\n    fn serialize(self) -> [Field; FUNCTION_DATA_LENGTH] {\n        [\n            self.selector.to_field(),\n            self.is_private as Field,\n        ]\n    }\n}\n\nimpl Deserialize<FUNCTION_DATA_LENGTH> for FunctionData {\n    fn deserialize(serialized: [Field; FUNCTION_DATA_LENGTH]) -> Self {\n        Self {\n            selector: FunctionSelector::from_field(serialized[0]),\n            is_private: serialized[1] as bool,\n        }\n    }\n}\n\nimpl Hash for FunctionData {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__FUNCTION_DATA)\n    }\n}\n\nimpl Empty for FunctionData {\n    fn empty() -> Self {\n        FunctionData {\n            selector: FunctionSelector::empty(),\n            is_private: false\n        }\n    }\n\n}\n\n#[test]\nfn serialization_of_empty() {\n    let data = FunctionData::empty();\n    let serialized = data.serialize();\n    let deserialized = FunctionData::deserialize(serialized);\n    assert(data.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let data = FunctionData::empty();\n    let hash = data.hash();\n\n    // Value from function_data.test.ts \"computes empty function data hash\" test\n    let test_data_empty_hash = 0x27b1d0839a5b23baf12a8d195b18ac288fcf401afb2f70b8a4b529ede5fa9fed;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_data.nr"},"216":{"source":"struct AppendOnlyTreeSnapshot {\n    root : Field,\n    // TODO(Alvaro) change this to a u64\n    next_available_leaf_index : u32\n}\n\nglobal APPEND_ONLY_TREE_SNAPSHOT_LENGTH: u32 = 2;\n\nimpl AppendOnlyTreeSnapshot {\n    pub fn serialize(self) -> [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH] {\n        [self.root, self.next_available_leaf_index as Field]\n    }\n\n    pub fn deserialize(serialized: [Field; APPEND_ONLY_TREE_SNAPSHOT_LENGTH]) -> AppendOnlyTreeSnapshot {\n        AppendOnlyTreeSnapshot { root: serialized[0], next_available_leaf_index: serialized[1] as u32 }\n    }\n\n    pub fn zero() -> Self {\n        Self { root: 0, next_available_leaf_index: 0 }\n    }\n}\n\nimpl Eq for AppendOnlyTreeSnapshot {\n    fn eq(self, other : AppendOnlyTreeSnapshot) -> bool {\n        (self.root == other.root) & (self.next_available_leaf_index == other.next_available_leaf_index)\n    }\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/append_only_tree_snapshot.nr"},"218":{"source":"use crate::address::AztecAddress;\nuse crate::traits::{Empty, Serialize, Deserialize};\nuse crate::constants::CALLER_CONTEXT_LENGTH;\nuse crate::utils::reader::Reader;\n\nstruct CallerContext {\n    msg_sender: AztecAddress,\n    storage_contract_address: AztecAddress,\n    is_static_call: bool,\n}\n\nimpl Eq for CallerContext {\n    fn eq(self, other: CallerContext) -> bool {\n        other.msg_sender.eq(self.msg_sender)\n            & other.storage_contract_address.eq(self.storage_contract_address)\n            & other.is_static_call == self.is_static_call\n    }\n}\n\nimpl Empty for CallerContext {\n    fn empty() -> Self {\n        CallerContext {\n            msg_sender: AztecAddress::zero(),\n            storage_contract_address: AztecAddress::zero(),\n            is_static_call: false,\n        }\n    }\n}\n\nimpl CallerContext {\n    pub fn is_empty(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero() & !self.is_static_call\n    }\n\n    // Different to an empty context, a hidden context won't reveal the caller's msg_sender and storage_contract_address,\n    // but will still propagate the is_static_call flag.\n    pub fn is_hidden(self) -> bool {\n        self.msg_sender.is_zero() & self.storage_contract_address.is_zero()\n    }\n}\n\nimpl Serialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn serialize(self) -> [Field; CALLER_CONTEXT_LENGTH] {\n    let mut fields: BoundedVec<Field, CALLER_CONTEXT_LENGTH> = BoundedVec::new();\n\n    fields.extend_from_array(self.msg_sender.serialize());\n    fields.extend_from_array(self.storage_contract_address.serialize());\n    fields.push(self.is_static_call as Field);\n\n    assert_eq(fields.len(), CALLER_CONTEXT_LENGTH);\n\n    fields.storage\n  }\n}\n\nimpl Deserialize<CALLER_CONTEXT_LENGTH> for CallerContext {\n  fn deserialize(fields: [Field; CALLER_CONTEXT_LENGTH]) -> CallerContext {\n    let mut reader = Reader::new(fields);\n\n    let item = CallerContext {\n      msg_sender: reader.read_struct(AztecAddress::deserialize),\n      storage_contract_address: reader.read_struct(AztecAddress::deserialize),\n      is_static_call: reader.read_bool(),\n    };\n    reader.finish();\n    item\n  }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = CallerContext::empty();\n    let serialized = item.serialize();\n    let deserialized = CallerContext::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/caller_context.nr"},"220":{"source":"use crate::{\n    abis::read_request::ScopedReadRequest, address::AztecAddress,\n    abis::side_effect::{Ordered, OrderedValue, Readable, Scoped},\n    constants::{NOTE_HASH_LENGTH, SCOPED_NOTE_HASH_LENGTH}, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct NoteHash {\n    value: Field,\n    counter: u32,\n}\n\nimpl Ordered for NoteHash {\n    fn counter(self) -> u32 {\n        self.counter\n    }\n}\n\nimpl Eq for NoteHash {\n    fn eq(self, other: NoteHash) -> bool {\n        (self.value == other.value)\n            & (self.counter == other.counter) \n    }\n}\n\nimpl Empty for NoteHash {\n    fn empty() -> Self {\n        NoteHash {\n            value: 0,\n            counter: 0,\n        }\n    }\n}\n\nimpl Serialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn serialize(self) -> [Field; NOTE_HASH_LENGTH] {\n        [self.value, self.counter as Field]\n    }\n}\n\nimpl Deserialize<NOTE_HASH_LENGTH> for NoteHash {\n    fn deserialize(values: [Field; NOTE_HASH_LENGTH]) -> Self {\n        Self {\n            value: values[0],\n            counter: values[1] as u32,\n        }\n    }\n}\n\nimpl NoteHash {\n    pub fn scope(self, nullifier_counter: u32, contract_address: AztecAddress) -> ScopedNoteHash {\n        ScopedNoteHash { note_hash: self, nullifier_counter, contract_address }\n    }\n}\n\nstruct ScopedNoteHash {\n    note_hash: NoteHash,\n    nullifier_counter: u32,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<NoteHash> for ScopedNoteHash {\n    fn inner(self) -> NoteHash {\n        self.note_hash\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedNoteHash {\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl OrderedValue<Field> for ScopedNoteHash {\n    fn value(self) -> Field {\n        self.note_hash.value\n    }\n    fn counter(self) -> u32 {\n        self.note_hash.counter\n    }\n}\n\nimpl Eq for ScopedNoteHash {\n    fn eq(self, other: ScopedNoteHash) -> bool {\n        (self.note_hash == other.note_hash)\n            & (self.nullifier_counter == other.nullifier_counter)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedNoteHash {\n    fn empty() -> Self {\n        ScopedNoteHash {\n            note_hash: NoteHash::empty(),\n            nullifier_counter: 0,\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn serialize(self) -> [Field; SCOPED_NOTE_HASH_LENGTH] {\n        array_concat(self.note_hash.serialize(), [self.nullifier_counter as Field, self.contract_address.to_field()])\n    }\n}\n\nimpl Deserialize<SCOPED_NOTE_HASH_LENGTH> for ScopedNoteHash {\n    fn deserialize(values: [Field; SCOPED_NOTE_HASH_LENGTH]) -> Self {\n        let mut reader = Reader::new(values);\n        let res = Self {\n            note_hash: reader.read_struct(NoteHash::deserialize),\n            nullifier_counter: reader.read_u32(),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl Readable for ScopedNoteHash {\n    fn assert_match_read_request(self, read_request: ScopedReadRequest) {\n        assert_eq(self.note_hash.value, read_request.value(), \"Value of the note hash does not match read request\");\n        assert_eq(self.contract_address, read_request.contract_address, \"Contract address of the note hash does not match read request\");\n        assert(\n            read_request.counter() > self.note_hash.counter, \"Read request counter must be greater than the counter of the note hash\"\n        );\n        assert(\n            (self.nullifier_counter == 0) | (read_request.counter() < self.nullifier_counter), \"Read request counter must be less than the nullifier counter of the note hash\"\n        );\n    }\n}\n\nimpl ScopedNoteHash {\n    pub fn expose_to_public(self) -> NoteHash {\n        // Hide the actual counter when exposing it to the public kernel.\n        NoteHash { value: self.note_hash.value, counter: 0 }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = NoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = NoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n#[test]\nfn serialization_of_empty_scoped() {\n    let item = ScopedNoteHash::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedNoteHash::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/note_hash.nr"},"231":{"source":"use crate::{\n    constants::KEY_VALIDATION_REQUEST_LENGTH, traits::{Empty, Serialize, Deserialize},\n    grumpkin_point::GrumpkinPoint\n};\n\nstruct KeyValidationRequest {\n    pk_m: GrumpkinPoint,\n    sk_app: Field, // not a grumpkin scalar because it's output of poseidon2\n}\n\nimpl Eq for KeyValidationRequest {\n    fn eq(self, request: KeyValidationRequest) -> bool {\n        (request.pk_m.eq(self.pk_m))\n            & (request.sk_app.eq(self.sk_app))\n    }\n}\n\nimpl Empty for KeyValidationRequest {\n    fn empty() -> Self {\n        KeyValidationRequest {\n            pk_m: GrumpkinPoint::zero(),\n            sk_app: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_LENGTH] {\n        [\n            self.pk_m.x,\n            self.pk_m.y,\n            self.sk_app,\n        ]\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_LENGTH> for KeyValidationRequest {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_LENGTH]) -> Self {\n        Self {\n            pk_m: GrumpkinPoint::new(fields[0], fields[1]),\n            sk_app: fields[2],\n        }\n    }\n}\n\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request.nr"},"233":{"source":"use crate::{\n    address::AztecAddress,\n    abis::validation_requests::{\n    key_validation_request::KeyValidationRequest,\n    scoped_key_validation_request_and_generator::ScopedKeyValidationRequestAndGenerator\n},\n    constants::KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH, traits::{Empty, Serialize, Deserialize},\n    utils::{arrays::array_concat, reader::Reader}\n};\n\nstruct KeyValidationRequestAndGenerator {\n    request: KeyValidationRequest,\n    sk_app_generator: Field,\n}\n\nimpl Eq for KeyValidationRequestAndGenerator {\n    fn eq(self, other: KeyValidationRequestAndGenerator) -> bool {\n        (self.request == other.request) & (self.sk_app_generator == other.sk_app_generator)\n    }\n}\n\nimpl Empty for KeyValidationRequestAndGenerator {\n    fn empty() -> Self {\n        KeyValidationRequestAndGenerator {\n            request: KeyValidationRequest::empty(),\n            sk_app_generator: 0,\n        }\n    }\n}\n\nimpl Serialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn serialize(self) -> [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH] {\n        array_concat(self.request.serialize(), [self.sk_app_generator])\n    }\n}\n\nimpl Deserialize<KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH> for KeyValidationRequestAndGenerator {\n    fn deserialize(fields: [Field; KEY_VALIDATION_REQUEST_AND_GENERATOR_LENGTH]) -> Self {\n        let mut reader = Reader::new(fields);\n        let res = Self {\n            request: reader.read_struct(KeyValidationRequest::deserialize),\n            sk_app_generator: reader.read(),\n        };\n        reader.finish();\n        res\n    }\n}\n\nimpl KeyValidationRequestAndGenerator {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedKeyValidationRequestAndGenerator {\n        ScopedKeyValidationRequestAndGenerator { request: self, contract_address }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = KeyValidationRequestAndGenerator::empty();\n    let serialized = item.serialize();\n    let deserialized = KeyValidationRequestAndGenerator::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/validation_requests/key_validation_request_and_generator.nr"},"236":{"source":"use crate::utils::field::field_from_bytes;\nuse crate::traits::{Serialize, Deserialize, FromField, ToField, Empty};\n\nglobal SELECTOR_SIZE = 4;\n\nstruct FunctionSelector {\n    // 1st 4-bytes of abi-encoding of function.\n    inner: u32,\n}\n\nimpl Eq for FunctionSelector {\n    fn eq(self, function_selector: FunctionSelector) -> bool {\n        function_selector.inner == self.inner\n    }\n}\n\nimpl Serialize<1> for FunctionSelector {\n    fn serialize(self: Self) -> [Field; 1] {\n        [self.inner as Field]\n    }\n}\n\nimpl Deserialize<1> for FunctionSelector {\n    fn deserialize(fields: [Field; 1]) -> Self {\n        Self {\n            inner: fields[0] as u32\n        }\n    }\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<N>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = std::hash::keccak256(bytes, bytes.len() as u32);\n\n        let mut selector_be_bytes = [0; SELECTOR_SIZE];\n        for i in 0..SELECTOR_SIZE {\n            selector_be_bytes[i] = hash[i];\n        }\n\n        FunctionSelector::from_field(field_from_bytes(selector_be_bytes, true))\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr"},"237":{"source":"use crate::{\n    abis::{caller_context::CallerContext, side_effect::{Ordered, RangeOrdered, Scoped}},\n    address::AztecAddress, constants::{PRIVATE_CALL_REQUEST_LENGTH, SCOPED_PRIVATE_CALL_REQUEST_LENGTH},\n    traits::{Empty, Serialize, Deserialize}, utils::reader::Reader\n};\n\nstruct PrivateCallRequest {\n    hash: Field,\n    caller_context: CallerContext,\n    start_side_effect_counter: u32,\n    end_side_effect_counter: u32,\n}\n\nimpl Ordered for PrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.start_side_effect_counter\n    }\n}\n\nimpl RangeOrdered for PrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.start_side_effect_counter\n    }\n    fn counter_end(self) -> u32 {\n        self.end_side_effect_counter\n    }\n}\n\nimpl Eq for PrivateCallRequest {\n    fn eq(self, other: PrivateCallRequest) -> bool {\n        (self.hash == other.hash)\n            & (self.caller_context == other.caller_context)\n            & (self.start_side_effect_counter == other.start_side_effect_counter)\n            & (self.end_side_effect_counter == other.end_side_effect_counter)\n    }\n}\n\nimpl Empty for PrivateCallRequest {\n    fn empty() -> Self {\n        PrivateCallRequest {\n            hash: 0,\n            caller_context: CallerContext::empty(),\n            start_side_effect_counter: 0,\n            end_side_effect_counter: 0,\n        }\n    }\n}\n\nimpl Serialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn serialize(self) -> [Field; PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.push(self.hash);\n        fields.extend_from_array(self.caller_context.serialize());\n        fields.push(self.start_side_effect_counter as Field);\n        fields.push(self.end_side_effect_counter as Field);\n\n        assert_eq(fields.len(), PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<PRIVATE_CALL_REQUEST_LENGTH> for PrivateCallRequest {\n    fn deserialize(fields: [Field; PRIVATE_CALL_REQUEST_LENGTH]) -> PrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = PrivateCallRequest {\n            hash: reader.read(),\n            caller_context: reader.read_struct(CallerContext::deserialize),\n            start_side_effect_counter: reader.read_u32(),\n            end_side_effect_counter: reader.read_u32(),\n        };\n        reader.finish();\n        item\n    }\n}\n\nimpl PrivateCallRequest {\n    pub fn scope(self, contract_address: AztecAddress) -> ScopedPrivateCallRequest {\n        ScopedPrivateCallRequest { call_request: self, contract_address }\n    }\n}\n\nstruct ScopedPrivateCallRequest {\n    call_request: PrivateCallRequest,\n    contract_address: AztecAddress,\n}\n\nimpl Scoped<PrivateCallRequest> for ScopedPrivateCallRequest {\n    fn inner(self) -> PrivateCallRequest {\n        self.call_request\n    }\n    fn contract_address(self) -> AztecAddress {\n        self.contract_address\n    }\n}\n\nimpl Ordered for ScopedPrivateCallRequest {\n    fn counter(self) -> u32 {\n        self.call_request.counter_start()\n    }\n}\n\nimpl RangeOrdered for ScopedPrivateCallRequest {\n    fn counter_start(self) -> u32 {\n        self.call_request.counter_start()\n    }\n    fn counter_end(self) -> u32 {\n        self.call_request.counter_end()\n    }\n}\n\nimpl Eq for ScopedPrivateCallRequest {\n    fn eq(self, other: ScopedPrivateCallRequest) -> bool {\n        (self.call_request == other.call_request)\n            & (self.contract_address == other.contract_address)\n    }\n}\n\nimpl Empty for ScopedPrivateCallRequest {\n    fn empty() -> Self {\n        ScopedPrivateCallRequest {\n            call_request: PrivateCallRequest::empty(),\n            contract_address: AztecAddress::zero(),\n        }\n    }\n}\n\nimpl Serialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn serialize(self) -> [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH] {\n        let mut fields: BoundedVec<Field, SCOPED_PRIVATE_CALL_REQUEST_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.call_request.serialize());\n        fields.extend_from_array(self.contract_address.serialize());\n\n        assert_eq(fields.len(), SCOPED_PRIVATE_CALL_REQUEST_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<SCOPED_PRIVATE_CALL_REQUEST_LENGTH> for ScopedPrivateCallRequest {\n    fn deserialize(fields: [Field; SCOPED_PRIVATE_CALL_REQUEST_LENGTH]) -> ScopedPrivateCallRequest {\n        let mut reader = Reader::new(fields);\n        let item = ScopedPrivateCallRequest {\n            call_request: reader.read_struct(PrivateCallRequest::deserialize),\n            contract_address: reader.read_struct(AztecAddress::deserialize),\n        };\n        reader.finish();\n        item\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = ScopedPrivateCallRequest::empty();\n    let serialized = item.serialize();\n    let deserialized = ScopedPrivateCallRequest::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/private_call_request.nr"},"239":{"source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress}, abis::gas::Gas,\n    abis::gas_fees::GasFees,\n    constants::{\n    GAS_SETTINGS_LENGTH, DEFAULT_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_MAX_FEE_PER_GAS,\n    DEFAULT_INCLUSION_FEE\n},\n    hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered,\n    utils::reader::Reader\n};\n\nstruct GasSettings {\n    gas_limits: Gas,\n    teardown_gas_limits: Gas,\n    max_fees_per_gas: GasFees,\n    inclusion_fee: Field,\n}\n\nimpl GasSettings {\n    pub fn new(\n        gas_limits: Gas,\n        teardown_gas_limits: Gas,\n        max_fees_per_gas: GasFees,\n        inclusion_fee: Field\n    ) -> Self {\n        Self { gas_limits, teardown_gas_limits, max_fees_per_gas, inclusion_fee }\n    }\n\n    pub fn default() -> Self {\n        GasSettings::new(\n            Gas::new(DEFAULT_GAS_LIMIT, DEFAULT_GAS_LIMIT),\n            Gas::new(DEFAULT_TEARDOWN_GAS_LIMIT, DEFAULT_TEARDOWN_GAS_LIMIT),\n            GasFees::new(DEFAULT_MAX_FEE_PER_GAS, DEFAULT_MAX_FEE_PER_GAS),\n            DEFAULT_INCLUSION_FEE\n        )\n    }\n}\n\nimpl Eq for GasSettings {\n    fn eq(self, other: Self) -> bool {\n        (self.gas_limits == other.gas_limits) & (self.teardown_gas_limits == other.teardown_gas_limits) & (self.max_fees_per_gas == other.max_fees_per_gas) & (self.inclusion_fee == other.inclusion_fee)\n    }\n}\n\nimpl Empty for GasSettings {\n    fn empty() -> Self {\n        GasSettings::new(\n            Gas::empty(), Gas::empty(), GasFees::empty(), 0\n        )\n    }\n}\n\nimpl Serialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn serialize(self) -> [Field; GAS_SETTINGS_LENGTH] {\n        let mut serialized: BoundedVec<Field, GAS_SETTINGS_LENGTH> = BoundedVec::new();\n\n        serialized.extend_from_array(self.gas_limits.serialize());\n        serialized.extend_from_array(self.teardown_gas_limits.serialize());\n        serialized.extend_from_array(self.max_fees_per_gas.serialize());\n        serialized.push(self.inclusion_fee);\n    \n        serialized.storage\n    }\n}\n\nimpl Deserialize<GAS_SETTINGS_LENGTH> for GasSettings {\n    fn deserialize(serialized: [Field; GAS_SETTINGS_LENGTH]) -> GasSettings {\n        let mut reader = Reader::new(serialized);\n        GasSettings::new(reader.read_struct(Gas::deserialize), reader.read_struct(Gas::deserialize), reader.read_struct(GasFees::deserialize), reader.read())\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasSettings::empty();\n    let serialized = item.serialize();\n    let deserialized = GasSettings::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_settings.nr"},"241":{"source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::GAS_FEES_LENGTH, hash::pedersen_hash, traits::{Deserialize, Hash, Serialize, Empty},\n    abis::side_effect::Ordered, utils::reader::Reader\n};\n\nstruct GasFees {\n    fee_per_da_gas: Field,\n    fee_per_l2_gas: Field,\n}\n\nimpl GasFees {\n    pub fn new(fee_per_da_gas: Field, fee_per_l2_gas: Field) -> Self {\n        Self { fee_per_da_gas, fee_per_l2_gas }\n    }\n\n    pub fn default() -> Self {\n        GasFees::new(1, 1)\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.fee_per_da_gas == 0) & (self.fee_per_l2_gas == 0)\n    }\n}\n\nimpl Serialize<GAS_FEES_LENGTH> for GasFees {\n    fn serialize(self) -> [Field; GAS_FEES_LENGTH] {\n        [self.fee_per_da_gas, self.fee_per_l2_gas]\n    }\n}\n\nimpl Deserialize<GAS_FEES_LENGTH> for GasFees {\n    fn deserialize(serialized: [Field; GAS_FEES_LENGTH]) -> GasFees {\n        GasFees::new(serialized[0], serialized[1])\n    }\n}\n\nimpl Eq for GasFees {\n    fn eq(self, other : GasFees) -> bool {\n        (self.fee_per_da_gas == other.fee_per_da_gas) & (self.fee_per_l2_gas == other.fee_per_l2_gas)\n    }\n}\n\nimpl Empty for GasFees {\n    fn empty() -> Self {\n        GasFees::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = GasFees::empty();\n    let serialized = item.serialize();\n    let deserialized = GasFees::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas_fees.nr"},"244":{"source":"use crate::{\n    abis::function_selector::FunctionSelector, address::{EthAddress, AztecAddress},\n    constants::{GAS_LENGTH, FIXED_DA_GAS}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, abis::side_effect::Ordered, utils::reader::Reader,\n    abis::gas_fees::GasFees\n};\nuse std::ops::{Add, Sub};\n\nstruct Gas {\n    da_gas: u32,\n    l2_gas: u32,\n}\n\nimpl Gas {\n    pub fn new(da_gas: u32, l2_gas: u32) -> Self {\n        Self { da_gas, l2_gas }\n    }\n\n    pub fn tx_overhead() -> Self {\n        Self { da_gas: FIXED_DA_GAS, l2_gas: 0 }\n    }\n\n    pub fn compute_fee(self, fees: GasFees) -> Field {\n        (self.da_gas as Field) * fees.fee_per_da_gas + (self.l2_gas as Field) * fees.fee_per_l2_gas\n    }\n\n    pub fn is_empty(self) -> bool {\n        (self.da_gas == 0) & (self.l2_gas == 0)\n    }\n\n    pub fn within(self, limits: Gas) -> bool {\n        (self.da_gas <= limits.da_gas) & (self.l2_gas <= limits.l2_gas)\n    }\n}\n\nimpl Add for Gas {\n    fn add(self, other: Gas) -> Self {\n        Gas::new(self.da_gas + other.da_gas, self.l2_gas + other.l2_gas)\n    }\n}\n\nimpl Sub for Gas {\n    fn sub(self, other: Gas) -> Self {\n        Gas::new(self.da_gas - other.da_gas, self.l2_gas - other.l2_gas)\n    }\n}\n\nimpl Serialize<GAS_LENGTH> for Gas {\n    fn serialize(self) -> [Field; GAS_LENGTH] {\n        [self.da_gas as Field, self.l2_gas as Field]\n    }\n}\n\nimpl Deserialize<GAS_LENGTH> for Gas {\n    fn deserialize(serialized: [Field; GAS_LENGTH]) -> Gas {\n        Gas::new(serialized[0] as u32, serialized[1] as u32)\n    }\n}\n\nimpl Eq for Gas {\n    fn eq(self, other : Gas) -> bool {\n        (self.da_gas == other.da_gas) & (self.l2_gas == other.l2_gas)\n    }\n}\n\nimpl Empty for Gas {\n    fn empty() -> Self {\n        Gas::new(0, 0)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let item = Gas::empty();\n    let serialized = item.serialize();\n    let deserialized = Gas::deserialize(serialized);\n    assert(item.eq(deserialized));\n}\n\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/abis/gas.nr"},"247":{"source":"use crate::{\n    abis::append_only_tree_snapshot::{AppendOnlyTreeSnapshot, APPEND_ONLY_TREE_SNAPSHOT_LENGTH},\n    constants::{PARTIAL_STATE_REFERENCE_LENGTH, STATE_REFERENCE_LENGTH},\n    partial_state_reference::PartialStateReference, traits::{Deserialize, Empty, Hash, Serialize},\n    utils::arr_copy_slice\n};\n\nstruct StateReference {\n    l1_to_l2_message_tree: AppendOnlyTreeSnapshot,\n    partial: PartialStateReference,\n}\n\nimpl Eq for StateReference {\n    fn eq(self, other: StateReference) -> bool {\n        self.l1_to_l2_message_tree.eq(other.l1_to_l2_message_tree) &\n        self.partial.eq(other.partial)\n    }\n}\n\nimpl Serialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn serialize(self) -> [Field; STATE_REFERENCE_LENGTH] {\n        let mut fields: BoundedVec<Field, STATE_REFERENCE_LENGTH> = BoundedVec::new();\n\n        fields.extend_from_array(self.l1_to_l2_message_tree.serialize());\n        fields.extend_from_array(self.partial.serialize());\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<STATE_REFERENCE_LENGTH> for StateReference {\n    fn deserialize(serialized: [Field; STATE_REFERENCE_LENGTH]) -> StateReference {\n        let mut offset = 0;\n\n        let l1_to_l2_message_tree_fields = arr_copy_slice(serialized, [0; APPEND_ONLY_TREE_SNAPSHOT_LENGTH], offset);\n        offset = offset + APPEND_ONLY_TREE_SNAPSHOT_LENGTH;\n\n        let partial_fields = arr_copy_slice(serialized, [0; PARTIAL_STATE_REFERENCE_LENGTH], offset);\n\n        StateReference {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::deserialize(l1_to_l2_message_tree_fields),\n            partial: PartialStateReference::deserialize(partial_fields),\n        }\n    }\n}\n\nimpl Empty for StateReference {\n    fn empty() -> Self {\n        Self {\n            l1_to_l2_message_tree: AppendOnlyTreeSnapshot::zero(),\n            partial: PartialStateReference::empty(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let state = StateReference::empty();\n    let _serialized = state.serialize();\n    let _deserialized = StateReference::deserialize(_serialized);\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/state_reference.nr"},"262":{"source":"use crate::{\n    abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot, constants::PARTIAL_STATE_REFERENCE_LENGTH,\n    traits::{Deserialize, Empty, Serialize}\n};\n\nstruct PartialStateReference {\n    note_hash_tree: AppendOnlyTreeSnapshot,\n    nullifier_tree: AppendOnlyTreeSnapshot,\n    public_data_tree: AppendOnlyTreeSnapshot,\n}\n\nimpl Eq for PartialStateReference {\n    fn eq(self, other: PartialStateReference) -> bool {\n        self.note_hash_tree.eq(other.note_hash_tree) &\n        self.nullifier_tree.eq(other.nullifier_tree) &\n        self.public_data_tree.eq(other.public_data_tree)\n    }\n}\n\nimpl Serialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn serialize(self) -> [Field; PARTIAL_STATE_REFERENCE_LENGTH] {\n        let serialized_note_hash_tree = self.note_hash_tree.serialize();\n        let serialized_nullifier_tree = self.nullifier_tree.serialize();\n        let serialized_public_data_tree = self.public_data_tree.serialize();\n\n        [\n            serialized_note_hash_tree[0], \n            serialized_note_hash_tree[1],\n            serialized_nullifier_tree[0],\n            serialized_nullifier_tree[1],\n            serialized_public_data_tree[0],\n            serialized_public_data_tree[1],\n        ]\n    }\n}\n\nimpl Deserialize<PARTIAL_STATE_REFERENCE_LENGTH> for PartialStateReference {\n    fn deserialize(serialized: [Field; PARTIAL_STATE_REFERENCE_LENGTH]) -> PartialStateReference {\n        PartialStateReference {\n            note_hash_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[0], serialized[1]]\n            ),\n            nullifier_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[2], serialized[3]]\n            ),\n            public_data_tree: AppendOnlyTreeSnapshot::deserialize(\n                [serialized[4], serialized[5]]\n            ),\n        }\n    }\n}\n\nimpl Empty for PartialStateReference {\n    fn empty() -> Self {\n        Self {\n            note_hash_tree: AppendOnlyTreeSnapshot::zero(),\n            nullifier_tree: AppendOnlyTreeSnapshot::zero(),\n            public_data_tree: AppendOnlyTreeSnapshot::zero(),\n        }\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let partial = PartialStateReference::empty();\n    let _serialized = partial.serialize();\n    let _deserialized = PartialStateReference::deserialize(_serialized);\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/partial_state_reference.nr"},"265":{"source":"use crate::{\n    constants::{GENERATOR_INDEX__TX_CONTEXT, TX_CONTEXT_LENGTH}, hash::pedersen_hash,\n    traits::{Deserialize, Hash, Serialize, Empty}, utils::reader::Reader,\n    abis::gas_settings::GasSettings\n};\n\n// docs:start:tx-context\nstruct TxContext {\n    chain_id : Field,\n    version : Field,\n    gas_settings: GasSettings,\n}\n// docs:end:tx-context\n\nimpl TxContext {\n    pub fn new(chain_id: Field, version: Field, gas_settings: GasSettings) -> Self {\n        TxContext { chain_id, version, gas_settings }\n    }\n}\n\nimpl Eq for TxContext {\n    fn eq(self, other: Self) -> bool {\n        (self.chain_id == other.chain_id) &\n        (self.version == other.version) &\n        (self.gas_settings.eq(other.gas_settings))\n    }\n}\n\nimpl Empty for TxContext {\n    fn empty() -> Self {\n        TxContext {\n            chain_id: 0,\n            version: 0,\n            gas_settings: GasSettings::empty(),\n        }\n    }\n}\n\nimpl Serialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn serialize(self) -> [Field; TX_CONTEXT_LENGTH] {\n        let mut fields: BoundedVec<Field, TX_CONTEXT_LENGTH> = BoundedVec::new();\n\n        fields.push(self.chain_id);\n        fields.push(self.version);\n        fields.extend_from_array(self.gas_settings.serialize());\n\n        assert_eq(fields.len(), TX_CONTEXT_LENGTH);\n\n        fields.storage\n    }\n}\n\nimpl Deserialize<TX_CONTEXT_LENGTH> for TxContext {\n    fn deserialize(serialized: [Field; TX_CONTEXT_LENGTH]) -> Self {\n        // TODO(#4390): This should accept a reader ^ to avoid copying data.\n        let mut reader = Reader::new(serialized);\n\n        let context = Self {\n            chain_id: reader.read(),\n            version: reader.read(),\n            gas_settings: reader.read_struct(GasSettings::deserialize),\n        };\n\n        reader.finish();\n        context\n    }\n}\n\nimpl Hash for TxContext {\n    fn hash(self) -> Field {\n        pedersen_hash(self.serialize(), GENERATOR_INDEX__TX_CONTEXT)\n    }\n}\n\n#[test]\nfn serialization_of_empty() {\n    let context = TxContext::empty();\n    let serialized = context.serialize();\n    let deserialized = TxContext::deserialize(serialized);\n    assert(context.eq(deserialized));\n}\n\n#[test]\nfn empty_hash() {\n    let context = TxContext::empty();\n    let hash = context.hash();\n\n    // Value from tx_context.test.ts \"computes empty item hash\" test\n    let test_data_empty_hash = 0x17e4357684c5a4349b4587c95b0b6161dcb4a3c5b02d4eb2ecc3b02c80193261;\n    assert_eq(hash, test_data_empty_hash);\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/transaction/tx_context.nr"},"273":{"source":"use crate::{\n    constants::ETH_ADDRESS_LENGTH, hash::pedersen_hash,\n    traits::{Empty, ToField, Serialize, Deserialize}, utils\n};\n\nstruct EthAddress{\n    inner : Field\n}\n\nimpl Eq for EthAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Serialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn serialize(self: Self) -> [Field; ETH_ADDRESS_LENGTH] {\n        [self.inner]\n    }\n}\n\nimpl Deserialize<ETH_ADDRESS_LENGTH> for EthAddress {\n    fn deserialize(fields: [Field; ETH_ADDRESS_LENGTH]) -> Self {\n        EthAddress::from_field(fields[0])\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size(160);\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr"},"274":{"source":"use crate::{\n    crate::address::{eth_address::EthAddress, partial_address::PartialAddress, public_keys_hash::PublicKeysHash},\n    constants::{AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1},\n    contract_class_id::ContractClassId, hash::poseidon2_hash, grumpkin_point::GrumpkinPoint,\n    traits::{Empty, FromField, ToField, Serialize, Deserialize}, utils\n};\n\n// Aztec address\nstruct AztecAddress {\n    inner : Field\n}\n\nimpl Eq for AztecAddress {\n    fn eq(self, other : Self) -> bool {\n        self.to_field() == other.to_field()\n    }\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self {\n            inner : 0\n        }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl Serialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn serialize(self: Self) -> [Field; AZTEC_ADDRESS_LENGTH] {\n        [self.to_field()]\n    }\n}\n\nimpl Deserialize<AZTEC_ADDRESS_LENGTH> for AztecAddress {\n    fn deserialize(fields: [Field; AZTEC_ADDRESS_LENGTH]) -> Self {\n        FromField::from_field(fields[0])\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn compute(pub_keys_hash: PublicKeysHash, partial_address: PartialAddress) -> AztecAddress {\n        AztecAddress::from_field(\n            poseidon2_hash([pub_keys_hash.to_field(), partial_address.to_field(), GENERATOR_INDEX__CONTRACT_ADDRESS_V1])\n        )\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn conditional_assign(predicate: bool, lhs: Self, rhs: Self) -> Self {\n        let result = utils::conditional_assign(predicate, rhs.to_field(), lhs.to_field());\n        Self { inner: result }\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys_hash() {\n    let pub_keys_hash = PublicKeysHash::from_field(1);\n    let partial_address = PartialAddress::from_field(2);\n\n    let address = AztecAddress::compute(pub_keys_hash, partial_address);\n    let expected_computed_address_from_partial_and_pubkey = 0x1b6ead051e7b42665064ca6cf1ec77da0a36d86e00d1ff6e44077966c0c3a9fa;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(Deserialize::deserialize(address.serialize()), address);\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr"},"278":{"source":"use crate::{merkle_tree::leaf_preimage::IndexedTreeLeafPreimage, traits::{Empty, Hash}};\n\nstruct PublicDataTreeLeafPreimage {\n    slot : Field,\n    value: Field,\n    next_slot :Field,\n    next_index : u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self {\n            slot: 0,\n            value: 0,\n            next_slot: 0,\n            next_index: 0,\n        }\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            std::hash::pedersen_hash([self.slot, self.value, (self.next_index as Field), self.next_slot])\n        }\n    }\n}\n\nimpl IndexedTreeLeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-protocol-circuits/crates/types/src/public_data_tree_leaf_preimage.nr"},"294":{"source":"// docs:start:token_all\n// docs:start:imports\nmod types;\nmod test;\n\n// Minimal token implementation that supports `AuthWit` accounts.\n// The auth message follows a similar pattern to the cross-chain message and includes a designated caller.\n// The designated caller is ALWAYS used here, and not based on a flag as cross-chain.\n// message hash = H([caller, contract, selector, ...args])\n// To be read as `caller` calls function at `contract` defined by `selector` with `args`\n// Including a nonce in the message hash ensures that the message can only be used once.\n\ncontract Token {\n    // Libs\n\n    use dep::compressed_string::FieldCompressedString;\n\n    use dep::aztec::{\n        hash::compute_secret_hash,\n        prelude::{NoteGetterOptions, Map, PublicMutable, SharedImmutable, PrivateSet, AztecAddress},\n        encrypted_logs::{\n        encrypted_note_emission::{\n        encode_and_encrypt_note, encode_and_encrypt_note_with_keys,\n        encode_and_encrypt_note_with_keys_unconstrained\n    },\n        encrypted_event_emission::{encode_and_encrypt_event, encode_and_encrypt_event_with_keys_unconstrained}\n    }\n    };\n\n    // docs:start:import_authwit\n    use dep::authwit::auth::{assert_current_call_valid_authwit, assert_current_call_valid_authwit_public, compute_authwit_nullifier};\n    // docs:end:import_authwit\n\n    use crate::types::{transparent_note::TransparentNote, token_note::{TokenNote, TOKEN_NOTE_LEN}, balances_map::BalancesMap};\n    // docs:end::imports\n\n    #[aztec(event)]\n    struct Transfer {\n        from: Field,\n        to: Field,\n        amount: Field,\n    }\n\n    // docs:start:storage_struct\n    #[aztec(storage)]\n    struct Storage {\n        // docs:start:storage_admin\n        admin: PublicMutable<AztecAddress>,\n        // docs:end:storage_admin\n        // docs:start:storage_minters\n        minters: Map<AztecAddress, PublicMutable<bool>>,\n        // docs:end:storage_minters\n        // docs:start:storage_balances\n        balances: BalancesMap<TokenNote>,\n        // docs:end:storage_balances\n        total_supply: PublicMutable<U128>,\n        // docs:start:storage_pending_shields\n        pending_shields: PrivateSet<TransparentNote>,\n        // docs:end:storage_pending_shields\n        public_balances: Map<AztecAddress, PublicMutable<U128>>,\n        symbol: SharedImmutable<FieldCompressedString>,\n        name: SharedImmutable<FieldCompressedString>,\n        // docs:start:storage_decimals\n        decimals: SharedImmutable<u8>,\n        // docs:end:storage_decimals\n    }\n    // docs:end:storage_struct\n\n    // docs:start:constructor\n    #[aztec(public)]\n    #[aztec(initializer)]\n    fn constructor(admin: AztecAddress, name: str<31>, symbol: str<31>, decimals: u8) {\n        assert(!admin.is_zero(), \"invalid admin\");\n        storage.admin.write(admin);\n        storage.minters.at(admin).write(true);\n        storage.name.initialize(FieldCompressedString::from_string(name));\n        storage.symbol.initialize(FieldCompressedString::from_string(symbol));\n        // docs:start:initialize_decimals\n        storage.decimals.initialize(decimals);\n        // docs:end:initialize_decimals\n    }\n    // docs:end:constructor\n\n    // docs:start:set_admin\n    #[aztec(public)]\n    fn set_admin(new_admin: AztecAddress) {\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:start:write_admin\n        storage.admin.write(new_admin);\n        // docs:end:write_admin\n    }\n    // docs:end:set_admin\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_name() -> pub FieldCompressedString {\n        storage.name.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_name() -> pub FieldCompressedString {\n        storage.name.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_public()\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_symbol() -> pub FieldCompressedString {\n        storage.symbol.read_private()\n    }\n\n    #[aztec(public)]\n    #[aztec(view)]\n    fn public_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_public\n        storage.decimals.read_public()\n        // docs:end:read_decimals_public\n    }\n\n    #[aztec(private)]\n    #[aztec(view)]\n    fn private_get_decimals() -> pub u8 {\n        // docs:start:read_decimals_private\n        storage.decimals.read_private()\n        // docs:end:read_decimals_private\n    }\n\n    // docs:start:admin\n    #[aztec(public)]\n    #[aztec(view)]\n    fn admin() -> Field {\n        storage.admin.read().to_field()\n    }\n    // docs:end:admin\n\n    // docs:start:is_minter\n    #[aztec(public)]\n    #[aztec(view)]\n    fn is_minter(minter: AztecAddress) -> bool {\n        storage.minters.at(minter).read()\n    }\n    // docs:end:is_minter\n\n    // docs:start:total_supply\n    #[aztec(public)]\n    #[aztec(view)]\n    fn total_supply() -> Field {\n        storage.total_supply.read().to_integer()\n    }\n    // docs:end:total_supply\n\n    // docs:start:balance_of_public\n    #[aztec(public)]\n    #[aztec(view)]\n    fn balance_of_public(owner: AztecAddress) -> Field {\n        storage.public_balances.at(owner).read().to_integer()\n    }\n    // docs:end:balance_of_public\n\n    // docs:start:set_minter\n    #[aztec(public)]\n    fn set_minter(minter: AztecAddress, approve: bool) {\n        // docs:start:read_admin\n        assert(storage.admin.read().eq(context.msg_sender()), \"caller is not admin\");\n        // docs:end:read_admin\n        // docs:start:write_minter\n        storage.minters.at(minter).write(approve);\n        // docs:end:write_minter\n    }\n    // docs:end:set_minter\n\n    // docs:start:mint_public\n    #[aztec(public)]\n    fn mint_public(to: AztecAddress, amount: Field) {\n        // docs:start:read_minter\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        // docs:end:read_minter\n        let amount = U128::from_integer(amount);\n        let new_balance = storage.public_balances.at(to).read().add(amount);\n        let supply = storage.total_supply.read().add(amount);\n\n        storage.public_balances.at(to).write(new_balance);\n        storage.total_supply.write(supply);\n    }\n    // docs:end:mint_public\n\n    // docs:start:mint_private\n    #[aztec(public)]\n    fn mint_private(amount: Field, secret_hash: Field) {\n        assert(storage.minters.at(context.msg_sender()).read(), \"caller is not minter\");\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount, secret_hash);\n        let supply = storage.total_supply.read().add(U128::from_integer(amount));\n\n        storage.total_supply.write(supply);\n        // docs:start:insert_from_public\n        pending_shields.insert_from_public(&mut note);\n        // docs:end:insert_from_public\n    }\n    // docs:end:mint_private\n\n    // TODO: Nuke this - test functions do not belong to token contract!\n    #[aztec(private)]\n    fn privately_mint_private_note(amount: Field) {\n        let caller = context.msg_sender();\n        storage.balances.add(caller, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, caller, caller));\n\n        Token::at(context.this_address()).assert_minter_and_mint(context.msg_sender(), amount).enqueue(&mut context);\n    }\n\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn assert_minter_and_mint(minter: AztecAddress, amount: Field) {\n        assert(storage.minters.at(minter).read(), \"caller is not minter\");\n        let supply = storage.total_supply.read() + U128::from_integer(amount);\n        storage.total_supply.write(supply);\n    }\n\n    // docs:start:shield\n    #[aztec(public)]\n    fn shield(from: AztecAddress, amount: Field, secret_hash: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            // The redeem is only spendable once, so we need to ensure that you cannot insert multiple shields from the same message.\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n\n        let pending_shields = storage.pending_shields;\n        let mut note = TransparentNote::new(amount.to_field(), secret_hash);\n\n        storage.public_balances.at(from).write(from_balance);\n        pending_shields.insert_from_public(&mut note);\n    }\n    // docs:end:shield\n\n    // docs:start:transfer_public\n    #[aztec(public)]\n    fn transfer_public(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let to_balance = storage.public_balances.at(to).read().add(amount);\n        storage.public_balances.at(to).write(to_balance);\n    }\n    // docs:end:transfer_public\n\n    // docs:start:burn_public\n    #[aztec(public)]\n    fn burn_public(from: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit_public\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit_public\n\n        let amount = U128::from_integer(amount);\n        let from_balance = storage.public_balances.at(from).read().sub(amount);\n        storage.public_balances.at(from).write(from_balance);\n\n        let new_supply = storage.total_supply.read().sub(amount);\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:burn_public\n\n    // docs:start:redeem_shield\n    #[aztec(private)]\n    fn redeem_shield(to: AztecAddress, amount: Field, secret: Field) {\n        let pending_shields = storage.pending_shields;\n        let secret_hash = compute_secret_hash(secret);\n        // Get 1 note (set_limit(1)) which has amount stored in field with index 0 (select(0, amount)) and secret_hash\n        // stored in field with index 1 (select(1, secret_hash)).\n        let mut options = NoteGetterOptions::new();\n        options = options.select(TransparentNote::properties().amount, amount, Option::none()).select(\n            TransparentNote::properties().secret_hash,\n            secret_hash,\n            Option::none()\n        ).set_limit(1);\n        let notes = pending_shields.get_notes(options);\n        let note = notes.get_unchecked(0);\n        // Remove the note from the pending shields set\n        pending_shields.remove(note);\n\n        // Add the token note to user's balances set\n        // Note: Using context.msg_sender() as a sender below makes this incompatible with escrows because we send\n        // outgoing logs to that address and to send outgoing logs you need to get a hold of ovsk_m.\n        let from = context.msg_sender();\n        storage.balances.add(to, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, to));\n    }\n    // docs:end:redeem_shield\n\n    // docs:start:unshield\n    #[aztec(private)]\n    fn unshield(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, from));\n\n        Token::at(context.this_address())._increase_public_balance(to, amount).enqueue(&mut context);\n    }\n    // docs:end:unshield\n\n    // docs:start:transfer\n    #[aztec(private)]\n    fn transfer(to: AztecAddress, amount: Field) {\n        let from = context.msg_sender();\n\n        // By fetching the keys here, we can avoid doing an extra read from the storage, since from_ovpk would\n        // be needed twice.\n        let header = context.get_header();\n        let from_ovpk = header.get_ovpk_m(&mut context, from);\n        let from_ivpk = header.get_ivpk_m(&mut context, from);\n        let to_ivpk = header.get_ivpk_m(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        storage.balances.sub(from, amount).emit(encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_ovpk, from_ivpk));\n        storage.balances.add(to, amount).emit(encode_and_encrypt_note_with_keys_unconstrained(&mut context, from_ovpk, to_ivpk));\n\n        Transfer { from: from.to_field(), to: to.to_field(), amount: amount.to_field() }.emit(encode_and_encrypt_event_with_keys_unconstrained(&mut context, from_ovpk, to_ivpk));\n    }\n    // docs:end:transfer\n\n    /**\n     * Cancel a private authentication witness.\n     * @param inner_hash The inner hash of the authwit to cancel.\n     */\n    #[aztec(private)]\n    fn cancel_authwit(inner_hash: Field) {\n        let on_behalf_of = context.msg_sender();\n        let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n        context.push_new_nullifier(nullifier, 0);\n    }\n\n    #[aztec(private)]\n    fn transfer_from(from: AztecAddress, to: AztecAddress, amount: Field, nonce: Field) {\n        // docs:start:assert_current_call_valid_authwit\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n        // docs:end:assert_current_call_valid_authwit\n\n        // By fetching the keys here, we can avoid doing an extra read from the storage, since from_ovpk would\n        // be needed twice.\n        let header = context.get_header();\n        let from_ovpk = header.get_ovpk_m(&mut context, from);\n        let from_ivpk = header.get_ivpk_m(&mut context, from);\n        let to_ivpk = header.get_ivpk_m(&mut context, to);\n\n        let amount = U128::from_integer(amount);\n        // docs:start:increase_private_balance\n        // docs:start:encrypted\n        storage.balances.sub(from, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_ovpk, from_ivpk));\n        // docs:end:encrypted\n        // docs:end:increase_private_balance\n        storage.balances.add(to, amount).emit(encode_and_encrypt_note_with_keys(&mut context, from_ovpk, to_ivpk));\n    }\n\n    // docs:start:burn\n    #[aztec(private)]\n    fn burn(from: AztecAddress, amount: Field, nonce: Field) {\n        if (!from.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit(&mut context, from);\n        } else {\n            assert(nonce == 0, \"invalid nonce\");\n        }\n\n        storage.balances.sub(from, U128::from_integer(amount)).emit(encode_and_encrypt_note(&mut context, from, from));\n\n        Token::at(context.this_address())._reduce_total_supply(amount).enqueue(&mut context);\n    }\n    // docs:end:burn\n\n    /// Internal ///\n\n    // docs:start:increase_public_balance\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _increase_public_balance(to: AztecAddress, amount: Field) {\n        let new_balance = storage.public_balances.at(to).read().add(U128::from_integer(amount));\n        storage.public_balances.at(to).write(new_balance);\n    }\n    // docs:end:increase_public_balance\n\n    // docs:start:reduce_total_supply\n    #[aztec(public)]\n    #[aztec(internal)]\n    fn _reduce_total_supply(amount: Field) {\n        // Only to be called from burn.\n        let new_supply = storage.total_supply.read().sub(U128::from_integer(amount));\n        storage.total_supply.write(new_supply);\n    }\n    // docs:end:reduce_total_supply\n\n    /// Unconstrained ///\n\n    // docs:start:balance_of_private\n    unconstrained fn balance_of_private(owner: AztecAddress) -> pub Field {\n        storage.balances.balance_of(owner).to_field()\n    }\n    // docs:end:balance_of_private\n}\n// docs:end:token_all","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-contracts/contracts/token_contract/src/main.nr"},"307":{"source":"// docs:start:mint_public_content_hash_nr\nuse dep::aztec::prelude::{AztecAddress, EthAddress};\nuse dep::aztec::protocol_types::hash::sha256_to_field;\n\n// Computes a content hash of a deposit/mint_public message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_public_content_hash(owner: AztecAddress, amount: Field) -> Field {\n    let mut hash_bytes = [0; 68];\n    let recipient_bytes = owner.to_field().to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0x3e87b9be keccak256('mint_public(bytes32,uint256)')\n    hash_bytes[0] = 0x3e;\n    hash_bytes[1] = 0x87;\n    hash_bytes[2] = 0xb9;\n    hash_bytes[3] = 0xbe;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:mint_public_content_hash_nr\n\n// docs:start:get_mint_private_content_hash\n// Computes a content hash of a deposit/mint_private message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_private_content_hash(\n    secret_hash_for_redeeming_minted_notes: Field,\n    amount: Field\n) -> Field {\n    let mut hash_bytes = [0; 68];\n    let secret_hash_bytes = secret_hash_for_redeeming_minted_notes.to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = secret_hash_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    // Function selector: 0xefa012c1 keccak256('mint_private(bytes32,uint256)')\n    hash_bytes[0] = 0xef;\n    hash_bytes[1] = 0xa0;\n    hash_bytes[2] = 0x12;\n    hash_bytes[3] = 0xc1;\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_mint_private_content_hash\n\n// docs:start:get_withdraw_content_hash\n// Computes a content hash of a withdraw message.\npub fn get_withdraw_content_hash(recipient: EthAddress, amount: Field, caller_on_l1: EthAddress) -> Field {\n    // Compute the content hash\n    // Compute sha256(selector || amount || recipient)\n    // then convert to a single field element\n    // add that to the l2 to l1 messages\n    let mut hash_bytes: [u8; 100] = [0; 100];\n    let recipient_bytes = recipient.to_field().to_be_bytes(32);\n    let amount_bytes = amount.to_be_bytes(32);\n    let caller_on_l1_bytes = caller_on_l1.to_field().to_be_bytes(32);\n\n    //  0x69328dec, selector for \"withdraw(address,uint256,address)\"\n    hash_bytes[0] = 0x69;\n    hash_bytes[1] = 0x32;\n    hash_bytes[2] = 0x8d;\n    hash_bytes[3] = 0xec;\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n        hash_bytes[i + 68] = caller_on_l1_bytes[i];\n    }\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_withdraw_content_hash\n","path":"/home/muzzamil/nargo/github.com/AztecProtocol/aztec-packages/aztec-packages-v0.45.0/noir-projects/noir-contracts/contracts/token_portal_content_hash_lib/src/lib.nr"}}}